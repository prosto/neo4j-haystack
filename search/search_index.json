{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"neo4j-haystack <p>A Haystack Document Store for Neo4j.</p> <p> </p> <p>Table of Contents</p> <ul> <li>Overview</li> <li>Installation</li> <li>Usage</li> <li>Running Neo4j</li> <li>Document Store</li> <li>Indexing documents</li> <li>Retrieving documents</li> <li>Retrieving documents using Cypher</li> <li>More examples</li> <li>License</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>An integration of Neo4j graph database with Haystack v2.0 by deepset. In Neo4j Vector search index is being used for storing document embeddings and dense retrievals.</p> <p>The library allows using Neo4j as a DocumentStore, and implements the required Protocol methods. You can start working with the implementation by importing it from <code>neo4_haystack</code> package:</p> <pre><code>from neo4j_haystack import Neo4jDocumentStore\n</code></pre> <p>In addition to the <code>Neo4jDocumentStore</code> the library includes the following haystack components which can be used in a pipeline:</p> <ul> <li>Neo4jEmbeddingRetriever - is a typical retriever component which can be used to query vector store index and find related Documents. The component uses <code>Neo4jDocumentStore</code> to query embeddings.</li> <li>Neo4jDynamicDocumentRetriever is also a retriever component in a sense that it can be used to query Documents in Neo4j. However it is decoupled from <code>Neo4jDocumentStore</code> and allows to run arbitrary Cypher query to extract documents. Practically it is possible to query Neo4j same way <code>Neo4jDocumentStore</code> does, including vector search.</li> <li>Neo4jQueryReader - is a component which gives flexible way to read data from Neo4j by running custom Cypher query along with query parameters. You could use such queries to read data from Neo4j to enhance your RAG pipelines. For example prompting LLM to produce Cypher query based on given context (Text to Cypher) and use <code>Neo4jQueryReader</code> to run the   query and extract results. OutputAdapter component might   become handy in such scenarios - it can be used to handle outputs from <code>Neo4jQueryReader</code>.</li> <li>Neo4jQueryWriter - this component gives flexible way to write data to Neo4j by running arbitrary Cypher query along with parameters. Query parameters can be pipeline inputs or outputs from connected components. You could use such queries to write Documents with additional graph nodes for a more complex RAG scenarios. The difference between DocumentWriter and <code>Neo4jQueryWriter</code> is that the latter can write any data to Neo4j, not just Documents.</li> </ul> <p>The <code>neo4j-haystack</code> library uses Python Driver and Cypher Queries to interact with Neo4j database and hide all complexities under the hood.</p> <p><code>Neo4jDocumentStore</code> will store Documents as Graph nodes in Neo4j. Embeddings are stored as part of the node, but indexing and querying of vector embeddings using ANN is managed by a dedicated Vector Index.</p> <pre><code>                                   +-----------------------------+\n                                   |       Neo4j Database        |\n                                   +-----------------------------+\n                                   |                             |\n                                   |      +----------------+     |\n                                   |      |    Document    |     |\n                write_documents    |      +----------------+     |\n          +------------------------+-----&gt;|   properties   |     |\n          |                        |      |                |     |\n+---------+----------+             |      |   embedding    |     |\n|                    |             |      +--------+-------+     |\n| Neo4jDocumentStore |             |               |             |\n|                    |             |               |index/query  |\n+---------+----------+             |               |             |\n          |                        |      +--------+--------+    |\n          |                        |      |  Vector Index   |    |\n          +-----------------------&gt;|      |                 |    |\n               query_embeddings    |      | (for embedding) |    |\n                                   |      +-----------------+    |\n                                   |                             |\n                                   +-----------------------------+\n</code></pre> <p>In the above diagram:</p> <ul> <li><code>Document</code> is a Neo4j node (with \"Document\" label)</li> <li><code>properties</code> are Document attributes stored as part of the node. In current implementation <code>meta</code> attributes are stored on the same level as the rest of Document fields.</li> <li><code>embedding</code> is also a property of the Document node (just shown separately in the diagram for clarity) which is a vector of type <code>LIST[FLOAT]</code>.</li> <li><code>Vector Index</code> is where embeddings are getting indexed by Neo4j as soon as those are updated in Document nodes.</li> </ul> <p><code>Neo4jDocumentStore</code> by default creates a vector index if it does not exist. Before writing documents you should make sure Documents are embedded by one of the provided embedders. For example SentenceTransformersDocumentEmbedder can be used in indexing pipeline to calculate document embeddings before writing those to Neo4j.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>neo4j-haystack</code> can be installed as any other Python library, using pip:</p> <pre><code>pip install --upgrade pip # optional\npip install sentence-transformers # required in order to run pipeline examples given below\npip install neo4j-haystack\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#running-neo4j","title":"Running Neo4j","text":"<p>You will need to have a running instance of Neo4j database to use components from the package (in-memory version of Neo4j is not supported). There are several options available:</p> <ul> <li>Docker, other options available in the same Operations Manual</li> <li>AuraDB - a fully managed Cloud Instance of Neo4j</li> <li>Neo4j Desktop client application</li> </ul> <p>The simplest way to start database locally will be with Docker container:</p> <pre><code>docker run \\\n    --restart always \\\n    --publish=7474:7474 --publish=7687:7687 \\\n    --env NEO4J_AUTH=neo4j/passw0rd \\\n    neo4j:5.15.0\n</code></pre> <p>As of Neo4j <code>5.13</code>, the vector search index is no longer a beta feature, consider using a version of the database <code>\"&gt;= 5.13\"</code>. In the example above version <code>5.15.0</code> is being used to start a container. You could explore Known issues and Limitations in the documentation.</p> <p>The <code>NEO4J_AUTH</code> environment variable sets default credentials (<code>username/password</code>) for authentication.</p> <p>Note Assuming you have a docker container running navigate to http://localhost:7474 to open Neo4j Browser to explore graph data and run Cypher queries.</p>"},{"location":"#document-store","title":"Document Store","text":"<p>Once you have the package installed and the database running, you can start using <code>Neo4jDocumentStore</code> as any other document stores that support embeddings.</p> <pre><code>from neo4j_haystack import Neo4jDocumentStore\n\ndocument_store = Neo4jDocumentStore(\n    url=\"bolt://localhost:7687\",\n    username=\"neo4j\",\n    password=\"passw0rd\",\n    database=\"neo4j\",\n    embedding_dim=384,\n    embedding_field=\"embedding\",\n    index=\"document-embeddings\", # The name of the Vector Index in Neo4j\n    node_label=\"Document\", # Providing a label to Neo4j nodes which store Documents\n)\n</code></pre> <p>Alternatively, Neo4j connection properties could be specified using a dedicated Neo4jClientConfig class:</p> <pre><code>from neo4j_haystack import Neo4jClientConfig, Neo4jDocumentStore\n\nclient_config = Neo4jClientConfig(\n    url=\"bolt://localhost:7687\",\n    username=\"neo4j\",\n    password=\"passw0rd\",\n    database=\"neo4j\",\n)\n\ndocument_store = Neo4jDocumentStore(client_config=client_config, embedding_dim=384)\n</code></pre> <p>Assuming there is a list of documents available and a running Neo4j database you can write/index those in Neo4j, e.g.:</p> <pre><code>from haystack import Document\n\ndocuments = [Document(content=\"My name is Morgan and I live in Paris.\")]\n\ndocument_store.write_documents(documents)\n</code></pre> <p>If you intend to obtain embeddings before writing documents use the following code:</p> <pre><code>from haystack import Document\n\n# import one of the available document embedders\nfrom haystack.components.embedders import SentenceTransformersDocumentEmbedder\n\ndocuments = [Document(content=\"My name is Morgan and I live in Paris.\")]\n\ndocument_embedder = SentenceTransformersDocumentEmbedder(model=\"sentence-transformers/all-MiniLM-L6-v2\")\ndocument_embedder.warm_up() # will download the model during first run\ndocuments_with_embeddings = document_embedder.run(documents)\n\ndocument_store.write_documents(documents_with_embeddings.get(\"documents\"))\n</code></pre> <p>Make sure embedding model produces vectors of same size as it has been set on <code>Neo4jDocumentStore</code>, e.g. setting <code>embedding_dim=384</code> would comply with the \"sentence-transformers/all-MiniLM-L6-v2\" model.</p> <p>Note Most of the time you will be using Haystack Pipelines to build both indexing and querying RAG scenarios.</p> <p>It is important to understand how haystack Documents are stored in Neo4j after you call <code>write_documents</code>.</p> <pre><code>from random import random\n\nsample_embedding = [random() for _ in range(384)]  # using fake/random embedding for brevity here to simplify example\ndocument = Document(\n    content=\"My name is Morgan and I live in Paris.\", embedding=sample_embedding, meta={\"num_of_years\": 3}\n)\ndocument.to_dict()\n</code></pre> <p>The above code converts a Document to a dictionary and will render the following output:</p> <pre><code>&gt;&gt;&gt; output:\n{\n    \"id\": \"11c255ad10bff4286781f596a5afd9ab093ed056d41bca4120c849058e52f24d\",\n    \"content\": \"My name is Morgan and I live in Paris.\",\n    \"dataframe\": None,\n    \"blob\": None,\n    \"score\": None,\n    \"embedding\": [0.025010755222666936, 0.27502931836911926, 0.22321073814882275, ...], # vector of size 384\n    \"num_of_years\": 3,\n}\n</code></pre> <p>The data from the dictionary will be used to create a node in Neo4j after you write the document with <code>document_store.write_documents([document])</code>. You could query it with Cypher, e.g. <code>MATCH (doc:Document) RETURN doc</code>. Below is a json representation of the node in Neo4j:</p> <pre><code>{\n  \"identity\": 0,\n  \"labels\": [\n    \"Document\" // label name is specified in the Neo4jDocumentStore.node_label argument\n  ],\n  \"properties\": { // this is where Document data is stored\n    \"id\": \"11c255ad10bff4286781f596a5afd9ab093ed056d41bca4120c849058e52f24d\",\n    \"embedding\": [0.6394268274307251, 0.02501075528562069,0.27502933144569397, ...], // vector of size 384\n    \"content\": \"My name is Morgan and I live in Paris.\",\n    \"num_of_years\": 3\n  },\n  \"elementId\": \"4:8bde9fb3-3975-4c3e-9ea1-3e10dbad55eb:0\"\n}\n</code></pre> <p>Note Metadata (<code>num_of_years</code>) is serialized to the same level as rest of attributes (flatten). It is expected by current implementation as Neo4j node's properties can not have nested structures.</p> <p>The full list of parameters accepted by <code>Neo4jDocumentStore</code> can be found in API documentation.</p>"},{"location":"#indexing-documents","title":"Indexing documents","text":"<p>With Haystack you can use DocumentWriter component to write Documents into a Document Store. In the example below we construct pipeline to write documents to Neo4j using <code>Neo4jDocumentStore</code>:</p> <pre><code>from haystack import Document\nfrom haystack.components.embedders import SentenceTransformersDocumentEmbedder\nfrom haystack.components.writers import DocumentWriter\nfrom haystack.pipeline import Pipeline\n\nfrom neo4j_haystack import Neo4jDocumentStore\n\ndocuments = [Document(content=\"This is document 1\"), Document(content=\"This is document 2\")]\n\ndocument_store = Neo4jDocumentStore(\n    url=\"bolt://localhost:7687\",\n    username=\"neo4j\",\n    password=\"passw0rd\",\n    database=\"neo4j\",\n    embedding_dim=384,\n    embedding_field=\"embedding\",\n    index=\"document-embeddings\",\n    node_label=\"Document\",\n)\nembedder = SentenceTransformersDocumentEmbedder(model=\"sentence-transformers/all-MiniLM-L6-v2\")\ndocument_writer = DocumentWriter(document_store=document_store)\n\nindexing_pipeline = Pipeline()\nindexing_pipeline.add_component(instance=embedder, name=\"embedder\")\nindexing_pipeline.add_component(instance=document_writer, name=\"writer\")\n\nindexing_pipeline.connect(\"embedder\", \"writer\")\nindexing_pipeline.run({\"embedder\": {\"documents\": documents}})\n</code></pre> <pre><code>&gt;&gt;&gt; output:\n`{'writer': {'documents_written': 2}}`\n</code></pre>"},{"location":"#retrieving-documents","title":"Retrieving documents","text":"<p><code>Neo4jEmbeddingRetriever</code> component can be used to retrieve documents from Neo4j by querying vector index using an embedded query. Below is a pipeline which finds documents using query embedding as well as metadata filtering:</p> <pre><code>from typing import List\n\nfrom haystack import Document, Pipeline\nfrom haystack.components.embedders import SentenceTransformersDocumentEmbedder, SentenceTransformersTextEmbedder\n\nfrom neo4j_haystack import Neo4jDocumentStore, Neo4jEmbeddingRetriever\n\ndocument_store = Neo4jDocumentStore(\n    url=\"bolt://localhost:7687\",\n    username=\"neo4j\",\n    password=\"passw0rd\",\n    database=\"neo4j\",\n    embedding_dim=384,\n    index=\"document-embeddings\",\n)\n\ndocuments = [\n    Document(content=\"My name is Morgan and I live in Paris.\", meta={\"num_of_years\": 3}),\n    Document(content=\"I am Susan and I live in Berlin.\", meta={\"num_of_years\": 7}),\n]\n\n# Same model is used for both query and Document embeddings\nmodel_name = \"sentence-transformers/all-MiniLM-L6-v2\"\n\ndocument_embedder = SentenceTransformersDocumentEmbedder(model=model_name)\ndocument_embedder.warm_up()\ndocuments_with_embeddings = document_embedder.run(documents)\n\ndocument_store.write_documents(documents_with_embeddings.get(\"documents\"))\n\nprint(\"Number of documents written: \", document_store.count_documents())\n\npipeline = Pipeline()\npipeline.add_component(\"text_embedder\", SentenceTransformersTextEmbedder(model=model_name))\npipeline.add_component(\"retriever\", Neo4jEmbeddingRetriever(document_store=document_store))\npipeline.connect(\"text_embedder.embedding\", \"retriever.query_embedding\")\n\nresult = pipeline.run(\n    data={\n        \"text_embedder\": {\"text\": \"What cities do people live in?\"},\n        \"retriever\": {\n            \"top_k\": 5,\n            \"filters\": {\"field\": \"num_of_years\", \"operator\": \"==\", \"value\": 3},\n        },\n    }\n)\n\ndocuments: List[Document] = result[\"retriever\"][\"documents\"]\n</code></pre> <pre><code>&gt;&gt;&gt; output:\n[Document(id=3930326edabe6d172031557556999e2f8ba258ccde3c876f5e3ac7e66ed3d53a, content: 'My name is Morgan and I live in Paris.', meta: {'num_of_years': 3}, score: 0.8348373770713806)]\n</code></pre> <p>Note You can learn more about how a given metadata filter is converted into Cypher queries by looking at documentation of the Neo4jQueryConverter class.</p>"},{"location":"#retrieving-documents-using-cypher","title":"Retrieving documents using Cypher","text":"<p>In certain scenarios you might have an existing graph in Neo4j database which was created by custom scripts or data ingestion pipelines. The schema of the graph could be complex and not exactly fitting into Haystack Document model. Moreover in many situations you might want to leverage existing graph data to extract more context for grounding LLMs. To make it possible with Haystack we have <code>Neo4jDynamicDocumentRetriever</code> component - a flexible retriever which can run arbitrary Cypher query to obtain documents. This component does not require Document Store to operate.</p> <p>Note The logic of <code>Neo4jDynamicDocumentRetriever</code> could be easily achieved with <code>Neo4jQueryReader</code> + <code>OutputAdapter</code> components. <code>Neo4jDynamicDocumentRetriever</code> makes sense when you specifically expect Documents as an output of a query execution and would like to avoid additional output conversions in your pipeline (e.g. \"Neo4j Record\" --&gt; Document).</p> <p>The above example of <code>Neo4jEmbeddingRetriever</code> could be rewritten without usage of <code>Neo4jDocumentStore</code> in the retrieval pipeline:</p> <pre><code>from typing import List\n\nfrom haystack import Document, Pipeline\nfrom haystack.components.embedders import SentenceTransformersDocumentEmbedder, SentenceTransformersTextEmbedder\n\nfrom neo4j_haystack import Neo4jClientConfig, Neo4jDocumentStore, Neo4jDynamicDocumentRetriever\n\nclient_config = Neo4jClientConfig(\n    url=\"bolt://localhost:7687\",\n    username=\"neo4j\",\n    password=\"passw0rd\",\n    database=\"neo4j\",\n)\n\ndocuments = [\n    Document(content=\"My name is Morgan and I live in Paris.\", meta={\"num_of_years\": 3}),\n    Document(content=\"I am Susan and I live in Berlin.\", meta={\"num_of_years\": 7}),\n]\n\n# Same model is used for both query and Document embeddings\nmodel_name = \"sentence-transformers/all-MiniLM-L6-v2\"\n\ndocument_embedder = SentenceTransformersDocumentEmbedder(model=model_name)\ndocument_embedder.warm_up()\ndocuments_with_embeddings = document_embedder.run(documents)\n\ndocument_store = Neo4jDocumentStore(client_config=client_config, embedding_dim=384)\ndocument_store.write_documents(documents_with_embeddings.get(\"documents\"))\n\n# Same model is used for both query and Document embeddings\nmodel_name = \"sentence-transformers/all-MiniLM-L6-v2\"\n\ncypher_query = \"\"\"\n            CALL db.index.vector.queryNodes($index, $top_k, $query_embedding)\n            YIELD node as doc, score\n            MATCH (doc) WHERE doc.num_of_years = $num_of_years\n            RETURN doc{.*, score}, score\n            ORDER BY score DESC LIMIT $top_k\n        \"\"\"\n\nembedder = SentenceTransformersTextEmbedder(model=\"sentence-transformers/all-MiniLM-L6-v2\")\nretriever = Neo4jDynamicDocumentRetriever(\n    client_config=client_config, runtime_parameters=[\"query_embedding\"], doc_node_name=\"doc\"\n)\n\npipeline = Pipeline()\npipeline.add_component(\"text_embedder\", embedder)\npipeline.add_component(\"retriever\", retriever)\npipeline.connect(\"text_embedder.embedding\", \"retriever.query_embedding\")\n\nresult = pipeline.run(\n    data={\n        \"text_embedder\": {\"text\": \"What cities do people live in?\"},\n        \"retriever\": {\n            \"query\": cypher_query,\n            \"parameters\": {\"index\": \"document-embeddings\", \"top_k\": 5, \"num_of_years\": 3},\n        },\n    }\n)\n\ndocuments: List[Document] = result[\"retriever\"][\"documents\"]\n</code></pre> <pre><code>&gt;&gt;&gt; output:\n[Document(id=4014455c3be5d88151ba12d734a16754d7af75c691dfc3a5f364f81772471bd2, content: 'My name is Morgan and I live in Paris.', meta: {'num_of_years': 3}, score: 0.6696747541427612, embedding: vector of size 384)]\n</code></pre> <p>Please notice how query parameters are being used in the <code>cypher_query</code>:</p> <ul> <li><code>runtime_parameters</code> is a list of parameter names which are going to be input slots when connecting components   in a pipeline. In our case <code>query_embedding</code> input is connected to the <code>text_embedder.embedding</code> output.</li> <li><code>pipeline.run</code> specifies additional parameters to the <code>retriever</code> component which can be referenced in the   <code>cypher_query</code>, e.g. <code>top_k</code> and <code>num_of_years</code>.</li> </ul> <p>In some way <code>Neo4jDynamicDocumentRetriever</code> resembles the PromptBuilder component, only instead of prompt it constructs a Cypher query using parameters. In the example above documents retrieved by running the query, the <code>RETURN doc{.*, score}</code> part returns back found documents with scores. Which node variable is going to be used to construct haystack Document is specified in the <code>doc_node_name</code> parameter (see above <code>doc_node_name=\"doc\"</code>).</p> <p>You have options to enhance your RAG pipeline with data having various schemas, for example by first finding nodes using vector search and then expanding query to search for nearby nodes using appropriate Cypher syntax. It is possible to implement \"Parent-Child\" chunking strategy with such approach. Before that you have to ingest/index data into Neo4j accordingly by building an indexing pipeline or a custom ingestion script. A simple schema is shown below:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Child    \u2502                \u2502   Parent    \u2502\n\u2502            \u2502  :HAS_PARENT   \u2502             \u2502\n\u2502   content  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   content   \u2502\n\u2502  embedding \u2502                \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The following Cypher query is an example of how <code>Neo4jDynamicDocumentRetriever</code> can first search embeddings for <code>Child</code> document chunks and then return <code>Parent</code> documents which have larger context window (text length) for RAG applications:</p> <pre><code>// Query Child documents by $query_embedding\nCALL db.index.vector.queryNodes($index, $top_k, $query_embedding)\nYIELD node as child_doc, score\n\n// Find Parent document for previously retrieved child (e.g. extend RAG context)\nMATCH (child_doc)-[:HAS_PARENT]-&gt;(parent:Parent)\nWITH parent, max(score) AS score // deduplicate parents\nRETURN parent{.*, score}\n</code></pre> <p>As you might have guessed, the value for the <code>doc_node_name</code> parameter should be equal to <code>parent</code> according to the query above.</p>"},{"location":"#more-examples","title":"More examples","text":"<p>You can find more examples in the implementation repository:</p> <ul> <li>indexing_pipeline.py - Indexing text files (documents) from a remote http location.</li> <li>rag_pipeline.py - Generative question answering RAG pipeline using <code>Neo4jEmbeddingRetriever</code> to fetch documents from Neo4j document store and answer question using HuggingFaceTGIGenerator.</li> <li>rag_pipeline_cypher.py - Same as <code>rag_pipeline.py</code> but using <code>Neo4jDynamicDocumentRetriever</code>.</li> </ul> <p>More technical details available in the Code Reference documentation. For example, in real world scenarios there could be requirements to tune connection settings to Neo4j database (e.g. request timeout). Neo4jDocumentStore accepts an extended client configuration using Neo4jClientConfig class.</p>"},{"location":"#license","title":"License","text":"<p><code>neo4j-haystack</code> is distributed under the terms of the MIT license.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v221-2025-04-10","title":"v2.2.1 - 2025-04-10","text":"<p>Compare with v2.2.0</p>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>For tests making sure numpy version is &lt; 2 to avoid errors (548cb95 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Keep \"auth\" as part of driver_config only for backward compatibility (b08bb51 by Sergey Bondarenco).</li> <li>Unify auth container propagation logic (55412aa by Sergey Bondarenco). Issue #10</li> <li>Allow custom auth object propagation to database client (9ac5028 by Sergey Bondarenco). Issue #10</li> <li>Align ChatMessage serialization with latest Haystack version (98e7e5d by Sergey Bondarenco).</li> <li>Base error does not take keyword arguments (8421b4c by Sergey Bondarenco). Issue #10</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Apply a more idiomatic way to convert a list to a dictionary of component parameters (c259ab2 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#v220-2024-12-03","title":"v2.2.0 - 2024-12-03","text":"<p>Compare with v2.1.0</p>"},{"location":"changelog/#dependencies_1","title":"Dependencies","text":"<ul> <li>Update Haystack version to &gt;=2.6.0 (2b9f6be by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Remove those dynamic input slots in components which are declared in component's run method (88e8a47 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#v210-2024-09-17","title":"v2.1.0 - 2024-09-17","text":"<p>Compare with v2.0.3</p>"},{"location":"changelog/#dependencies_2","title":"Dependencies","text":"<ul> <li>Update versions of dependencies (b422aca by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Allow Cypher query to be provided during creation of Neo4jDynamicDocumentRetriever component (ddfbd2e by Sergey Bondarenco).</li> <li>Allow a custom marshaller for converting Document to Neo4j record (9ca023e by Sergey Bondarenco).</li> <li>Neo4jQueryReader component to run arbitrary Cypher queries to extract data from Neo4j (bc23597 by Sergey Bondarenco).</li> <li>A module responsible of serialization of complex types in Cypher query parameters (99ff860 by Sergey Bondarenco).</li> <li>Example RAG pipeline for Parent-Child document setup (525d166 by Sergey Bondarenco).</li> <li>Add raise_on_failure setting for Neo4jQueryWriter component for better error handling control (51c819c by Sergey Bondarenco).</li> <li>Neo4jQueryWriter component to run Cypher queries which write data to Neo4j (ceb569a by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Use HuggingFaceAPIGenerator in example scripts as HuggingFaceTGIGenerator is no longer available (42ed60d by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Adjust component outputs and parameter serialization for Neo4jQueryWriter (0d93b21 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#v203-2024-02-08","title":"v2.0.3 - 2024-02-08","text":"<p>Compare with v2.0.2</p>"},{"location":"changelog/#build","title":"Build","text":"<ul> <li>Update settings as per latest ruff requirements in pyproject.toml (652d1f1 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Introducing <code>execute_write</code> method in Neo4jClient to run arbitrary Cypher queries which modify data (88e89bb by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Return number of written documents from <code>write_documents</code> as per Protocol for document stores (f421ed5 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#code-refactoring_2","title":"Code Refactoring","text":"<ul> <li>Read token values using Secret util (f75fa32 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#v202-2024-01-19","title":"v2.0.2 - 2024-01-19","text":"<p>Compare with v2.0.1</p>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Change imports for DuplicateDocumentError and DuplicatePolicy as per latest changes in haystack (7a1f053 by Sergey Bondarenco).</li> <li>Rename 'model_name_or_path' to 'model' as per latest changes in haystack (0131059 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#v201-2024-01-15","title":"v2.0.1 - 2024-01-15","text":"<p>Compare with v2.0.0</p>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Rename metadata slot to meta in example pipelines (1831d40 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#v200-2024-01-15","title":"v2.0.0 - 2024-01-15","text":"<p>Compare with v1.0.0</p>"},{"location":"changelog/#build_1","title":"Build","text":"<ul> <li>Update haystack dependency to 2.0 (bd3e925 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Update examples based on haystack 2.0 pipelines (a7e3bf1 by Sergey Bondarenco).</li> <li>Retriever component for documents stored in Neo4j (b411ebc by Sergey Bondarenco).</li> <li>Update DocumentStore protocol implementation to match haystack 2.0 requirements (9748e7d by Sergey Bondarenco).</li> <li>Update metadata filter parser for document store (6ce780c by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#code-refactoring_3","title":"Code Refactoring","text":"<ul> <li>Organize modules into packages for better separation of concerns (6a101e8 by Sergey Bondarenco).</li> <li>Change name of retriever component as per documented naming convention (f79a952 by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#v100-2023-12-19","title":"v1.0.0 - 2023-12-19","text":"<p>Compare with first commit</p>"},{"location":"changelog/#build_2","title":"Build","text":"<ul> <li>Script to bump a new release by tagging commit and generating changelog (84a923d by Sergey Bondarenco).</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Example of Neo4jDocumentStore used in a question answering pipeline (e7628c6 by Sergey Bondarenco).</li> <li>Sample script to download movie data from HF datasets (ed44127 by Sergey Bondarenco).</li> <li>Project setup and initial implementation of Neo4jDataStore (f801a10 by Sergey Bondarenco).</li> </ul>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2023-present Sergey Bondarenco &lt;sergey.bondarenco@outlook.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"reference/errors/","title":"errors","text":""},{"location":"reference/errors/#neo4j_haystack.errors.Neo4jDocumentStoreError","title":"Neo4jDocumentStoreError","text":"<p>               Bases: <code>DocumentStoreError</code></p> <p>Error for issues that occur in a Neo4j Document Store</p> Source code in <code>src/neo4j_haystack/errors.py</code> <pre><code>class Neo4jDocumentStoreError(DocumentStoreError):\n    \"\"\"Error for issues that occur in a Neo4j Document Store\"\"\"\n\n    def __init__(self, message: Optional[str] = None):\n        super().__init__(message=message)\n</code></pre>"},{"location":"reference/errors/#neo4j_haystack.errors.Neo4jClientError","title":"Neo4jClientError","text":"<p>               Bases: <code>DocumentStoreError</code></p> <p>Error for issues that occur in a Neo4j client</p> Source code in <code>src/neo4j_haystack/errors.py</code> <pre><code>class Neo4jClientError(DocumentStoreError):\n    \"\"\"Error for issues that occur in a Neo4j client\"\"\"\n\n    def __init__(self, message: Optional[str] = None):\n        super().__init__(message)\n</code></pre>"},{"location":"reference/errors/#neo4j_haystack.errors.Neo4jFilterParserError","title":"Neo4jFilterParserError","text":"<p>               Bases: <code>Exception</code></p> <p>Error is raised when metadata filters are failing to parse</p> Source code in <code>src/neo4j_haystack/errors.py</code> <pre><code>class Neo4jFilterParserError(Exception):\n    \"\"\"Error is raised when metadata filters are failing to parse\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/neo4j_client/","title":"Neo4jClient","text":""},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.NODE_VAR","title":"NODE_VAR  <code>module-attribute</code>","text":"<pre><code>NODE_VAR = 'doc'\n</code></pre> <p>Default variable name used in Cypher queries to match and return Documents, e.g. <code>match(doc:Document) where doc.id = $id return doc</code> where <code>doc</code> is a variable name.</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.DEFAULT_NEO4J_URI","title":"DEFAULT_NEO4J_URI  <code>module-attribute</code>","text":"<pre><code>DEFAULT_NEO4J_URI = 'bolt://localhost:7687'\n</code></pre> <p>Default URI to connect to neo4j instance, e.g. a local DB running in Docker container.</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.DEFAULT_NEO4J_DATABASE","title":"DEFAULT_NEO4J_DATABASE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_NEO4J_DATABASE = 'neo4j'\n</code></pre> <p>Default Neo4j database name to connect to if not provided.</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.DEFAULT_NEO4J_USERNAME","title":"DEFAULT_NEO4J_USERNAME  <code>module-attribute</code>","text":"<pre><code>DEFAULT_NEO4J_USERNAME = 'neo4j'\n</code></pre> <p>Default Neo4j username to be used for authentication with Neo4j. Used to simplify local development.</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.DEFAULT_NEO4J_PASSWORD","title":"DEFAULT_NEO4J_PASSWORD  <code>module-attribute</code>","text":"<pre><code>DEFAULT_NEO4J_PASSWORD = 'neo4j'\n</code></pre> <p>Default Neo4j password to be used for authentication with Neo4j. Used to simplify local development.</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jRecord","title":"Neo4jRecord  <code>module-attribute</code>","text":"<pre><code>Neo4jRecord = Dict[str, Any]\n</code></pre> <p>Type alias for data items returned from Neo4j queries</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jSessionConfig","title":"Neo4jSessionConfig  <code>module-attribute</code>","text":"<pre><code>Neo4jSessionConfig = Mapping[str, Any]\n</code></pre> <p>Generic dictionary for Session Configuration</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jDriverConfig","title":"Neo4jDriverConfig  <code>module-attribute</code>","text":"<pre><code>Neo4jDriverConfig = Mapping[str, Any]\n</code></pre> <p>Generic dictionary for Driver Configuration</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jTransactionConfig","title":"Neo4jTransactionConfig  <code>module-attribute</code>","text":"<pre><code>Neo4jTransactionConfig = Mapping[str, Any]\n</code></pre> <p>Generic dictionary for Transaction Configuration</p>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.VectorStoreIndexInfo","title":"VectorStoreIndexInfo  <code>dataclass</code>","text":"<p>Neo4j vector index information retrieved from the database.</p> <p>See Create and configure vector indexes documentation to learn more about data representing index configuration.</p> <p>Attributes:</p> <ul> <li> <code>index_name</code>               (<code>str</code>)           \u2013            <p>The name of the index.</p> </li> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>Name of Neo4j node which contains embeddings which are indexed.</p> </li> <li> <code>property_key</code>               (<code>str</code>)           \u2013            <p>Name of the property of the node which contains vectors.</p> </li> <li> <code>dimensions</code>               (<code>int</code>)           \u2013            <p>Dimension of embedding vector.</p> </li> <li> <code>similarity_function</code>               (<code>str</code>)           \u2013            <p>Configured vector similarity function.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>@dataclass\nclass VectorStoreIndexInfo:\n    \"\"\"Neo4j vector index information retrieved from the database.\n\n    See [Create and configure vector indexes](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-create)\n    documentation to learn more about data representing index configuration.\n\n    Attributes:\n        index_name: The name of the index.\n        node_label: Name of Neo4j node which contains embeddings which are indexed.\n        property_key: Name of the property of the node which contains vectors.\n        dimensions: Dimension of embedding vector.\n        similarity_function: Configured vector similarity function.\n    \"\"\"\n\n    index_name: str\n    node_label: str\n    property_key: str\n    dimensions: int\n    similarity_function: str\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClientConfig","title":"Neo4jClientConfig  <code>dataclass</code>","text":"<p>Provides extensive configuration options in order to communicate with Neo4j database.</p> <p>It combines several configuration levels for each entity used by python driver to communicate with a database:</p> <ul> <li>Driver Configuration</li> <li>Session Configuration</li> <li>Transaction Configuration</li> </ul> <p>Developers can pick up configuration properties for each entity (e.g. session) which will be applied during transaction invocations. For example, <code>driver_config={\"connection_timeout\": 30}</code> will set amount of time in seconds to wait for a TCP connection to be established.</p> <p><code>username</code> and <code>password</code> are optional because developer can choose to provide alternative authentication options using <code>driver_config</code> by setting Driver Auth Details.</p> <p>Attributes:</p> <ul> <li> <code>url</code>               (<code>Optional[str]</code>)           \u2013            <p>Database connection string, see https://neo4j.com/docs/api/python-driver/current/api.html#uri.</p> </li> <li> <code>database</code>               (<code>Optional[str]</code>)           \u2013            <p>Database name to connect.</p> </li> <li> <code>username</code>               (<code>Optional[str]</code>)           \u2013            <p>Username to authenticate with the database.</p> </li> <li> <code>password</code>               (<code>Optional[str]</code>)           \u2013            <p>Password credential for the given username.</p> </li> <li> <code>driver_config</code>               (<code>Neo4jDriverConfig</code>)           \u2013            <p>Additional driver configuration.</p> </li> <li> <code>session_config</code>               (<code>Neo4jSessionConfig</code>)           \u2013            <p>Additional session configuration.</p> </li> <li> <code>transaction_config</code>               (<code>Neo4jTransactionConfig</code>)           \u2013            <p>Additional transaction configuration (e.g. <code>timeout</code>)</p> </li> <li> <code>use_env</code>               (<code>Optional[bool]</code>)           \u2013            <p>If <code>True</code> the following Driver attributes will be assigned from respective environment variables: <pre><code>&gt;&gt;&gt; url = os.getenv(\"NEO4J_URI\")\n&gt;&gt;&gt; database = os.getenv(\"NEO4J_DATABASE\")\n&gt;&gt;&gt; username = os.getenv(\"NEO4J_USERNAME\")\n&gt;&gt;&gt; password = os.getenv(\"NEO4J_PASSWORD\")\n</code></pre></p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>In case conflicting auth credentials are provided - choose either username/password combination or <code>driver_config.auth</code>.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>@dataclass\nclass Neo4jClientConfig:\n    \"\"\"\n    Provides extensive configuration options in order to communicate with Neo4j database.\n\n    It combines several configuration levels for each entity used by python driver to communicate with a database:\n\n    - [Driver Configuration][neo4j_haystack.client.neo4j_client.Neo4jDriverConfig]\n    - [Session Configuration][neo4j_haystack.client.neo4j_client.Neo4jSessionConfig]\n    - [Transaction Configuration][neo4j_haystack.client.neo4j_client.Neo4jTransactionConfig]\n\n    Developers can pick up configuration properties for each entity (e.g. session) which will be applied during\n    transaction invocations. For example, ``driver_config={\"connection_timeout\": 30}`` will set amount of time in\n    seconds to wait for a TCP connection to be established.\n\n    `username` and `password` are optional because developer can choose to provide alternative\n    authentication options using `driver_config` by setting [Driver Auth Details](https://neo4j.com/docs/api/python-driver/current/api.html#auth).\n\n    Attributes:\n        url: Database connection string, see https://neo4j.com/docs/api/python-driver/current/api.html#uri.\n        database: Database name to connect.\n        username: Username to authenticate with the database.\n        password: Password credential for the given username.\n        driver_config: Additional driver configuration.\n        session_config: Additional session configuration.\n        transaction_config: Additional transaction configuration (e.g. ``timeout``)\n        use_env: If `True` the following Driver attributes will be assigned from respective environment variables:\n            ```py\n            &gt;&gt;&gt; url = os.getenv(\"NEO4J_URI\")\n            &gt;&gt;&gt; database = os.getenv(\"NEO4J_DATABASE\")\n            &gt;&gt;&gt; username = os.getenv(\"NEO4J_USERNAME\")\n            &gt;&gt;&gt; password = os.getenv(\"NEO4J_PASSWORD\")\n            ```\n\n    Raises:\n        ValueError: In case conflicting auth credentials are provided - choose either username/password combination\n            or `driver_config.auth`.\n    \"\"\"\n\n    url: Optional[str] = field(default=DEFAULT_NEO4J_URI)\n    database: Optional[str] = field(default=DEFAULT_NEO4J_DATABASE)\n    username: Optional[str] = field(default=DEFAULT_NEO4J_USERNAME)\n    password: Optional[str] = field(default=DEFAULT_NEO4J_PASSWORD)\n\n    driver_config: Neo4jDriverConfig = field(default_factory=dict)\n    session_config: Neo4jSessionConfig = field(default_factory=dict)\n    transaction_config: Neo4jTransactionConfig = field(default_factory=dict)\n\n    use_env: Optional[bool] = field(default=False)\n    auth: Optional[Auth] = field(default=None)\n\n    def __post_init__(self):\n        if self.use_env:\n            self.url = os.getenv(\"NEO4J_URI\", self.url)\n            self.database = os.getenv(\"NEO4J_DATABASE\", self.database)\n            self.username = os.getenv(\"NEO4J_USERNAME\", self.username)\n            self.password = os.getenv(\"NEO4J_PASSWORD\", self.password)\n\n        if not self.url:\n            raise ValueError(\"The `url` attribute is mandatory to connect to database.\")\n\n        self.auth = self.auth or self.driver_config.get(\"auth\")\n        # Lets remove \"auth\" from driver config to avoid duplicate \"auth\" configuration when driver is created\n        self.driver_config = {k: v for k, v in self.driver_config.items() if k != \"auth\"}\n\n        if self.auth is None and self.username and self.password:\n            self.auth = (self.username, self.password)\n\n        if self.auth is None:\n            raise ValueError(\n                \"Authentication credentials are missing. Please provide one of the following: \"\n                \"1) `username` and `password`, \"\n                \"2) `auth` field, or \"\n                \"3) `driver_config['auth']`.\"\n            )\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Serializes client configuration to a dictionary.\n        \"\"\"\n        data = default_to_dict(\n            self,\n            url=self.url,\n            database=self.database,\n            username=self.username,\n            password=self.password,\n            driver_config=self.driver_config,\n            session_config=self.session_config,\n            transaction_config=self.transaction_config,\n            use_env=self.use_env,\n        )\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jClientConfig\":\n        \"\"\"\n        Deserializes client configuration from a dictionary.\n        \"\"\"\n        return default_from_dict(cls, data)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClientConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Serializes client configuration to a dictionary.</p> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serializes client configuration to a dictionary.\n    \"\"\"\n    data = default_to_dict(\n        self,\n        url=self.url,\n        database=self.database,\n        username=self.username,\n        password=self.password,\n        driver_config=self.driver_config,\n        session_config=self.session_config,\n        transaction_config=self.transaction_config,\n        use_env=self.use_env,\n    )\n\n    return data\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClientConfig.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Neo4jClientConfig\n</code></pre> <p>Deserializes client configuration from a dictionary.</p> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jClientConfig\":\n    \"\"\"\n    Deserializes client configuration from a dictionary.\n    \"\"\"\n    return default_from_dict(cls, data)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient","title":"Neo4jClient","text":"<p>Neo4j Python Driver wrapper to run low level database transactions using Cypher queries. It abstracts away Neo4j related details from <code>Neo4jDocumentStore</code> so that database related interactions are encapsulated in a single place.</p> <p><code>Neo4jClient</code> can be created with a number of configuration options represented by the <code>Neo4jClientConfig</code> data class. The configuration applied when connecting to a database or running transactions.</p> <p>Attributes:</p> <ul> <li> <code>_config</code>           \u2013            <p>Neo4j configuration options.</p> </li> <li> <code>_driver</code>           \u2013            <p>An instance of neo4j.Driver which is used to start a session for transaction execution.</p> </li> <li> <code>_filter_converter</code>           \u2013            <p>Instance of <code>Neo4jQueryConverter</code> which converts parsed Metadata filters to Cypher queries.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>class Neo4jClient:\n    \"\"\"\n    Neo4j Python Driver wrapper to run low level database transactions using Cypher queries. It abstracts away Neo4j\n    related details from `Neo4jDocumentStore` so that database related interactions are encapsulated in a single\n    place.\n\n    `Neo4jClient` can be created with a number of configuration options represented by the `Neo4jClientConfig` data\n    class. The configuration applied when connecting to a database or running transactions.\n\n    Attributes:\n        _config: Neo4j configuration options.\n        _driver: An instance of [neo4j.Driver][] which is used to start a session for transaction execution.\n        _filter_converter: Instance of `Neo4jQueryConverter` which converts parsed Metadata filters to Cypher\n            queries.\n    \"\"\"\n\n    def __init__(self, config: Neo4jClientConfig):\n        self._config = config\n\n        if not config.url:\n            raise ValueError(\"`Neo4jClientConfig.url` is mandatory attribute when trying to connect to Neo4j database.\")\n\n        self._driver = GraphDatabase.driver(config.url, auth=config.auth, **config.driver_config)\n        self._filter_converter = Neo4jQueryConverter(NODE_VAR)\n\n    def delete_nodes(self, node_label: str, filter_ast: Optional[AST] = None) -&gt; None:\n        \"\"\"\n        Deletes nodes with with given label and filters using [DELETE](https://neo4j.com/docs/cypher-manual/current/clauses/delete/)\n            Cypher clause.\n\n        Args:\n            node_label: The name of the label to delete (e.g. ``\"Document\"``)\n            filter_ast: Metadata filters to delete only specific nodes which match filtering conditions.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n            where_clause, where_params = self._where_clause(filter_ast)\n            tx.run(\n                f\"\"\"\n                MATCH ({NODE_VAR}:`{node_label}`)\n                {where_clause}\n                DETACH DELETE {NODE_VAR}\n                \"\"\",\n                parameters={**where_params},\n            )\n\n        with self._begin_session() as session:\n            session.execute_write(_mgt_tx)\n\n    def create_index(\n        self,\n        index_name: str,\n        label: str,\n        property_key: str,\n        dimension: int,\n        similarity_function: SimilarityFunction,\n    ) -&gt; None:\n        \"\"\"\n        Creates a new vector index in database for a given node label and vector specific attributes (e.g. dimension,\n        similarity function etc). See documentation for the index creation procedure \\\n        [db.index.vector.createNodeIndex](https://neo4j.com/docs/operations-manual/5/reference/procedures/#procedure_db_index_vector_createNodeIndex)\n\n        Args:\n            index_name: The unique name of the index.\n            label: The node label to be indexed (e.g. ``\"Document\"``).\n            property_key: The property key of a node which contains embedding values.\n            dimension: Vector embedding dimension (must be between 1 and 2048 inclusively).\n            similarity_function: case-insensitive values for the vector similarity function:\n                ``cosine`` or ``euclidean``.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n            tx.run(\n                \"\"\"\n                CALL db.index.vector.createNodeIndex(\n                    $index_name,\n                    $label,\n                    $property_key,\n                    toInteger($vector_dimension),\n                    $similarity_function\n                )\n                \"\"\",\n                index_name=index_name,\n                label=label,\n                property_key=property_key,\n                vector_dimension=dimension,\n                similarity_function=similarity_function,\n            )\n\n        with self._begin_session() as session:\n            session.execute_write(_mgt_tx)\n\n    def retrieve_vector_index(\n        self,\n        index_name: str,\n        node_label: str,\n        property_key: str,\n    ) -&gt; Optional[VectorStoreIndexInfo]:\n        \"\"\"\n        Retrieves information about existing vector index.\n\n        For more details and an example query on how to obtain existing indexes see \\\n        [Query a vector index](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-query).\n\n        Args:\n            index_name: The name of the vector index to retrieve.\n            node_label: The label of the node configured as prt of vector index setup.\n            property_key: The property key configured as part of vector index setup.\n\n        Raises:\n            Neo4jClientError: If more than one index found matching search criteria (same index name OR\n                label+property combination).\n\n        Returns:\n            Data retrieved from the query execution or `None` if index was not found.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction) -&gt; List[Record]:\n            result = tx.run(\n                \"\"\"\n                SHOW INDEXES YIELD name, type, labelsOrTypes, properties, options\n                WHERE type = 'VECTOR' AND\n                (name = $index_name OR (labelsOrTypes[0] = $node_label AND properties[0] = $property_key))\n                RETURN name, labelsOrTypes, properties, options\n                \"\"\",\n                index_name=index_name,\n                node_label=node_label,\n                property_key=property_key,\n            )\n\n            return list(result)\n\n        with self._begin_session() as session:\n            found_indexes = session.execute_write(_mgt_tx)\n\n        if len(found_indexes) &gt; 1:\n            raise Neo4jClientError(\n                \"Failed to retrieve vector index from Neo4j.\"\n                \"There were several indexes found with a given search criteria: \"\n                f\"$index_name='{index_name}' OR ($node_label='{node_label}' AND $property_key='{property_key}'). \"\n                \"Please make sure the Neo4jDocumentStore points to an unambiguous vector index\"\n            )\n\n        return self._vector_store_index_info(found_indexes[0]) if found_indexes else None\n\n    def create_index_if_missing(\n        self,\n        index_name: str,\n        label: str,\n        property_key: str,\n        dimension: int,\n        similarity_function: SimilarityFunction,\n    ):\n        \"\"\"\n        Creates a vector index in case it does not exist in database.\n        Uses same parameters as [create_index][neo4j_haystack.client.neo4j_client.Neo4jClient.create_index] \\\n            method.\n        \"\"\"\n\n        existing_index = self.retrieve_vector_index(index_name, label, property_key)\n\n        if not existing_index:\n            logger.debug(\"Creating a new index(%s) as it is not present in the configured Neo4j database\", index_name)\n            self.create_index(index_name, label, property_key, dimension, similarity_function)\n\n    def delete_index(self, index_name: str) -&gt; None:\n        \"\"\"\n        Removes index from Neo4j database.\n\n        See Cypher manual on [Drop vector indexes](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-drop)\n\n        Args:\n            index_name: The name of the index to delete.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n            tx.run(f\"DROP INDEX `{index_name}`\")\n\n        with self._begin_session() as session:\n            session.execute_write(_mgt_tx)\n\n    def update_embedding(self, node_label: str, embedding_field: str, records: List[Dict[str, Any]]) -&gt; None:\n        \"\"\"\n        Updates embedding on a number of ``Document`` nodes. It uses ``db.create.setNodeVectorProperty()`` procedure as\n        a recommended update method. See more details in [Set a vector property on a node](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-set)\n\n        Args:\n            node_label: A node label to match (e.g. ``\"Document\"``).\n            embedding_field: The name of the embedding field which stores embeddings (of type ``LIST&lt;FLOAT&gt;``) as part\n                node properties.\n            records: A list dictionary objects following the structure:\n                ```python\n                    [{\n                        \"id\": \"doc_id1\", # id of the Document (node) to update\n                        embedding_field: [0.8, 0.9, ...] # Embedding vector\n                    }]\n                ```\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n            tx.run(\n                f\"\"\"\n                WITH $records AS batch\n                UNWIND batch as row\n                MATCH ({NODE_VAR}:`{node_label}` {{id: row.id}})\n                CALL db.create.setNodeVectorProperty({NODE_VAR}, '{embedding_field}', row.{embedding_field})\n                RETURN {NODE_VAR}\n                \"\"\",\n                records=records,\n            )\n\n        with self._begin_session() as session:\n            session.execute_write(_mgt_tx)\n\n    def merge_nodes(self, node_label: str, embedding_field: str, records: List[Neo4jRecord]) -&gt; ResultSummary:\n        \"\"\"\n        Creates or updates a node in neo4j representing a Document with all properties. Nodes are matched by \"id\",\n        if not found a new node will be created. See the following manuals:\n\n        - [MERGE clause](https://neo4j.com/docs/cypher-manual/current/clauses/merge/)\n        - [Settings properties using a map](https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map)\n        - [db.create.setNodeVectorProperty](https://neo4j.com/docs/operations-manual/5/reference/procedures/#procedure_db_create_setNodeVectorProperty)\n\n        Args:\n            node_label: The label of the node to match (e.g. \"Document\").\n            embedding_field: The name of the embedding field which stores embeddings (of type ``LIST&lt;FLOAT&gt;``) as part\n                of node properties. Embeddings (if present) will be updated/set by ``db.create.setNodeVectorProperty()``\n                procedure - `embedding_field` is excluded from ``SET`` Cypher clause by using map projections.\n            records: A list of [Documents](https://docs.haystack.deepset.ai/reference/primitives-api#document) \\\n                converted to dictionaries, with ``meta`` attributes included.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction):\n            result = tx.run(\n                f\"\"\"\n                WITH $records AS batch\n                UNWIND batch as row\n                MERGE ({NODE_VAR}:`{node_label}` {{id: row.id}})\n                SET {NODE_VAR} += row{{.*, {embedding_field}: null}}\n                WITH {NODE_VAR}, row\n                CALL {{ WITH {NODE_VAR}, row\n                    MATCH({NODE_VAR}:`{node_label}` {{id: row.id}}) WHERE row.embedding IS NOT NULL\n                    CALL db.create.setNodeVectorProperty({NODE_VAR}, '{embedding_field}', row.{embedding_field})\n                }}\n                \"\"\",\n                records=records,\n            )\n            summary = result.consume()\n            return summary\n\n        with self._begin_session() as session:\n            return session.execute_write(_mgt_tx)\n\n    def count_nodes(self, node_label: str, filter_ast: Optional[AST] = None) -&gt; int:\n        \"\"\"\n        Counts number of nodes matching given label and optional filters.\n\n        Args:\n            node_label: The label of the node to match (e.g. ``\"Document\"``).\n            filter_ast: The filter syntax tree (parsed metadata filter) to narrow down counted results.\n\n        Returns:\n            Number of found nodes.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction):\n            where_clause, where_params = self._where_clause(filter_ast)\n            result = tx.run(\n                f\"\"\"\n                MATCH ({NODE_VAR}:`{node_label}`)\n                {where_clause}\n                RETURN count(*) as count\n                \"\"\",\n                parameters={**where_params},\n            )\n            return result.single(strict=True).value()\n\n        with self._begin_session() as session:\n            return session.execute_read(_mgt_tx)\n\n    def find_nodes(\n        self,\n        node_label: str,\n        filter_ast: Optional[AST] = None,\n        skip_properties: Optional[List[str]] = None,\n        fetch_size: int = 1000,\n    ) -&gt; Generator[Neo4jRecord, None, None]:\n        \"\"\"\n        Search for nodes matching a given label and metadata filters.\n\n        Args:\n            node_label: The label of the nodes to match (e.g. ``\"Document\"``).\n            filter_ast: The filter syntax tree (parsed metadata filter) for search.\n            skip_properties: Properties we would like not to return as part of data payload. Is uses map projection\n                Cypher syntax, e.g. `:::cypher doc{.*, embedding: null}` - such construct will make sure ``embedding``\n                is not returned back in results.\n            fetch_size: Controls how many records are fetched at once from the database which helps with batching\n                process.\n\n        Returns:\n            Found records matching search criteria.\n        \"\"\"\n        where_clause, where_params = self._where_clause(filter_ast)\n        query = f\"\"\"\n            MATCH ({NODE_VAR}:`{node_label}`)\n            {where_clause}\n            RETURN {NODE_VAR}{self._map_projection(skip_properties)}\n            \"\"\"\n\n        for record in self.query_nodes(query=query, parameters={**where_params}, fetch_size=fetch_size):\n            yield cast(Neo4jRecord, record.data().get(NODE_VAR))\n\n    def query_nodes(\n        self,\n        query: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        fetch_size: int = 1000,\n    ) -&gt; Generator[Record, None, None]:\n        \"\"\"\n        Runs a given Cypher `query`. The implementation is based on ``Unmanaged Transactions``\n        for greater control and possibility to ``yield`` results as soon as those are fetched from database. The Neo4j\n        python driver internally manages a buffer which replenished while records are being consumed thus making sure we\n        do not store all fetched records in memory. That greatly simplifies batching mechanism as it is implemented by\n        the buffer. See more details about how python driver implements \\\n        [Explicit/Unmanaged Transactions](https://neo4j.com/docs/api/python-driver/current/api.html#explicit-transactions-unmanaged-transactions)\n\n        Note:\n            Please notice results are yielded while read transaction is still open. That should impact your choice of\n            transaction timeout setting, see \\\n                [Neo4jClientConfig][neo4j_haystack.client.neo4j_client.Neo4jClientConfig].\n\n        Args:\n            query: Cypher query to run in Neo4j.\n            parameters: Query parameters which can be used as placeholders in the `query`.\n            fetch_size: Controls how many records are fetched at once from the database which helps with batching\n                process.\n\n        Returns:\n            Records containing data specified in ``RETURN`` Cypher query statement.\n        \"\"\"\n        with self._begin_session(fetch_size=fetch_size) as session:\n            with session.begin_transaction(\n                metadata=self._config.transaction_config.get(\"metadata\"),\n                timeout=self._config.transaction_config.get(\"timeout\"),\n            ) as tx:\n                try:\n                    result: Result = tx.run(\n                        query,\n                        parameters=parameters,\n                    )\n                    yield from result\n                finally:\n                    tx.close()\n\n    def query_embeddings(\n        self,\n        index: str,\n        top_k: int,\n        embedding: List[float],\n        filter_ast: Optional[AST] = None,\n        skip_properties: Optional[List[str]] = None,\n        vector_top_k: Optional[int] = None,\n    ) -&gt; List[Neo4jRecord]:\n        \"\"\"\n        Query a vector index and apply filtering using `WHERE` clause on results returned by vector search.\n        See the following documentation for more details:\n\n        - [Query a vector index](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-query)\n        - [db.index.vector.queryNodes()](https://neo4j.com/docs/operations-manual/5/reference/procedures/#procedure_db_index_vector_queryNodes)\n\n        Args:\n            index: Refers to the unique name of the vector index to query.\n            top_k: Number of results to return from vector search.\n            embedding: The query vector (a ``LIST&lt;FLOAT&gt;``) in which to search for the neighborhood.\n            filter_ast: Additional filters translated into `WHERE` Cypher clause by \\\n                [Neo4jQueryConverter][neo4j_haystack.metadata_filter.Neo4jQueryConverter]\n            skip_properties: Properties we would like **not** to return as part of data payload. Is uses map projection\n                Cypher syntax, e.g. `:::cypher doc{.*, embedding: null}` - such construct will make sure `embedding` is\n                not returned back in results.\n            vector_top_k: If provided `vector_top_k` is used instead of `top_k` in order to increase number of\n                results (nearest neighbors) from vector search. It makes sense when filters (`filter_ast`) could\n                further narrow down vector search result. Only `top_k` number of records will be returned back thus\n                `vector_top_k` should be preferably greater than `top_k`.\n        Returns:\n            An ordered by score `top_k` nodes found in vector search which are optionally filtered using\n                ``WHERE`` clause.\n        \"\"\"\n\n        score_property = \"score\"\n\n        if vector_top_k and vector_top_k &lt; top_k:\n            logger.warning(\n                \"Make sure 'vector_top_k'(=%s) is greater than 'top_k'(=%s) parameter. Using 'top_k' instead\",\n                vector_top_k,\n                top_k,\n            )\n            vector_top_k = top_k\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction) -&gt; List[Record]:\n            where_clause, where_params = self._where_clause(filter_ast)\n            result = tx.run(\n                f\"\"\"\n                CALL db.index.vector.queryNodes($index, $vector_top_k, $embedding)\n                YIELD node as {NODE_VAR}, {score_property}\n                MATCH ({NODE_VAR}) {where_clause}\n                RETURN {NODE_VAR}{self._map_projection(skip_properties)}, {score_property}\n                ORDER BY {score_property} DESC LIMIT $top_k\n                \"\"\",\n                parameters={\n                    \"index\": index,\n                    \"top_k\": top_k,\n                    \"embedding\": embedding,\n                    \"vector_top_k\": vector_top_k or top_k,\n                    **where_params,\n                },\n            )\n            return list(result)\n\n        with self._begin_session() as session:\n            records = session.execute_read(_mgt_tx)\n\n        return [{**record.value(NODE_VAR), score_property: record.value(\"score\")} for record in records]\n\n    def execute_write(\n        self,\n        query: str,\n        parameters: Optional[Dict[str, Any]] = None,\n    ) -&gt; Tuple[ResultSummary, List[Dict[str, Any]]]:\n        \"\"\"\n        Runs an arbitrary write Cypher query with parameters.\n\n        Args:\n            query: Cypher query to run in Neo4j.\n            parameters: Query parameters which can be used as placeholders in the `query`.\n\n        Returns:\n            A tuple consisting of execution result summary (`neo4j.ResultSummary`) and data records (`dict`) if any.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction):\n            result = tx.run(\n                query,\n                parameters=parameters,\n            )\n            records = result.data()\n            summary = result.consume()\n            return summary, records\n\n        with self._begin_session() as session:\n            return session.execute_write(_mgt_tx)\n\n    def execute_read(\n        self,\n        query: str,\n        parameters: Optional[Dict[str, Any]] = None,\n    ) -&gt; Tuple[ResultSummary, List[Dict[str, Any]]]:\n        \"\"\"\n        Runs an arbitrary \"read\" Cypher query with parameters.\n\n        Args:\n            query: Cypher query to run in Neo4j.\n            parameters: Query parameters which can be used as placeholders in the `query`.\n\n        Returns:\n            A tuple consisting of execution result summary (`neo4j.ResultSummary`) and data records if any.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction):\n            result = tx.run(\n                query,\n                parameters=parameters,\n            )\n            records = result.data()\n            summary = result.consume()\n            return summary, records\n\n        with self._begin_session() as session:\n            return session.execute_read(_mgt_tx)\n\n    def update_node(self, node_label: str, doc_id: str, data: Dict[str, Any]) -&gt; Optional[Neo4jRecord]:\n        \"\"\"\n        Updates a given node matched by the given id (`doc_id`). Properties are mutated by `+=` operator,\n        see more details in [Setting properties using map](https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map).\n\n        Args:\n            node_label: A node label to match (e.g. \"Document\").\n            doc_id: Node id to match. Please notice the `id` used in Cypher query is not a native element id but\n                the one which mapped from the [haystack.schema.Document](https://docs.haystack.deepset.ai/reference/primitives-api#document).\n            data: A dictionary of data which will be set as node's properties.\n\n        Returns:\n            Updated Neo4j record data.\n        \"\"\"\n\n        @self._unit_of_work()\n        def _mgt_tx(tx: ManagedTransaction):\n            result = tx.run(\n                f\"\"\"\n                MATCH ({NODE_VAR}:`{node_label}` {{id: $doc_id}})\n                SET {NODE_VAR} += $doc_data\n                RETURN {NODE_VAR}\n                \"\"\",\n                doc_id=doc_id,\n                doc_data=data,\n            )\n            return result.single(strict=False)\n\n        with self._begin_session() as session:\n            record = session.execute_write(_mgt_tx)\n\n        return record.data().get(NODE_VAR) if record else None\n\n    def verify_connectivity(self):\n        \"\"\"\n        Verifies connection to Neo4j database as per configuration and auth credentials provided.\n\n        Raises:\n            Neo4jClientError: In case connection could not be established.\n        \"\"\"\n        try:\n            self._driver.verify_connectivity()\n        except Exception as err:\n            raise Neo4jClientError(\n                \"Could not connect to Neo4j database. Please ensure that the url and provided credentials are correct\"\n            ) from err\n\n    def close_driver(self) -&gt; None:\n        logger.debug(\"Closing driver instance created for Neo4j client to release its connection pool\")\n        self._driver.close()\n\n    def _begin_session(self, **session_kwargs) -&gt; Session:\n        \"\"\"\n        Creates a database session with common as well as client specific configuration settings.\n\n        Returns:\n            A new `Session` object to execute transactions.\n        \"\"\"\n        session_config = {**self._config.session_config, **session_kwargs}\n        return self._driver.session(database=self._config.database, **session_config)\n\n    def _unit_of_work(self) -&gt; Callable:\n        \"\"\"\n        An extended version of managed transaction decorator to pass through configuration options from\n        `self._config.transaction_config`:\n\n        - ``metadata`` - will be attached to the executing transaction\n        - ``timeout`` - the transaction timeout in seconds\n\n        See more details in [Managed Transactions](https://neo4j.com/docs/api/python-driver/current/api.html#managed-transactions-transaction-functions)\n\n        Returns:\n            A pre-configured [neo4j.unit_of_work][] decorator\n        \"\"\"\n        return unit_of_work(\n            metadata=self._config.transaction_config.get(\"metadata\"),\n            timeout=self._config.transaction_config.get(\"timeout\"),\n        )\n\n    def _where_clause(self, filter_ast: Optional[AST]) -&gt; Tuple[str, Dict[str, Any]]:\n        \"\"\"\n        Converts a given filter syntax tree `filter_ast` into a Cypher query in order to build ``WHERE`` filter clause.\n        Along with the query method also returns parameters used in the query to be included into final request.\n        Find out more details about [WHERE clause](https://neo4j.com/docs/cypher-manual/current/clauses/where/)\n\n        Args:\n            filter_ast: Filters AST to be converted into Cypher query by \\\n                [Neo4jQueryConverter.convert][neo4j_haystack.metadata_filter.Neo4jQueryConverter.convert].\n        Returns:\n            ``WHERE`` filter clause used in filtering logic (e.g. `:::cypher WHERE doc.age &gt; $age`) as well as\n            parameters used in the clause  (e.g. `:::py {\"age\": 25}`)\n        \"\"\"\n        if filter_ast:\n            query, params = self._filter_converter.convert(filter_ast)\n            return f\"WHERE {query}\", params\n\n        # empty query and no parameters\n        return (\"\", {})\n\n    def _map_projection(self, skip_properties: Optional[List[str]]) -&gt; str:\n        \"\"\"\n        Creates a map projection Cypher query syntax with the option to skip certain properties.\n        Example query would be `:::cypher {.*, embedding=null}`, where `:::py skip_properties=[\"embedding\"]`\n\n        See Neo4j manual about [Map Projections](https://neo4j.com/docs/cypher-manual/current/values-and-types/maps/#cypher-map-projection)\n\n        Args:\n            skip_properties: a list of property names to skip (set values to ``null``) from map projection.\n\n        Returns:\n            A map projection Cypher query with skipped properties if any.\n        \"\"\"\n        all_props = [\".*\"] + ([f\"{p}: null\" for p in skip_properties] if skip_properties else [])\n        return f\"{{{','.join(all_props)}}}\"\n\n    def _vector_store_index_info(self, record: Record) -&gt; VectorStoreIndexInfo:\n        \"\"\"\n        Creates a dataclass from a data record returned by a ``SHOW INDEXES`` Cypher query output.\n\n        See Neo4j manual for [SHOW INDEXES](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/#indexes-list-indexes)\n\n        Args:\n            record: A Neo4j record containing ``SHOW INDEXES`` output.\n\n        Returns:\n            Custom dataclass with vector index information.\n        \"\"\"\n        return VectorStoreIndexInfo(\n            index_name=record[\"name\"],\n            node_label=record[\"labelsOrTypes\"][0],\n            property_key=record[\"properties\"][0],\n            dimensions=record[\"options\"][\"indexConfig\"][\"vector.dimensions\"],\n            similarity_function=record[\"options\"][\"indexConfig\"][\"vector.similarity_function\"],\n        )\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.delete_nodes","title":"delete_nodes","text":"<pre><code>delete_nodes(node_label: str, filter_ast: Optional[AST] = None) -&gt; None\n</code></pre> <p>Deletes nodes with with given label and filters using DELETE     Cypher clause.</p> <p>Parameters:</p> <ul> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>The name of the label to delete (e.g. <code>\"Document\"</code>)</p> </li> <li> <code>filter_ast</code>               (<code>Optional[AST]</code>, default:                   <code>None</code> )           \u2013            <p>Metadata filters to delete only specific nodes which match filtering conditions.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def delete_nodes(self, node_label: str, filter_ast: Optional[AST] = None) -&gt; None:\n    \"\"\"\n    Deletes nodes with with given label and filters using [DELETE](https://neo4j.com/docs/cypher-manual/current/clauses/delete/)\n        Cypher clause.\n\n    Args:\n        node_label: The name of the label to delete (e.g. ``\"Document\"``)\n        filter_ast: Metadata filters to delete only specific nodes which match filtering conditions.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n        where_clause, where_params = self._where_clause(filter_ast)\n        tx.run(\n            f\"\"\"\n            MATCH ({NODE_VAR}:`{node_label}`)\n            {where_clause}\n            DETACH DELETE {NODE_VAR}\n            \"\"\",\n            parameters={**where_params},\n        )\n\n    with self._begin_session() as session:\n        session.execute_write(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.create_index","title":"create_index","text":"<pre><code>create_index(\n    index_name: str,\n    label: str,\n    property_key: str,\n    dimension: int,\n    similarity_function: SimilarityFunction,\n) -&gt; None\n</code></pre> <p>Creates a new vector index in database for a given node label and vector specific attributes (e.g. dimension, similarity function etc). See documentation for the index creation procedure         db.index.vector.createNodeIndex</p> <p>Parameters:</p> <ul> <li> <code>index_name</code>               (<code>str</code>)           \u2013            <p>The unique name of the index.</p> </li> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The node label to be indexed (e.g. <code>\"Document\"</code>).</p> </li> <li> <code>property_key</code>               (<code>str</code>)           \u2013            <p>The property key of a node which contains embedding values.</p> </li> <li> <code>dimension</code>               (<code>int</code>)           \u2013            <p>Vector embedding dimension (must be between 1 and 2048 inclusively).</p> </li> <li> <code>similarity_function</code>               (<code>SimilarityFunction</code>)           \u2013            <p>case-insensitive values for the vector similarity function: <code>cosine</code> or <code>euclidean</code>.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def create_index(\n    self,\n    index_name: str,\n    label: str,\n    property_key: str,\n    dimension: int,\n    similarity_function: SimilarityFunction,\n) -&gt; None:\n    \"\"\"\n    Creates a new vector index in database for a given node label and vector specific attributes (e.g. dimension,\n    similarity function etc). See documentation for the index creation procedure \\\n    [db.index.vector.createNodeIndex](https://neo4j.com/docs/operations-manual/5/reference/procedures/#procedure_db_index_vector_createNodeIndex)\n\n    Args:\n        index_name: The unique name of the index.\n        label: The node label to be indexed (e.g. ``\"Document\"``).\n        property_key: The property key of a node which contains embedding values.\n        dimension: Vector embedding dimension (must be between 1 and 2048 inclusively).\n        similarity_function: case-insensitive values for the vector similarity function:\n            ``cosine`` or ``euclidean``.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n        tx.run(\n            \"\"\"\n            CALL db.index.vector.createNodeIndex(\n                $index_name,\n                $label,\n                $property_key,\n                toInteger($vector_dimension),\n                $similarity_function\n            )\n            \"\"\",\n            index_name=index_name,\n            label=label,\n            property_key=property_key,\n            vector_dimension=dimension,\n            similarity_function=similarity_function,\n        )\n\n    with self._begin_session() as session:\n        session.execute_write(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.retrieve_vector_index","title":"retrieve_vector_index","text":"<pre><code>retrieve_vector_index(\n    index_name: str, node_label: str, property_key: str\n) -&gt; Optional[VectorStoreIndexInfo]\n</code></pre> <p>Retrieves information about existing vector index.</p> <p>For more details and an example query on how to obtain existing indexes see         Query a vector index.</p> <p>Parameters:</p> <ul> <li> <code>index_name</code>               (<code>str</code>)           \u2013            <p>The name of the vector index to retrieve.</p> </li> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>The label of the node configured as prt of vector index setup.</p> </li> <li> <code>property_key</code>               (<code>str</code>)           \u2013            <p>The property key configured as part of vector index setup.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Neo4jClientError</code>             \u2013            <p>If more than one index found matching search criteria (same index name OR label+property combination).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[VectorStoreIndexInfo]</code>           \u2013            <p>Data retrieved from the query execution or <code>None</code> if index was not found.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def retrieve_vector_index(\n    self,\n    index_name: str,\n    node_label: str,\n    property_key: str,\n) -&gt; Optional[VectorStoreIndexInfo]:\n    \"\"\"\n    Retrieves information about existing vector index.\n\n    For more details and an example query on how to obtain existing indexes see \\\n    [Query a vector index](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-query).\n\n    Args:\n        index_name: The name of the vector index to retrieve.\n        node_label: The label of the node configured as prt of vector index setup.\n        property_key: The property key configured as part of vector index setup.\n\n    Raises:\n        Neo4jClientError: If more than one index found matching search criteria (same index name OR\n            label+property combination).\n\n    Returns:\n        Data retrieved from the query execution or `None` if index was not found.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction) -&gt; List[Record]:\n        result = tx.run(\n            \"\"\"\n            SHOW INDEXES YIELD name, type, labelsOrTypes, properties, options\n            WHERE type = 'VECTOR' AND\n            (name = $index_name OR (labelsOrTypes[0] = $node_label AND properties[0] = $property_key))\n            RETURN name, labelsOrTypes, properties, options\n            \"\"\",\n            index_name=index_name,\n            node_label=node_label,\n            property_key=property_key,\n        )\n\n        return list(result)\n\n    with self._begin_session() as session:\n        found_indexes = session.execute_write(_mgt_tx)\n\n    if len(found_indexes) &gt; 1:\n        raise Neo4jClientError(\n            \"Failed to retrieve vector index from Neo4j.\"\n            \"There were several indexes found with a given search criteria: \"\n            f\"$index_name='{index_name}' OR ($node_label='{node_label}' AND $property_key='{property_key}'). \"\n            \"Please make sure the Neo4jDocumentStore points to an unambiguous vector index\"\n        )\n\n    return self._vector_store_index_info(found_indexes[0]) if found_indexes else None\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.create_index_if_missing","title":"create_index_if_missing","text":"<pre><code>create_index_if_missing(\n    index_name: str,\n    label: str,\n    property_key: str,\n    dimension: int,\n    similarity_function: SimilarityFunction,\n)\n</code></pre> <p>Creates a vector index in case it does not exist in database. Uses same parameters as create_index             method.</p> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def create_index_if_missing(\n    self,\n    index_name: str,\n    label: str,\n    property_key: str,\n    dimension: int,\n    similarity_function: SimilarityFunction,\n):\n    \"\"\"\n    Creates a vector index in case it does not exist in database.\n    Uses same parameters as [create_index][neo4j_haystack.client.neo4j_client.Neo4jClient.create_index] \\\n        method.\n    \"\"\"\n\n    existing_index = self.retrieve_vector_index(index_name, label, property_key)\n\n    if not existing_index:\n        logger.debug(\"Creating a new index(%s) as it is not present in the configured Neo4j database\", index_name)\n        self.create_index(index_name, label, property_key, dimension, similarity_function)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.delete_index","title":"delete_index","text":"<pre><code>delete_index(index_name: str) -&gt; None\n</code></pre> <p>Removes index from Neo4j database.</p> <p>See Cypher manual on Drop vector indexes</p> <p>Parameters:</p> <ul> <li> <code>index_name</code>               (<code>str</code>)           \u2013            <p>The name of the index to delete.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def delete_index(self, index_name: str) -&gt; None:\n    \"\"\"\n    Removes index from Neo4j database.\n\n    See Cypher manual on [Drop vector indexes](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-drop)\n\n    Args:\n        index_name: The name of the index to delete.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n        tx.run(f\"DROP INDEX `{index_name}`\")\n\n    with self._begin_session() as session:\n        session.execute_write(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.update_embedding","title":"update_embedding","text":"<pre><code>update_embedding(\n    node_label: str, embedding_field: str, records: List[Dict[str, Any]]\n) -&gt; None\n</code></pre> <p>Updates embedding on a number of <code>Document</code> nodes. It uses <code>db.create.setNodeVectorProperty()</code> procedure as a recommended update method. See more details in Set a vector property on a node</p> <p>Parameters:</p> <ul> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>A node label to match (e.g. <code>\"Document\"</code>).</p> </li> <li> <code>embedding_field</code>               (<code>str</code>)           \u2013            <p>The name of the embedding field which stores embeddings (of type <code>LIST&lt;FLOAT&gt;</code>) as part node properties.</p> </li> <li> <code>records</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>A list dictionary objects following the structure: <pre><code>    [{\n        \"id\": \"doc_id1\", # id of the Document (node) to update\n        embedding_field: [0.8, 0.9, ...] # Embedding vector\n    }]\n</code></pre></p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def update_embedding(self, node_label: str, embedding_field: str, records: List[Dict[str, Any]]) -&gt; None:\n    \"\"\"\n    Updates embedding on a number of ``Document`` nodes. It uses ``db.create.setNodeVectorProperty()`` procedure as\n    a recommended update method. See more details in [Set a vector property on a node](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-set)\n\n    Args:\n        node_label: A node label to match (e.g. ``\"Document\"``).\n        embedding_field: The name of the embedding field which stores embeddings (of type ``LIST&lt;FLOAT&gt;``) as part\n            node properties.\n        records: A list dictionary objects following the structure:\n            ```python\n                [{\n                    \"id\": \"doc_id1\", # id of the Document (node) to update\n                    embedding_field: [0.8, 0.9, ...] # Embedding vector\n                }]\n            ```\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction) -&gt; None:\n        tx.run(\n            f\"\"\"\n            WITH $records AS batch\n            UNWIND batch as row\n            MATCH ({NODE_VAR}:`{node_label}` {{id: row.id}})\n            CALL db.create.setNodeVectorProperty({NODE_VAR}, '{embedding_field}', row.{embedding_field})\n            RETURN {NODE_VAR}\n            \"\"\",\n            records=records,\n        )\n\n    with self._begin_session() as session:\n        session.execute_write(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.merge_nodes","title":"merge_nodes","text":"<pre><code>merge_nodes(\n    node_label: str, embedding_field: str, records: List[Neo4jRecord]\n) -&gt; ResultSummary\n</code></pre> <p>Creates or updates a node in neo4j representing a Document with all properties. Nodes are matched by \"id\", if not found a new node will be created. See the following manuals:</p> <ul> <li>MERGE clause</li> <li>Settings properties using a map</li> <li>db.create.setNodeVectorProperty</li> </ul> <p>Parameters:</p> <ul> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>The label of the node to match (e.g. \"Document\").</p> </li> <li> <code>embedding_field</code>               (<code>str</code>)           \u2013            <p>The name of the embedding field which stores embeddings (of type <code>LIST&lt;FLOAT&gt;</code>) as part of node properties. Embeddings (if present) will be updated/set by <code>db.create.setNodeVectorProperty()</code> procedure - <code>embedding_field</code> is excluded from <code>SET</code> Cypher clause by using map projections.</p> </li> <li> <code>records</code>               (<code>List[Neo4jRecord]</code>)           \u2013            <p>A list of Documents                 converted to dictionaries, with <code>meta</code> attributes included.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def merge_nodes(self, node_label: str, embedding_field: str, records: List[Neo4jRecord]) -&gt; ResultSummary:\n    \"\"\"\n    Creates or updates a node in neo4j representing a Document with all properties. Nodes are matched by \"id\",\n    if not found a new node will be created. See the following manuals:\n\n    - [MERGE clause](https://neo4j.com/docs/cypher-manual/current/clauses/merge/)\n    - [Settings properties using a map](https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map)\n    - [db.create.setNodeVectorProperty](https://neo4j.com/docs/operations-manual/5/reference/procedures/#procedure_db_create_setNodeVectorProperty)\n\n    Args:\n        node_label: The label of the node to match (e.g. \"Document\").\n        embedding_field: The name of the embedding field which stores embeddings (of type ``LIST&lt;FLOAT&gt;``) as part\n            of node properties. Embeddings (if present) will be updated/set by ``db.create.setNodeVectorProperty()``\n            procedure - `embedding_field` is excluded from ``SET`` Cypher clause by using map projections.\n        records: A list of [Documents](https://docs.haystack.deepset.ai/reference/primitives-api#document) \\\n            converted to dictionaries, with ``meta`` attributes included.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction):\n        result = tx.run(\n            f\"\"\"\n            WITH $records AS batch\n            UNWIND batch as row\n            MERGE ({NODE_VAR}:`{node_label}` {{id: row.id}})\n            SET {NODE_VAR} += row{{.*, {embedding_field}: null}}\n            WITH {NODE_VAR}, row\n            CALL {{ WITH {NODE_VAR}, row\n                MATCH({NODE_VAR}:`{node_label}` {{id: row.id}}) WHERE row.embedding IS NOT NULL\n                CALL db.create.setNodeVectorProperty({NODE_VAR}, '{embedding_field}', row.{embedding_field})\n            }}\n            \"\"\",\n            records=records,\n        )\n        summary = result.consume()\n        return summary\n\n    with self._begin_session() as session:\n        return session.execute_write(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.count_nodes","title":"count_nodes","text":"<pre><code>count_nodes(node_label: str, filter_ast: Optional[AST] = None) -&gt; int\n</code></pre> <p>Counts number of nodes matching given label and optional filters.</p> <p>Parameters:</p> <ul> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>The label of the node to match (e.g. <code>\"Document\"</code>).</p> </li> <li> <code>filter_ast</code>               (<code>Optional[AST]</code>, default:                   <code>None</code> )           \u2013            <p>The filter syntax tree (parsed metadata filter) to narrow down counted results.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of found nodes.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def count_nodes(self, node_label: str, filter_ast: Optional[AST] = None) -&gt; int:\n    \"\"\"\n    Counts number of nodes matching given label and optional filters.\n\n    Args:\n        node_label: The label of the node to match (e.g. ``\"Document\"``).\n        filter_ast: The filter syntax tree (parsed metadata filter) to narrow down counted results.\n\n    Returns:\n        Number of found nodes.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction):\n        where_clause, where_params = self._where_clause(filter_ast)\n        result = tx.run(\n            f\"\"\"\n            MATCH ({NODE_VAR}:`{node_label}`)\n            {where_clause}\n            RETURN count(*) as count\n            \"\"\",\n            parameters={**where_params},\n        )\n        return result.single(strict=True).value()\n\n    with self._begin_session() as session:\n        return session.execute_read(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.find_nodes","title":"find_nodes","text":"<pre><code>find_nodes(\n    node_label: str,\n    filter_ast: Optional[AST] = None,\n    skip_properties: Optional[List[str]] = None,\n    fetch_size: int = 1000,\n) -&gt; Generator[Neo4jRecord, None, None]\n</code></pre> <p>Search for nodes matching a given label and metadata filters.</p> <p>Parameters:</p> <ul> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>The label of the nodes to match (e.g. <code>\"Document\"</code>).</p> </li> <li> <code>filter_ast</code>               (<code>Optional[AST]</code>, default:                   <code>None</code> )           \u2013            <p>The filter syntax tree (parsed metadata filter) for search.</p> </li> <li> <code>skip_properties</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Properties we would like not to return as part of data payload. Is uses map projection Cypher syntax, e.g. <code>doc{.*, embedding: null}</code> - such construct will make sure <code>embedding</code> is not returned back in results.</p> </li> <li> <code>fetch_size</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Controls how many records are fetched at once from the database which helps with batching process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Found records matching search criteria.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def find_nodes(\n    self,\n    node_label: str,\n    filter_ast: Optional[AST] = None,\n    skip_properties: Optional[List[str]] = None,\n    fetch_size: int = 1000,\n) -&gt; Generator[Neo4jRecord, None, None]:\n    \"\"\"\n    Search for nodes matching a given label and metadata filters.\n\n    Args:\n        node_label: The label of the nodes to match (e.g. ``\"Document\"``).\n        filter_ast: The filter syntax tree (parsed metadata filter) for search.\n        skip_properties: Properties we would like not to return as part of data payload. Is uses map projection\n            Cypher syntax, e.g. `:::cypher doc{.*, embedding: null}` - such construct will make sure ``embedding``\n            is not returned back in results.\n        fetch_size: Controls how many records are fetched at once from the database which helps with batching\n            process.\n\n    Returns:\n        Found records matching search criteria.\n    \"\"\"\n    where_clause, where_params = self._where_clause(filter_ast)\n    query = f\"\"\"\n        MATCH ({NODE_VAR}:`{node_label}`)\n        {where_clause}\n        RETURN {NODE_VAR}{self._map_projection(skip_properties)}\n        \"\"\"\n\n    for record in self.query_nodes(query=query, parameters={**where_params}, fetch_size=fetch_size):\n        yield cast(Neo4jRecord, record.data().get(NODE_VAR))\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.query_nodes","title":"query_nodes","text":"<pre><code>query_nodes(\n    query: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    fetch_size: int = 1000,\n) -&gt; Generator[Record, None, None]\n</code></pre> <p>Runs a given Cypher <code>query</code>. The implementation is based on <code>Unmanaged Transactions</code> for greater control and possibility to <code>yield</code> results as soon as those are fetched from database. The Neo4j python driver internally manages a buffer which replenished while records are being consumed thus making sure we do not store all fetched records in memory. That greatly simplifies batching mechanism as it is implemented by the buffer. See more details about how python driver implements         Explicit/Unmanaged Transactions</p> Note <p>Please notice results are yielded while read transaction is still open. That should impact your choice of transaction timeout setting, see                 Neo4jClientConfig.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>Cypher query to run in Neo4j.</p> </li> <li> <code>parameters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Query parameters which can be used as placeholders in the <code>query</code>.</p> </li> <li> <code>fetch_size</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Controls how many records are fetched at once from the database which helps with batching process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Records containing data specified in <code>RETURN</code> Cypher query statement.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def query_nodes(\n    self,\n    query: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    fetch_size: int = 1000,\n) -&gt; Generator[Record, None, None]:\n    \"\"\"\n    Runs a given Cypher `query`. The implementation is based on ``Unmanaged Transactions``\n    for greater control and possibility to ``yield`` results as soon as those are fetched from database. The Neo4j\n    python driver internally manages a buffer which replenished while records are being consumed thus making sure we\n    do not store all fetched records in memory. That greatly simplifies batching mechanism as it is implemented by\n    the buffer. See more details about how python driver implements \\\n    [Explicit/Unmanaged Transactions](https://neo4j.com/docs/api/python-driver/current/api.html#explicit-transactions-unmanaged-transactions)\n\n    Note:\n        Please notice results are yielded while read transaction is still open. That should impact your choice of\n        transaction timeout setting, see \\\n            [Neo4jClientConfig][neo4j_haystack.client.neo4j_client.Neo4jClientConfig].\n\n    Args:\n        query: Cypher query to run in Neo4j.\n        parameters: Query parameters which can be used as placeholders in the `query`.\n        fetch_size: Controls how many records are fetched at once from the database which helps with batching\n            process.\n\n    Returns:\n        Records containing data specified in ``RETURN`` Cypher query statement.\n    \"\"\"\n    with self._begin_session(fetch_size=fetch_size) as session:\n        with session.begin_transaction(\n            metadata=self._config.transaction_config.get(\"metadata\"),\n            timeout=self._config.transaction_config.get(\"timeout\"),\n        ) as tx:\n            try:\n                result: Result = tx.run(\n                    query,\n                    parameters=parameters,\n                )\n                yield from result\n            finally:\n                tx.close()\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.query_embeddings","title":"query_embeddings","text":"<pre><code>query_embeddings(\n    index: str,\n    top_k: int,\n    embedding: List[float],\n    filter_ast: Optional[AST] = None,\n    skip_properties: Optional[List[str]] = None,\n    vector_top_k: Optional[int] = None,\n) -&gt; List[Neo4jRecord]\n</code></pre> <p>Query a vector index and apply filtering using <code>WHERE</code> clause on results returned by vector search. See the following documentation for more details:</p> <ul> <li>Query a vector index</li> <li>db.index.vector.queryNodes()</li> </ul> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>str</code>)           \u2013            <p>Refers to the unique name of the vector index to query.</p> </li> <li> <code>top_k</code>               (<code>int</code>)           \u2013            <p>Number of results to return from vector search.</p> </li> <li> <code>embedding</code>               (<code>List[float]</code>)           \u2013            <p>The query vector (a <code>LIST&lt;FLOAT&gt;</code>) in which to search for the neighborhood.</p> </li> <li> <code>filter_ast</code>               (<code>Optional[AST]</code>, default:                   <code>None</code> )           \u2013            <p>Additional filters translated into <code>WHERE</code> Cypher clause by                 Neo4jQueryConverter</p> </li> <li> <code>skip_properties</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Properties we would like not to return as part of data payload. Is uses map projection Cypher syntax, e.g. <code>doc{.*, embedding: null}</code> - such construct will make sure <code>embedding</code> is not returned back in results.</p> </li> <li> <code>vector_top_k</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>If provided <code>vector_top_k</code> is used instead of <code>top_k</code> in order to increase number of results (nearest neighbors) from vector search. It makes sense when filters (<code>filter_ast</code>) could further narrow down vector search result. Only <code>top_k</code> number of records will be returned back thus <code>vector_top_k</code> should be preferably greater than <code>top_k</code>.</p> </li> </ul> <p>Returns:     An ordered by score <code>top_k</code> nodes found in vector search which are optionally filtered using         <code>WHERE</code> clause.</p> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def query_embeddings(\n    self,\n    index: str,\n    top_k: int,\n    embedding: List[float],\n    filter_ast: Optional[AST] = None,\n    skip_properties: Optional[List[str]] = None,\n    vector_top_k: Optional[int] = None,\n) -&gt; List[Neo4jRecord]:\n    \"\"\"\n    Query a vector index and apply filtering using `WHERE` clause on results returned by vector search.\n    See the following documentation for more details:\n\n    - [Query a vector index](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-query)\n    - [db.index.vector.queryNodes()](https://neo4j.com/docs/operations-manual/5/reference/procedures/#procedure_db_index_vector_queryNodes)\n\n    Args:\n        index: Refers to the unique name of the vector index to query.\n        top_k: Number of results to return from vector search.\n        embedding: The query vector (a ``LIST&lt;FLOAT&gt;``) in which to search for the neighborhood.\n        filter_ast: Additional filters translated into `WHERE` Cypher clause by \\\n            [Neo4jQueryConverter][neo4j_haystack.metadata_filter.Neo4jQueryConverter]\n        skip_properties: Properties we would like **not** to return as part of data payload. Is uses map projection\n            Cypher syntax, e.g. `:::cypher doc{.*, embedding: null}` - such construct will make sure `embedding` is\n            not returned back in results.\n        vector_top_k: If provided `vector_top_k` is used instead of `top_k` in order to increase number of\n            results (nearest neighbors) from vector search. It makes sense when filters (`filter_ast`) could\n            further narrow down vector search result. Only `top_k` number of records will be returned back thus\n            `vector_top_k` should be preferably greater than `top_k`.\n    Returns:\n        An ordered by score `top_k` nodes found in vector search which are optionally filtered using\n            ``WHERE`` clause.\n    \"\"\"\n\n    score_property = \"score\"\n\n    if vector_top_k and vector_top_k &lt; top_k:\n        logger.warning(\n            \"Make sure 'vector_top_k'(=%s) is greater than 'top_k'(=%s) parameter. Using 'top_k' instead\",\n            vector_top_k,\n            top_k,\n        )\n        vector_top_k = top_k\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction) -&gt; List[Record]:\n        where_clause, where_params = self._where_clause(filter_ast)\n        result = tx.run(\n            f\"\"\"\n            CALL db.index.vector.queryNodes($index, $vector_top_k, $embedding)\n            YIELD node as {NODE_VAR}, {score_property}\n            MATCH ({NODE_VAR}) {where_clause}\n            RETURN {NODE_VAR}{self._map_projection(skip_properties)}, {score_property}\n            ORDER BY {score_property} DESC LIMIT $top_k\n            \"\"\",\n            parameters={\n                \"index\": index,\n                \"top_k\": top_k,\n                \"embedding\": embedding,\n                \"vector_top_k\": vector_top_k or top_k,\n                **where_params,\n            },\n        )\n        return list(result)\n\n    with self._begin_session() as session:\n        records = session.execute_read(_mgt_tx)\n\n    return [{**record.value(NODE_VAR), score_property: record.value(\"score\")} for record in records]\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.execute_write","title":"execute_write","text":"<pre><code>execute_write(\n    query: str, parameters: Optional[Dict[str, Any]] = None\n) -&gt; Tuple[ResultSummary, List[Dict[str, Any]]]\n</code></pre> <p>Runs an arbitrary write Cypher query with parameters.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>Cypher query to run in Neo4j.</p> </li> <li> <code>parameters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Query parameters which can be used as placeholders in the <code>query</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[ResultSummary, List[Dict[str, Any]]]</code>           \u2013            <p>A tuple consisting of execution result summary (<code>neo4j.ResultSummary</code>) and data records (<code>dict</code>) if any.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def execute_write(\n    self,\n    query: str,\n    parameters: Optional[Dict[str, Any]] = None,\n) -&gt; Tuple[ResultSummary, List[Dict[str, Any]]]:\n    \"\"\"\n    Runs an arbitrary write Cypher query with parameters.\n\n    Args:\n        query: Cypher query to run in Neo4j.\n        parameters: Query parameters which can be used as placeholders in the `query`.\n\n    Returns:\n        A tuple consisting of execution result summary (`neo4j.ResultSummary`) and data records (`dict`) if any.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction):\n        result = tx.run(\n            query,\n            parameters=parameters,\n        )\n        records = result.data()\n        summary = result.consume()\n        return summary, records\n\n    with self._begin_session() as session:\n        return session.execute_write(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.execute_read","title":"execute_read","text":"<pre><code>execute_read(\n    query: str, parameters: Optional[Dict[str, Any]] = None\n) -&gt; Tuple[ResultSummary, List[Dict[str, Any]]]\n</code></pre> <p>Runs an arbitrary \"read\" Cypher query with parameters.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>Cypher query to run in Neo4j.</p> </li> <li> <code>parameters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Query parameters which can be used as placeholders in the <code>query</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[ResultSummary, List[Dict[str, Any]]]</code>           \u2013            <p>A tuple consisting of execution result summary (<code>neo4j.ResultSummary</code>) and data records if any.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def execute_read(\n    self,\n    query: str,\n    parameters: Optional[Dict[str, Any]] = None,\n) -&gt; Tuple[ResultSummary, List[Dict[str, Any]]]:\n    \"\"\"\n    Runs an arbitrary \"read\" Cypher query with parameters.\n\n    Args:\n        query: Cypher query to run in Neo4j.\n        parameters: Query parameters which can be used as placeholders in the `query`.\n\n    Returns:\n        A tuple consisting of execution result summary (`neo4j.ResultSummary`) and data records if any.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction):\n        result = tx.run(\n            query,\n            parameters=parameters,\n        )\n        records = result.data()\n        summary = result.consume()\n        return summary, records\n\n    with self._begin_session() as session:\n        return session.execute_read(_mgt_tx)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.update_node","title":"update_node","text":"<pre><code>update_node(\n    node_label: str, doc_id: str, data: Dict[str, Any]\n) -&gt; Optional[Neo4jRecord]\n</code></pre> <p>Updates a given node matched by the given id (<code>doc_id</code>). Properties are mutated by <code>+=</code> operator, see more details in Setting properties using map.</p> <p>Parameters:</p> <ul> <li> <code>node_label</code>               (<code>str</code>)           \u2013            <p>A node label to match (e.g. \"Document\").</p> </li> <li> <code>doc_id</code>               (<code>str</code>)           \u2013            <p>Node id to match. Please notice the <code>id</code> used in Cypher query is not a native element id but the one which mapped from the haystack.schema.Document.</p> </li> <li> <code>data</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>A dictionary of data which will be set as node's properties.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Neo4jRecord]</code>           \u2013            <p>Updated Neo4j record data.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def update_node(self, node_label: str, doc_id: str, data: Dict[str, Any]) -&gt; Optional[Neo4jRecord]:\n    \"\"\"\n    Updates a given node matched by the given id (`doc_id`). Properties are mutated by `+=` operator,\n    see more details in [Setting properties using map](https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map).\n\n    Args:\n        node_label: A node label to match (e.g. \"Document\").\n        doc_id: Node id to match. Please notice the `id` used in Cypher query is not a native element id but\n            the one which mapped from the [haystack.schema.Document](https://docs.haystack.deepset.ai/reference/primitives-api#document).\n        data: A dictionary of data which will be set as node's properties.\n\n    Returns:\n        Updated Neo4j record data.\n    \"\"\"\n\n    @self._unit_of_work()\n    def _mgt_tx(tx: ManagedTransaction):\n        result = tx.run(\n            f\"\"\"\n            MATCH ({NODE_VAR}:`{node_label}` {{id: $doc_id}})\n            SET {NODE_VAR} += $doc_data\n            RETURN {NODE_VAR}\n            \"\"\",\n            doc_id=doc_id,\n            doc_data=data,\n        )\n        return result.single(strict=False)\n\n    with self._begin_session() as session:\n        record = session.execute_write(_mgt_tx)\n\n    return record.data().get(NODE_VAR) if record else None\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient.verify_connectivity","title":"verify_connectivity","text":"<pre><code>verify_connectivity()\n</code></pre> <p>Verifies connection to Neo4j database as per configuration and auth credentials provided.</p> <p>Raises:</p> <ul> <li> <code>Neo4jClientError</code>             \u2013            <p>In case connection could not be established.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def verify_connectivity(self):\n    \"\"\"\n    Verifies connection to Neo4j database as per configuration and auth credentials provided.\n\n    Raises:\n        Neo4jClientError: In case connection could not be established.\n    \"\"\"\n    try:\n        self._driver.verify_connectivity()\n    except Exception as err:\n        raise Neo4jClientError(\n            \"Could not connect to Neo4j database. Please ensure that the url and provided credentials are correct\"\n        ) from err\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient._begin_session","title":"_begin_session","text":"<pre><code>_begin_session(**session_kwargs) -&gt; Session\n</code></pre> <p>Creates a database session with common as well as client specific configuration settings.</p> <p>Returns:</p> <ul> <li> <code>Session</code>           \u2013            <p>A new <code>Session</code> object to execute transactions.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def _begin_session(self, **session_kwargs) -&gt; Session:\n    \"\"\"\n    Creates a database session with common as well as client specific configuration settings.\n\n    Returns:\n        A new `Session` object to execute transactions.\n    \"\"\"\n    session_config = {**self._config.session_config, **session_kwargs}\n    return self._driver.session(database=self._config.database, **session_config)\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient._unit_of_work","title":"_unit_of_work","text":"<pre><code>_unit_of_work() -&gt; Callable\n</code></pre> <p>An extended version of managed transaction decorator to pass through configuration options from <code>self._config.transaction_config</code>:</p> <ul> <li><code>metadata</code> - will be attached to the executing transaction</li> <li><code>timeout</code> - the transaction timeout in seconds</li> </ul> <p>See more details in Managed Transactions</p> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A pre-configured neo4j.unit_of_work decorator</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def _unit_of_work(self) -&gt; Callable:\n    \"\"\"\n    An extended version of managed transaction decorator to pass through configuration options from\n    `self._config.transaction_config`:\n\n    - ``metadata`` - will be attached to the executing transaction\n    - ``timeout`` - the transaction timeout in seconds\n\n    See more details in [Managed Transactions](https://neo4j.com/docs/api/python-driver/current/api.html#managed-transactions-transaction-functions)\n\n    Returns:\n        A pre-configured [neo4j.unit_of_work][] decorator\n    \"\"\"\n    return unit_of_work(\n        metadata=self._config.transaction_config.get(\"metadata\"),\n        timeout=self._config.transaction_config.get(\"timeout\"),\n    )\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient._where_clause","title":"_where_clause","text":"<pre><code>_where_clause(filter_ast: Optional[AST]) -&gt; Tuple[str, Dict[str, Any]]\n</code></pre> <p>Converts a given filter syntax tree <code>filter_ast</code> into a Cypher query in order to build <code>WHERE</code> filter clause. Along with the query method also returns parameters used in the query to be included into final request. Find out more details about WHERE clause</p> <p>Parameters:</p> <ul> <li> <code>filter_ast</code>               (<code>Optional[AST]</code>)           \u2013            <p>Filters AST to be converted into Cypher query by                 Neo4jQueryConverter.convert.</p> </li> </ul> <p>Returns:     <code>WHERE</code> filter clause used in filtering logic (e.g. <code>WHERE doc.age &gt; $age</code>) as well as     parameters used in the clause  (e.g. <code>{\"age\": 25}</code>)</p> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def _where_clause(self, filter_ast: Optional[AST]) -&gt; Tuple[str, Dict[str, Any]]:\n    \"\"\"\n    Converts a given filter syntax tree `filter_ast` into a Cypher query in order to build ``WHERE`` filter clause.\n    Along with the query method also returns parameters used in the query to be included into final request.\n    Find out more details about [WHERE clause](https://neo4j.com/docs/cypher-manual/current/clauses/where/)\n\n    Args:\n        filter_ast: Filters AST to be converted into Cypher query by \\\n            [Neo4jQueryConverter.convert][neo4j_haystack.metadata_filter.Neo4jQueryConverter.convert].\n    Returns:\n        ``WHERE`` filter clause used in filtering logic (e.g. `:::cypher WHERE doc.age &gt; $age`) as well as\n        parameters used in the clause  (e.g. `:::py {\"age\": 25}`)\n    \"\"\"\n    if filter_ast:\n        query, params = self._filter_converter.convert(filter_ast)\n        return f\"WHERE {query}\", params\n\n    # empty query and no parameters\n    return (\"\", {})\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient._map_projection","title":"_map_projection","text":"<pre><code>_map_projection(skip_properties: Optional[List[str]]) -&gt; str\n</code></pre> <p>Creates a map projection Cypher query syntax with the option to skip certain properties. Example query would be <code>{.*, embedding=null}</code>, where <code>skip_properties=[\"embedding\"]</code></p> <p>See Neo4j manual about Map Projections</p> <p>Parameters:</p> <ul> <li> <code>skip_properties</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>a list of property names to skip (set values to <code>null</code>) from map projection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A map projection Cypher query with skipped properties if any.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def _map_projection(self, skip_properties: Optional[List[str]]) -&gt; str:\n    \"\"\"\n    Creates a map projection Cypher query syntax with the option to skip certain properties.\n    Example query would be `:::cypher {.*, embedding=null}`, where `:::py skip_properties=[\"embedding\"]`\n\n    See Neo4j manual about [Map Projections](https://neo4j.com/docs/cypher-manual/current/values-and-types/maps/#cypher-map-projection)\n\n    Args:\n        skip_properties: a list of property names to skip (set values to ``null``) from map projection.\n\n    Returns:\n        A map projection Cypher query with skipped properties if any.\n    \"\"\"\n    all_props = [\".*\"] + ([f\"{p}: null\" for p in skip_properties] if skip_properties else [])\n    return f\"{{{','.join(all_props)}}}\"\n</code></pre>"},{"location":"reference/neo4j_client/#neo4j_haystack.client.neo4j_client.Neo4jClient._vector_store_index_info","title":"_vector_store_index_info","text":"<pre><code>_vector_store_index_info(record: Record) -&gt; VectorStoreIndexInfo\n</code></pre> <p>Creates a dataclass from a data record returned by a <code>SHOW INDEXES</code> Cypher query output.</p> <p>See Neo4j manual for SHOW INDEXES</p> <p>Parameters:</p> <ul> <li> <code>record</code>               (<code>Record</code>)           \u2013            <p>A Neo4j record containing <code>SHOW INDEXES</code> output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VectorStoreIndexInfo</code>           \u2013            <p>Custom dataclass with vector index information.</p> </li> </ul> Source code in <code>src/neo4j_haystack/client/neo4j_client.py</code> <pre><code>def _vector_store_index_info(self, record: Record) -&gt; VectorStoreIndexInfo:\n    \"\"\"\n    Creates a dataclass from a data record returned by a ``SHOW INDEXES`` Cypher query output.\n\n    See Neo4j manual for [SHOW INDEXES](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/#indexes-list-indexes)\n\n    Args:\n        record: A Neo4j record containing ``SHOW INDEXES`` output.\n\n    Returns:\n        Custom dataclass with vector index information.\n    \"\"\"\n    return VectorStoreIndexInfo(\n        index_name=record[\"name\"],\n        node_label=record[\"labelsOrTypes\"][0],\n        property_key=record[\"properties\"][0],\n        dimensions=record[\"options\"][\"indexConfig\"][\"vector.dimensions\"],\n        similarity_function=record[\"options\"][\"indexConfig\"][\"vector.similarity_function\"],\n    )\n</code></pre>"},{"location":"reference/neo4j_query_reader/","title":"Neo4jQueryReader","text":""},{"location":"reference/neo4j_query_reader/#neo4j_haystack.components.neo4j_query_reader.QueryResult","title":"QueryResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Query execution outputs for the <code>Neo4jQueryReader</code> component.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_reader.py</code> <pre><code>class QueryResult(TypedDict):\n    \"\"\"\n    Query execution outputs for the `Neo4jQueryReader` component.\n    \"\"\"\n\n    records: NotRequired[List[Dict[str, Any]]]\n    first_record: NotRequired[Optional[Dict[str, Any]]]\n    error: NotRequired[Exception]\n    error_message: NotRequired[str]\n</code></pre>"},{"location":"reference/neo4j_query_reader/#neo4j_haystack.components.neo4j_query_reader.Neo4jQueryReader","title":"Neo4jQueryReader","text":"<p>A component for reading arbitrary data from Neo4j database using plain Cypher query.</p> <p>This component gives flexible way to read data from Neo4j by running custom Cypher query along with query parameters. Query parameters can be supplied in a pipeline from other components (or pipeline inputs). You could use such queries to read data from Neo4j to enhance your RAG pipelines. For example a prompt to LLM can produce Cypher query based on given context and then <code>Neo4jQueryReader</code> can be used to run the query and extract results. OutputAdapter component might become handy in such scenarios - it can be used as a connection from the <code>Neo4jQueryReader</code> to convert (transform) results accordingly.</p> Note <p>Please consider data types mappings in         Cypher query when working with query parameters. Neo4j Python Driver handles type conversions/mappings. Specifically you can figure out in the documentation of the driver how to work with temporal types.</p> Example: Find a Document node with Neo4jQueryReader and extract data<pre><code>from neo4j_haystack.client.neo4j_client import Neo4jClientConfig\nfrom neo4j_haystack.components.neo4j_query_reader import Neo4jQueryReader\n\nclient_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\n\nreader = Neo4jQueryReader(client_config=client_config, runtime_parameters=[\"year\"])\n\n# Get all documents with \"year\"=2020 and return \"name\" and \"embedding\" attributes for each found record\nresult = reader.run(\n    query=(\"MATCH (doc:`Document`) WHERE doc.year=$year RETURN doc.name as name, doc.embedding as embedding\"),\n    year=2020,\n)\n</code></pre> Output <p><code>&gt;&gt;&gt; {'records': [{'name': 'name_0', 'embedding': [...]}, {'name': 'name_1', 'embedding': [...]},         {'name': 'name_2', 'embedding': [...]}], 'first_record': {'name': 'name_0', 'embedding': [...]}}</code></p> <p>The above result contains the following output:</p> <ul> <li><code>records</code> - A list of dictionaries, will have all the records returned by Cypher query. You can control record     outputs as per your needs. For example an aggregation function could be used to return a single result.     In such case there will be one record in the <code>records</code> list.</li> <li><code>first_record</code> - In case the <code>records</code> contains just  one item, <code>first_record</code> will have the first record     from the list (put simply, first_record=records[0]). It was introduced as a syntax convenience.</li> </ul> <p>If your Cypher query produces an error (e.g. invalid syntax) you could use that in <code>Loop-Based Auto-Correction</code> pipelines to ask LLM to auto correct the query based on the error message, afterwards run the query again.</p> Example: Output error with Neo4jQueryReader<pre><code>from neo4j_haystack.client.neo4j_client import Neo4jClientConfig\nfrom neo4j_haystack.components.neo4j_query_reader import Neo4jQueryReader\n\nclient_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\n\nreader = Neo4jQueryReader(client_config=client_config, raise_on_failure=False)\n\n# Intentionally introduce error in Cypher query (see \"RETURN_\")\nresult = reader.run(\n    query=(\"MATCH (doc:`Document` {name: $name}) RETURN_ doc.name as name, doc.year as year\"),\n    parameters={\"name\": \"name_1\"},\n)\n</code></pre> Output <p><code>&gt;&gt;&gt; {'error_message': 'Invalid input 'RETURN_'...', 'error': &lt;Exception&gt;}</code></p> <p>The <code>error_message</code> output can be used in your pipeline to deal with Cypher query error (e.g. auto correction)</p> <p>When configuring Query parameters     for <code>Neo4jQueryReader</code> component, consider the following:</p> <ul> <li>Parameters can be provided at the component creation time, see <code>parameters</code></li> <li>In RAG pipeline runtime parameters could be connected from other components.   Make sure during creation time to specify which <code>runtime_parameters</code> are expected.</li> </ul> Important <p>At the moment parameters support simple data types, dictionaries and python dataclasses (which can be converted to <code>dict</code>). For example <code>haystack.ChatMessage</code> instance is a valid query parameter input. If you supply custom classes as query parameters, e.g.         <code>Neo4jQueryReader(client_config=client_config).run(parameters={\"obj\": &lt;instance of custom class&gt;})</code> it will result in error. In such rare cases <code>query_parameters_marshaller</code> attribute can be used to provide a custom marshaller implementation for the type being used as query parameter value.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_reader.py</code> <pre><code>@component\nclass Neo4jQueryReader:\n    \"\"\"\n    A component for reading arbitrary data from Neo4j database using plain Cypher query.\n\n    This component gives flexible way to read data from Neo4j by running custom Cypher query along with query\n    parameters. Query parameters can be supplied in a pipeline from other components (or pipeline inputs).\n    You could use such queries to read data from Neo4j to enhance your RAG pipelines. For example a\n    prompt to LLM can produce Cypher query based on given context and then `Neo4jQueryReader` can be used to run the\n    query and extract results. [OutputAdapter](https://docs.haystack.deepset.ai/docs/outputadapter) component might\n    become handy in such scenarios - it can be used as a connection from the `Neo4jQueryReader` to convert (transform)\n    results accordingly.\n\n    Note:\n        Please consider [data types mappings](https://neo4j.com/docs/api/python-driver/current/api.html#data-types) in \\\n        Cypher query when working with query parameters. Neo4j Python Driver handles type conversions/mappings.\n        Specifically you can figure out in the documentation of the driver how to work with temporal types.\n\n    ```py title=\"Example: Find a Document node with Neo4jQueryReader and extract data\"\n    from neo4j_haystack.client.neo4j_client import Neo4jClientConfig\n    from neo4j_haystack.components.neo4j_query_reader import Neo4jQueryReader\n\n    client_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\n\n    reader = Neo4jQueryReader(client_config=client_config, runtime_parameters=[\"year\"])\n\n    # Get all documents with \"year\"=2020 and return \"name\" and \"embedding\" attributes for each found record\n    result = reader.run(\n        query=(\"MATCH (doc:`Document`) WHERE doc.year=$year RETURN doc.name as name, doc.embedding as embedding\"),\n        year=2020,\n    )\n    ```\n\n    Output:\n        `&gt;&gt;&gt; {'records': [{'name': 'name_0', 'embedding': [...]}, {'name': 'name_1', 'embedding': [...]}, \\\n        {'name': 'name_2', 'embedding': [...]}], 'first_record': {'name': 'name_0', 'embedding': [...]}}`\n\n    The above result contains the following output:\n\n    - `records` - A list of dictionaries, will have all the records returned by Cypher query. You can control record\n        outputs as per your needs. For example an aggregation function could be used to return a single result.\n        In such case there will be one record in the `records` list.\n    - `first_record` - In case the `records` contains just  one item, `first_record` will have the first record\n        from the list (put simply, first_record=records[0]). It was introduced as a syntax convenience.\n\n    If your Cypher query produces an error (e.g. invalid syntax) you could use that in `Loop-Based Auto-Correction`\n    pipelines to ask LLM to auto correct the query based on the error message, afterwards run the query again.\n\n    ```py title=\"Example: Output error with Neo4jQueryReader\"\n    from neo4j_haystack.client.neo4j_client import Neo4jClientConfig\n    from neo4j_haystack.components.neo4j_query_reader import Neo4jQueryReader\n\n    client_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\n\n    reader = Neo4jQueryReader(client_config=client_config, raise_on_failure=False)\n\n    # Intentionally introduce error in Cypher query (see \"RETURN_\")\n    result = reader.run(\n        query=(\"MATCH (doc:`Document` {name: $name}) RETURN_ doc.name as name, doc.year as year\"),\n        parameters={\"name\": \"name_1\"},\n    )\n    ```\n\n    Output:\n        `&gt;&gt;&gt; {'error_message': 'Invalid input \\'RETURN_\\'...', 'error': &lt;Exception&gt;}`\n\n    The `error_message` output can be used in your pipeline to deal with Cypher query error (e.g. auto correction)\n\n    When configuring [Query parameters](https://neo4j.com/docs/python-manual/current/query-simple/#query-parameters) \\\n    for `Neo4jQueryReader` component, consider the following:\n\n    - Parameters can be provided at the component creation time, see `parameters`\n    - In RAG pipeline runtime parameters could be connected from other components.\n      Make sure during creation time to specify which `runtime_parameters` are expected.\n\n    Important:\n        At the moment parameters support simple data types, dictionaries and python dataclasses (which can be converted\n        to `dict`). For example `haystack.ChatMessage` instance is a valid query parameter input. If you supply custom\n        classes as query parameters, e.g. \\\n        `Neo4jQueryReader(client_config=client_config).run(parameters={\"obj\": &lt;instance of custom class&gt;})` it will\n        result in error. In such rare cases `query_parameters_marshaller` attribute can be used to provide a\n        custom marshaller implementation for the type being used as query parameter value.\n    \"\"\"\n\n    def __init__(\n        self,\n        client_config: Neo4jClientConfig,\n        query: Optional[str] = None,\n        runtime_parameters: Optional[List[str]] = None,\n        verify_connectivity: Optional[bool] = False,\n        raise_on_failure: bool = False,\n        query_parameters_marshaller: Optional[QueryParametersMarshaller] = None,\n    ):\n        \"\"\"\n        Creates a Neo4jDocumentReader component.\n\n        Args:\n            client_config: Neo4j client configuration to connect to database (e.g. credentials and connection settings).\n            query: Optional Cypher query if known at component creation time. If `None` should be provided as component\n                input.\n            runtime_parameters: list of input parameters/slots for connecting components in a pipeline.\n            verify_connectivity: If `True` will verify connectivity with Neo4j database configured by `client_config`.\n            raise_on_failure: If `True` raises an exception if it fails to execute given Cypher query.\n            query_parameters_marshaller: Marshaller responsible for converting query parameters which can be used in\n                Cypher query, e.g. python dataclasses to be converted to dictionary. `Neo4jQueryParametersMarshaller`\n                is the default marshaller implementation.\n        \"\"\"\n        self._client_config = client_config\n        self._query = query\n        self._runtime_parameters = runtime_parameters or []\n        self._verify_connectivity = verify_connectivity\n        self._raise_on_failure = raise_on_failure\n\n        self._neo4j_client = Neo4jClient(client_config)\n        self._query_parameters_marshaller = query_parameters_marshaller or Neo4jQueryParametersMarshaller()\n\n        # setup inputs\n        kwargs_input_slots = dict.fromkeys(self._runtime_parameters, Optional[Any])\n        component.set_input_types(self, **kwargs_input_slots)\n\n        # setup outputs\n        component.set_output_types(\n            self, records=List[Dict[str, Any]], expanded_record=Optional[Dict[str, Any]], error=Optional[str]\n        )\n\n        if verify_connectivity:\n            self._neo4j_client.verify_connectivity()\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n        \"\"\"\n        data = default_to_dict(\n            self,\n            query=self._query,\n            runtime_parameters=self._runtime_parameters,\n            verify_connectivity=self._verify_connectivity,\n            raise_on_failure=self._raise_on_failure,\n        )\n\n        data[\"init_parameters\"][\"client_config\"] = self._client_config.to_dict()\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jQueryReader\":\n        \"\"\"\n        Deserialize this component from a dictionary.\n        \"\"\"\n        client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n        data[\"init_parameters\"][\"client_config\"] = client_config\n        return default_from_dict(cls, data)\n\n    def run(self, query: Optional[str] = None, parameters: Optional[Dict[str, Any]] = None, **kwargs) -&gt; QueryResult:\n        \"\"\"\n        Runs the arbitrary Cypher `query` with `parameters` to read data from Neo4j.\n\n        Args:\n            query: Cypher query to run.\n            parameters: Cypher query parameters which can be used as placeholders in the `query`.\n            kwargs: Arbitrary parameters supplied in a pipeline execution from other component's output slots, e.g.\n                `pipeline.connect(\"year_provider.year_start\", \"reader.year_start\")`, where `year_start` will be part\n                of `kwargs`.\n\n        Returns:\n            Output: Records returned from Cypher query in case request was successful or error message if there was an\n                error during Cypher query execution (`raise_on_failure` should be `False`).\n\n                ```py title=\"Example: Output with records\"\n                {'records': [{...}, {...}], 'first_record': {...}}\n                ```\n\n                where:\n\n                - `records` - List of records returned (e.g. using `RETURN` statement) by Cypher query\n                - `first_record` - First record from the `records` list if any\n\n                ```py title=\"Example: Output with error\"\n                {'error_message': 'Invalid Cypher syntax...', 'error': &lt;Exception&gt;}\n                ```\n\n                where:\n\n                - `error_message` - Error message returned by Neo4j in case Cypher query is invalid\n                - `error` - Original Exception which was triggered by Neo4j (containing the `error_message`)\n        \"\"\"\n        query = query or self._query\n        if query is None:\n            raise ValueError(\n                \"`query` is mandatory input and should be provided either in component's constructor, pipeline input or\"\n                \"connection\"\n            )\n        kwargs = kwargs or {}\n        parameters = parameters or {}\n        parameters_combined = {**kwargs, **parameters}\n\n        try:\n            _, records = self._neo4j_client.execute_read(\n                query,\n                parameters=self._serialize_parameters(parameters_combined),\n            )\n\n            return {\"records\": records, \"first_record\": records[0] if len(records) &gt; 0 else None}\n        except Exception as ex:\n            if self._raise_on_failure:\n                logger.error(\"Couldn't execute Neo4j read query %s\", ex)\n                raise ex\n\n            return {\n                \"error\": ex,\n                \"error_message\": str(ex),\n            }\n\n    def _serialize_parameters(self, parameters: Any) -&gt; Any:\n        \"\"\"\n        Serializes `parameters` into a data structure which can be accepted by Neo4j Python Driver (and a Cypher query\n        respectively). See \\\n            [Neo4jQueryParametersMarshaller][neo4j_haystack.serialization.query_parameters_marshaller.Neo4jQueryParametersMarshaller]\n            for more details.\n        \"\"\"\n        return self._query_parameters_marshaller.marshal(parameters)\n</code></pre>"},{"location":"reference/neo4j_query_reader/#neo4j_haystack.components.neo4j_query_reader.Neo4jQueryReader.__init__","title":"__init__","text":"<pre><code>__init__(\n    client_config: Neo4jClientConfig,\n    query: Optional[str] = None,\n    runtime_parameters: Optional[List[str]] = None,\n    verify_connectivity: Optional[bool] = False,\n    raise_on_failure: bool = False,\n    query_parameters_marshaller: Optional[QueryParametersMarshaller] = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>client_config</code>               (<code>Neo4jClientConfig</code>)           \u2013            <p>Neo4j client configuration to connect to database (e.g. credentials and connection settings).</p> </li> <li> <code>query</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Optional Cypher query if known at component creation time. If <code>None</code> should be provided as component input.</p> </li> <li> <code>runtime_parameters</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>list of input parameters/slots for connecting components in a pipeline.</p> </li> <li> <code>verify_connectivity</code>               (<code>Optional[bool]</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> will verify connectivity with Neo4j database configured by <code>client_config</code>.</p> </li> <li> <code>raise_on_failure</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> raises an exception if it fails to execute given Cypher query.</p> </li> <li> <code>query_parameters_marshaller</code>               (<code>Optional[QueryParametersMarshaller]</code>, default:                   <code>None</code> )           \u2013            <p>Marshaller responsible for converting query parameters which can be used in Cypher query, e.g. python dataclasses to be converted to dictionary. <code>Neo4jQueryParametersMarshaller</code> is the default marshaller implementation.</p> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_query_reader.py</code> <pre><code>def __init__(\n    self,\n    client_config: Neo4jClientConfig,\n    query: Optional[str] = None,\n    runtime_parameters: Optional[List[str]] = None,\n    verify_connectivity: Optional[bool] = False,\n    raise_on_failure: bool = False,\n    query_parameters_marshaller: Optional[QueryParametersMarshaller] = None,\n):\n    \"\"\"\n    Creates a Neo4jDocumentReader component.\n\n    Args:\n        client_config: Neo4j client configuration to connect to database (e.g. credentials and connection settings).\n        query: Optional Cypher query if known at component creation time. If `None` should be provided as component\n            input.\n        runtime_parameters: list of input parameters/slots for connecting components in a pipeline.\n        verify_connectivity: If `True` will verify connectivity with Neo4j database configured by `client_config`.\n        raise_on_failure: If `True` raises an exception if it fails to execute given Cypher query.\n        query_parameters_marshaller: Marshaller responsible for converting query parameters which can be used in\n            Cypher query, e.g. python dataclasses to be converted to dictionary. `Neo4jQueryParametersMarshaller`\n            is the default marshaller implementation.\n    \"\"\"\n    self._client_config = client_config\n    self._query = query\n    self._runtime_parameters = runtime_parameters or []\n    self._verify_connectivity = verify_connectivity\n    self._raise_on_failure = raise_on_failure\n\n    self._neo4j_client = Neo4jClient(client_config)\n    self._query_parameters_marshaller = query_parameters_marshaller or Neo4jQueryParametersMarshaller()\n\n    # setup inputs\n    kwargs_input_slots = dict.fromkeys(self._runtime_parameters, Optional[Any])\n    component.set_input_types(self, **kwargs_input_slots)\n\n    # setup outputs\n    component.set_output_types(\n        self, records=List[Dict[str, Any]], expanded_record=Optional[Dict[str, Any]], error=Optional[str]\n    )\n\n    if verify_connectivity:\n        self._neo4j_client.verify_connectivity()\n</code></pre>"},{"location":"reference/neo4j_query_reader/#neo4j_haystack.components.neo4j_query_reader.Neo4jQueryReader.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize this component to a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_reader.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serialize this component to a dictionary.\n    \"\"\"\n    data = default_to_dict(\n        self,\n        query=self._query,\n        runtime_parameters=self._runtime_parameters,\n        verify_connectivity=self._verify_connectivity,\n        raise_on_failure=self._raise_on_failure,\n    )\n\n    data[\"init_parameters\"][\"client_config\"] = self._client_config.to_dict()\n\n    return data\n</code></pre>"},{"location":"reference/neo4j_query_reader/#neo4j_haystack.components.neo4j_query_reader.Neo4jQueryReader.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Neo4jQueryReader\n</code></pre> <p>Deserialize this component from a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_reader.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jQueryReader\":\n    \"\"\"\n    Deserialize this component from a dictionary.\n    \"\"\"\n    client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n    data[\"init_parameters\"][\"client_config\"] = client_config\n    return default_from_dict(cls, data)\n</code></pre>"},{"location":"reference/neo4j_query_reader/#neo4j_haystack.components.neo4j_query_reader.Neo4jQueryReader.run","title":"run","text":"<pre><code>run(\n    query: Optional[str] = None,\n    parameters: Optional[Dict[str, Any]] = None,\n    **kwargs\n) -&gt; QueryResult\n</code></pre> <p>Runs the arbitrary Cypher <code>query</code> with <code>parameters</code> to read data from Neo4j.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Cypher query to run.</p> </li> <li> <code>parameters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Cypher query parameters which can be used as placeholders in the <code>query</code>.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Arbitrary parameters supplied in a pipeline execution from other component's output slots, e.g. <code>pipeline.connect(\"year_provider.year_start\", \"reader.year_start\")</code>, where <code>year_start</code> will be part of <code>kwargs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Output</code> (              <code>QueryResult</code> )          \u2013            <p>Records returned from Cypher query in case request was successful or error message if there was an error during Cypher query execution (<code>raise_on_failure</code> should be <code>False</code>).</p> Example: Output with records<pre><code>{'records': [{...}, {...}], 'first_record': {...}}\n</code></pre> <p>where:</p> <ul> <li><code>records</code> - List of records returned (e.g. using <code>RETURN</code> statement) by Cypher query</li> <li><code>first_record</code> - First record from the <code>records</code> list if any</li> </ul> Example: Output with error<pre><code>{'error_message': 'Invalid Cypher syntax...', 'error': &lt;Exception&gt;}\n</code></pre> <p>where:</p> <ul> <li><code>error_message</code> - Error message returned by Neo4j in case Cypher query is invalid</li> <li><code>error</code> - Original Exception which was triggered by Neo4j (containing the <code>error_message</code>)</li> </ul> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_query_reader.py</code> <pre><code>def run(self, query: Optional[str] = None, parameters: Optional[Dict[str, Any]] = None, **kwargs) -&gt; QueryResult:\n    \"\"\"\n    Runs the arbitrary Cypher `query` with `parameters` to read data from Neo4j.\n\n    Args:\n        query: Cypher query to run.\n        parameters: Cypher query parameters which can be used as placeholders in the `query`.\n        kwargs: Arbitrary parameters supplied in a pipeline execution from other component's output slots, e.g.\n            `pipeline.connect(\"year_provider.year_start\", \"reader.year_start\")`, where `year_start` will be part\n            of `kwargs`.\n\n    Returns:\n        Output: Records returned from Cypher query in case request was successful or error message if there was an\n            error during Cypher query execution (`raise_on_failure` should be `False`).\n\n            ```py title=\"Example: Output with records\"\n            {'records': [{...}, {...}], 'first_record': {...}}\n            ```\n\n            where:\n\n            - `records` - List of records returned (e.g. using `RETURN` statement) by Cypher query\n            - `first_record` - First record from the `records` list if any\n\n            ```py title=\"Example: Output with error\"\n            {'error_message': 'Invalid Cypher syntax...', 'error': &lt;Exception&gt;}\n            ```\n\n            where:\n\n            - `error_message` - Error message returned by Neo4j in case Cypher query is invalid\n            - `error` - Original Exception which was triggered by Neo4j (containing the `error_message`)\n    \"\"\"\n    query = query or self._query\n    if query is None:\n        raise ValueError(\n            \"`query` is mandatory input and should be provided either in component's constructor, pipeline input or\"\n            \"connection\"\n        )\n    kwargs = kwargs or {}\n    parameters = parameters or {}\n    parameters_combined = {**kwargs, **parameters}\n\n    try:\n        _, records = self._neo4j_client.execute_read(\n            query,\n            parameters=self._serialize_parameters(parameters_combined),\n        )\n\n        return {\"records\": records, \"first_record\": records[0] if len(records) &gt; 0 else None}\n    except Exception as ex:\n        if self._raise_on_failure:\n            logger.error(\"Couldn't execute Neo4j read query %s\", ex)\n            raise ex\n\n        return {\n            \"error\": ex,\n            \"error_message\": str(ex),\n        }\n</code></pre>"},{"location":"reference/neo4j_query_reader/#neo4j_haystack.components.neo4j_query_reader.Neo4jQueryReader._serialize_parameters","title":"_serialize_parameters","text":"<pre><code>_serialize_parameters(parameters: Any) -&gt; Any\n</code></pre> <p>Serializes <code>parameters</code> into a data structure which can be accepted by Neo4j Python Driver (and a Cypher query respectively). See             Neo4jQueryParametersMarshaller     for more details.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_reader.py</code> <pre><code>def _serialize_parameters(self, parameters: Any) -&gt; Any:\n    \"\"\"\n    Serializes `parameters` into a data structure which can be accepted by Neo4j Python Driver (and a Cypher query\n    respectively). See \\\n        [Neo4jQueryParametersMarshaller][neo4j_haystack.serialization.query_parameters_marshaller.Neo4jQueryParametersMarshaller]\n        for more details.\n    \"\"\"\n    return self._query_parameters_marshaller.marshal(parameters)\n</code></pre>"},{"location":"reference/neo4j_query_writer/","title":"Neo4jQueryWriter","text":""},{"location":"reference/neo4j_query_writer/#neo4j_haystack.components.neo4j_query_writer.Neo4jQueryWriter","title":"Neo4jQueryWriter","text":"<p>A component for writing arbitrary data to Neo4j database using plain Cypher query.</p> <p>This component gives flexible way to write data to Neo4j by running arbitrary Cypher query with parameters. Query parameters can be supplied in a pipeline from other components (or pipeline data). You could use such queries to write Documents with additional graph nodes for a more complex RAG scenarios. The difference between DocumentWriter and <code>Neo4jQueryWriter</code> is that the latter can write any data to Neo4j - not just Documents.</p> Note <p>Please consider data types mappings in         Cypher query when working with query parameters. Neo4j Python Driver handles type conversions/mappings. Specifically you can figure out in the documentation of the driver how to work with temporal types.</p> Example: Creating a Document node with Neo4jQueryWriter<pre><code>from neo4j_haystack.client.neo4j_client import Neo4jClientConfig\nfrom neo4j_haystack.components.neo4j_query_writer import Neo4jQueryWriter\n\nclient_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\n\ndoc_meta = {\"year\": 2020, \"source_url\": \"https://www.deepset.ai/blog\"}\n\nwriter = Neo4jQueryWriter(client_config=client_config, verify_connectivity=True, runtime_parameters=[\"doc_meta\"])\n\nresult = writer.run(\n    query=(\n        \"MERGE (doc:`Document` {id: $doc_id})\"\n        \"SET doc += {id: $doc_id, content: $content, year: $doc_meta.year, source_url: $doc_meta.source_url}\"\n    ),\n    parameters={\"doc_id\": \"123\", \"content\": \"beautiful graph\"},\n    doc_meta=doc_meta\n)\n</code></pre> Output <p><code>&gt;&gt;&gt; {'query_status': 'success'}</code></p> <p>In case query execution results in error and <code>raise_on_failure=False</code> the output will contain the error, e.g.:</p> Output <p><code>&gt;&gt;&gt; {'query_status': 'error', 'error_message': 'Invalid cypher syntax', error: &lt;Exception&gt;}</code></p> <p>In RAG pipeline runtime parameters could be connected from other components. Make sure during component creation to specify which <code>runtime_parameters</code> are expected to become as input slots for the component. In the example above <code>doc_meta</code> can be connected , e.g. <code>pipeline.connect(\"other_component.output\", \"writer.doc_meta\")</code>.</p> Important <p>At the moment parameters support simple data types, dictionaries (see <code>doc_meta</code> in the example above) and python dataclasses (which can be converted to <code>dict</code>). For example <code>haystack.Document</code> or <code>haystack.ChatMessage</code> instances are valid query parameter inputs. However, currently Neo4j Python Driver does not convert dataclasses to dictionaries automatically for us. By default             Neo4jQueryParametersMarshaller is used to handle such conversions. You can change this logic by creating your own marshaller (see the <code>query_parameters_marshaller</code> attribute)</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_writer.py</code> <pre><code>@component\nclass Neo4jQueryWriter:\n    \"\"\"\n    A component for writing arbitrary data to Neo4j database using plain Cypher query.\n\n    This component gives flexible way to write data to Neo4j by running arbitrary Cypher query with\n    parameters. Query parameters can be supplied in a pipeline from other components (or pipeline data).\n    You could use such queries to write Documents with additional graph nodes for a more complex RAG scenarios.\n    The difference between [DocumentWriter](https://docs.haystack.deepset.ai/docs/documentwriter) and `Neo4jQueryWriter`\n    is that the latter can write any data to Neo4j - not just Documents.\n\n    Note:\n        Please consider [data types mappings](https://neo4j.com/docs/api/python-driver/current/api.html#data-types) in \\\n        Cypher query when working with query parameters. Neo4j Python Driver handles type conversions/mappings.\n        Specifically you can figure out in the documentation of the driver how to work with temporal types.\n\n    ```py title=\"Example: Creating a Document node with Neo4jQueryWriter\"\n    from neo4j_haystack.client.neo4j_client import Neo4jClientConfig\n    from neo4j_haystack.components.neo4j_query_writer import Neo4jQueryWriter\n\n    client_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\n\n    doc_meta = {\"year\": 2020, \"source_url\": \"https://www.deepset.ai/blog\"}\n\n    writer = Neo4jQueryWriter(client_config=client_config, verify_connectivity=True, runtime_parameters=[\"doc_meta\"])\n\n    result = writer.run(\n        query=(\n            \"MERGE (doc:`Document` {id: $doc_id})\"\n            \"SET doc += {id: $doc_id, content: $content, year: $doc_meta.year, source_url: $doc_meta.source_url}\"\n        ),\n        parameters={\"doc_id\": \"123\", \"content\": \"beautiful graph\"},\n        doc_meta=doc_meta\n    )\n    ```\n\n    Output:\n        `&gt;&gt;&gt; {'query_status': 'success'}`\n\n    In case query execution results in error and `raise_on_failure=False` the output will contain the error, e.g.:\n\n    Output:\n        `&gt;&gt;&gt; {'query_status': 'error', 'error_message': 'Invalid cypher syntax', error: &lt;Exception&gt;}`\n\n    In RAG pipeline runtime parameters could be connected from other components. Make sure during component creation to\n    specify which `runtime_parameters` are expected to become as input slots for the component. In the example above\n    `doc_meta` can be connected , e.g. `pipeline.connect(\"other_component.output\", \"writer.doc_meta\")`.\n\n    Important:\n        At the moment parameters support simple data types, dictionaries (see `doc_meta` in the example above) and\n        python dataclasses (which can be converted to `dict`). For example `haystack.Document` or `haystack.ChatMessage`\n        instances are valid query parameter inputs. However, currently Neo4j Python Driver does not convert dataclasses\n        to dictionaries automatically for us. By default \\\n            [Neo4jQueryParametersMarshaller][neo4j_haystack.serialization.query_parameters_marshaller.Neo4jQueryParametersMarshaller]\n        is used to handle such conversions. You can change this logic by creating your own marshaller (see the\n        `query_parameters_marshaller` attribute)\n    \"\"\"\n\n    def __init__(\n        self,\n        client_config: Neo4jClientConfig,\n        query: Optional[str] = None,\n        runtime_parameters: Optional[List[str]] = None,\n        verify_connectivity: Optional[bool] = False,\n        raise_on_failure: bool = True,\n        query_parameters_marshaller: Optional[QueryParametersMarshaller] = None,\n    ):\n        \"\"\"\n        Create a Neo4jDocumentWriter component.\n\n        Args:\n            client_config: Neo4j client configuration to connect to database (e.g. credentials and connection settings).\n            query: Optional Cypher query for document retrieval. If `None` should be provided as component input.\n            runtime_parameters: list of input parameters/slots for connecting components in a pipeline.\n            verify_connectivity: If `True` will verify connectivity with Neo4j database configured by `client_config`.\n            raise_on_failure: If `True` raises an exception if it fails to execute given Cypher query.\n            query_parameters_marshaller: Marshaller responsible for converting query parameters which can be used in\n                Cypher query, e.g. python dataclasses to be converted to dictionary. `Neo4jQueryParametersMarshaller`\n                is the default marshaller implementation.\n        \"\"\"\n        self._client_config = client_config\n        self._query = query\n        self._runtime_parameters = runtime_parameters or []\n        self._verify_connectivity = verify_connectivity\n        self._raise_on_failure = raise_on_failure\n\n        self._neo4j_client = Neo4jClient(client_config)\n        self._query_parameters_marshaller = query_parameters_marshaller or Neo4jQueryParametersMarshaller()\n\n        # setup inputs\n        kwargs_input_slots = dict.fromkeys(self._runtime_parameters, Optional[Any])\n        component.set_input_types(self, **kwargs_input_slots)\n\n        # setup outputs\n        component.set_output_types(self, query_status=str, error=Optional[Exception], error_message=Optional[str])\n\n        if verify_connectivity:\n            self._neo4j_client.verify_connectivity()\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n        \"\"\"\n        data = default_to_dict(\n            self,\n            query=self._query,\n            runtime_parameters=self._runtime_parameters,\n            verify_connectivity=self._verify_connectivity,\n            raise_on_failure=self._raise_on_failure,\n        )\n\n        data[\"init_parameters\"][\"client_config\"] = self._client_config.to_dict()\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jQueryWriter\":\n        \"\"\"\n        Deserialize this component from a dictionary.\n        \"\"\"\n        client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n        data[\"init_parameters\"][\"client_config\"] = client_config\n        return default_from_dict(cls, data)\n\n    def run(self, query: Optional[str] = None, parameters: Optional[Dict[str, Any]] = None, **kwargs) -&gt; QueryResult:\n        \"\"\"\n        Runs the arbitrary Cypher `query` with `parameters` to write data to Neo4j.\n\n        Once data is written to Neo4j the component returns back some execution stats.\n\n        Args:\n            query: Cypher query to run.\n            parameters: Cypher query parameters which can be used as placeholders in the `query`.\n            kwargs: Runtime parameters from connected components in a pipeline, e.g.\n                `pipeline.connect(\"year_provider.year_start\", \"writer.year_start\")`, where `year_start` will be part\n                of `kwargs`.\n\n        Returns:\n            Output: Query execution stats.\n\n                Example: `:::py {'query_status': 'success'}`\n        \"\"\"\n        query = query or self._query\n        if query is None:\n            raise ValueError(\n                \"`query` is mandatory input and should be provided either in component's constructor, pipeline input or\"\n                \"connection\"\n            )\n        kwargs = kwargs or {}\n        parameters = parameters or {}\n        parameters_combined = {**kwargs, **parameters}\n\n        try:\n            self._neo4j_client.execute_write(\n                query,\n                parameters=self._serialize_parameters(parameters_combined),\n            )\n\n            return {\"query_status\": \"success\"}\n        except Exception as ex:\n            if self._raise_on_failure:\n                logger.error(\"Couldn't execute Neo4j write query %s\", ex)\n                raise ex\n\n            return {\"query_status\": \"error\", \"error_message\": str(ex), \"error\": ex}\n\n    def _serialize_parameters(self, parameters: Any) -&gt; Any:\n        \"\"\"\n        Serializes `parameters` into a data structure which can be accepted by Neo4j Python Driver (and a Cypher query\n        respectively). See \\\n            [Neo4jQueryParametersMarshaller][neo4j_haystack.serialization.query_parameters_marshaller.Neo4jQueryParametersMarshaller]\n            for more details.\n        \"\"\"\n        return self._query_parameters_marshaller.marshal(parameters)\n</code></pre>"},{"location":"reference/neo4j_query_writer/#neo4j_haystack.components.neo4j_query_writer.Neo4jQueryWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    client_config: Neo4jClientConfig,\n    query: Optional[str] = None,\n    runtime_parameters: Optional[List[str]] = None,\n    verify_connectivity: Optional[bool] = False,\n    raise_on_failure: bool = True,\n    query_parameters_marshaller: Optional[QueryParametersMarshaller] = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>client_config</code>               (<code>Neo4jClientConfig</code>)           \u2013            <p>Neo4j client configuration to connect to database (e.g. credentials and connection settings).</p> </li> <li> <code>query</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Optional Cypher query for document retrieval. If <code>None</code> should be provided as component input.</p> </li> <li> <code>runtime_parameters</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>list of input parameters/slots for connecting components in a pipeline.</p> </li> <li> <code>verify_connectivity</code>               (<code>Optional[bool]</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> will verify connectivity with Neo4j database configured by <code>client_config</code>.</p> </li> <li> <code>raise_on_failure</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code> raises an exception if it fails to execute given Cypher query.</p> </li> <li> <code>query_parameters_marshaller</code>               (<code>Optional[QueryParametersMarshaller]</code>, default:                   <code>None</code> )           \u2013            <p>Marshaller responsible for converting query parameters which can be used in Cypher query, e.g. python dataclasses to be converted to dictionary. <code>Neo4jQueryParametersMarshaller</code> is the default marshaller implementation.</p> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_query_writer.py</code> <pre><code>def __init__(\n    self,\n    client_config: Neo4jClientConfig,\n    query: Optional[str] = None,\n    runtime_parameters: Optional[List[str]] = None,\n    verify_connectivity: Optional[bool] = False,\n    raise_on_failure: bool = True,\n    query_parameters_marshaller: Optional[QueryParametersMarshaller] = None,\n):\n    \"\"\"\n    Create a Neo4jDocumentWriter component.\n\n    Args:\n        client_config: Neo4j client configuration to connect to database (e.g. credentials and connection settings).\n        query: Optional Cypher query for document retrieval. If `None` should be provided as component input.\n        runtime_parameters: list of input parameters/slots for connecting components in a pipeline.\n        verify_connectivity: If `True` will verify connectivity with Neo4j database configured by `client_config`.\n        raise_on_failure: If `True` raises an exception if it fails to execute given Cypher query.\n        query_parameters_marshaller: Marshaller responsible for converting query parameters which can be used in\n            Cypher query, e.g. python dataclasses to be converted to dictionary. `Neo4jQueryParametersMarshaller`\n            is the default marshaller implementation.\n    \"\"\"\n    self._client_config = client_config\n    self._query = query\n    self._runtime_parameters = runtime_parameters or []\n    self._verify_connectivity = verify_connectivity\n    self._raise_on_failure = raise_on_failure\n\n    self._neo4j_client = Neo4jClient(client_config)\n    self._query_parameters_marshaller = query_parameters_marshaller or Neo4jQueryParametersMarshaller()\n\n    # setup inputs\n    kwargs_input_slots = dict.fromkeys(self._runtime_parameters, Optional[Any])\n    component.set_input_types(self, **kwargs_input_slots)\n\n    # setup outputs\n    component.set_output_types(self, query_status=str, error=Optional[Exception], error_message=Optional[str])\n\n    if verify_connectivity:\n        self._neo4j_client.verify_connectivity()\n</code></pre>"},{"location":"reference/neo4j_query_writer/#neo4j_haystack.components.neo4j_query_writer.Neo4jQueryWriter.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize this component to a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_writer.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serialize this component to a dictionary.\n    \"\"\"\n    data = default_to_dict(\n        self,\n        query=self._query,\n        runtime_parameters=self._runtime_parameters,\n        verify_connectivity=self._verify_connectivity,\n        raise_on_failure=self._raise_on_failure,\n    )\n\n    data[\"init_parameters\"][\"client_config\"] = self._client_config.to_dict()\n\n    return data\n</code></pre>"},{"location":"reference/neo4j_query_writer/#neo4j_haystack.components.neo4j_query_writer.Neo4jQueryWriter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Neo4jQueryWriter\n</code></pre> <p>Deserialize this component from a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_writer.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jQueryWriter\":\n    \"\"\"\n    Deserialize this component from a dictionary.\n    \"\"\"\n    client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n    data[\"init_parameters\"][\"client_config\"] = client_config\n    return default_from_dict(cls, data)\n</code></pre>"},{"location":"reference/neo4j_query_writer/#neo4j_haystack.components.neo4j_query_writer.Neo4jQueryWriter.run","title":"run","text":"<pre><code>run(\n    query: Optional[str] = None,\n    parameters: Optional[Dict[str, Any]] = None,\n    **kwargs\n) -&gt; QueryResult\n</code></pre> <p>Runs the arbitrary Cypher <code>query</code> with <code>parameters</code> to write data to Neo4j.</p> <p>Once data is written to Neo4j the component returns back some execution stats.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Cypher query to run.</p> </li> <li> <code>parameters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Cypher query parameters which can be used as placeholders in the <code>query</code>.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Runtime parameters from connected components in a pipeline, e.g. <code>pipeline.connect(\"year_provider.year_start\", \"writer.year_start\")</code>, where <code>year_start</code> will be part of <code>kwargs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Output</code> (              <code>QueryResult</code> )          \u2013            <p>Query execution stats.</p> <p>Example: <code>{'query_status': 'success'}</code></p> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_query_writer.py</code> <pre><code>def run(self, query: Optional[str] = None, parameters: Optional[Dict[str, Any]] = None, **kwargs) -&gt; QueryResult:\n    \"\"\"\n    Runs the arbitrary Cypher `query` with `parameters` to write data to Neo4j.\n\n    Once data is written to Neo4j the component returns back some execution stats.\n\n    Args:\n        query: Cypher query to run.\n        parameters: Cypher query parameters which can be used as placeholders in the `query`.\n        kwargs: Runtime parameters from connected components in a pipeline, e.g.\n            `pipeline.connect(\"year_provider.year_start\", \"writer.year_start\")`, where `year_start` will be part\n            of `kwargs`.\n\n    Returns:\n        Output: Query execution stats.\n\n            Example: `:::py {'query_status': 'success'}`\n    \"\"\"\n    query = query or self._query\n    if query is None:\n        raise ValueError(\n            \"`query` is mandatory input and should be provided either in component's constructor, pipeline input or\"\n            \"connection\"\n        )\n    kwargs = kwargs or {}\n    parameters = parameters or {}\n    parameters_combined = {**kwargs, **parameters}\n\n    try:\n        self._neo4j_client.execute_write(\n            query,\n            parameters=self._serialize_parameters(parameters_combined),\n        )\n\n        return {\"query_status\": \"success\"}\n    except Exception as ex:\n        if self._raise_on_failure:\n            logger.error(\"Couldn't execute Neo4j write query %s\", ex)\n            raise ex\n\n        return {\"query_status\": \"error\", \"error_message\": str(ex), \"error\": ex}\n</code></pre>"},{"location":"reference/neo4j_query_writer/#neo4j_haystack.components.neo4j_query_writer.Neo4jQueryWriter._serialize_parameters","title":"_serialize_parameters","text":"<pre><code>_serialize_parameters(parameters: Any) -&gt; Any\n</code></pre> <p>Serializes <code>parameters</code> into a data structure which can be accepted by Neo4j Python Driver (and a Cypher query respectively). See             Neo4jQueryParametersMarshaller     for more details.</p> Source code in <code>src/neo4j_haystack/components/neo4j_query_writer.py</code> <pre><code>def _serialize_parameters(self, parameters: Any) -&gt; Any:\n    \"\"\"\n    Serializes `parameters` into a data structure which can be accepted by Neo4j Python Driver (and a Cypher query\n    respectively). See \\\n        [Neo4jQueryParametersMarshaller][neo4j_haystack.serialization.query_parameters_marshaller.Neo4jQueryParametersMarshaller]\n        for more details.\n    \"\"\"\n    return self._query_parameters_marshaller.marshal(parameters)\n</code></pre>"},{"location":"reference/neo4j_retriever/","title":"Neo4jRetriever","text":""},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jEmbeddingRetriever","title":"Neo4jEmbeddingRetriever","text":"<p>A component for retrieving documents from Neo4jDocumentStore.</p> Retrieving documents assuming documents have been previously indexed<pre><code>from haystack import Document, Pipeline\nfrom haystack.components.embedders import SentenceTransformersTextEmbedder\n\nfrom neo4j_haystack import Neo4jDocumentStore, Neo4jEmbeddingRetriever\n\nmodel_name = \"sentence-transformers/all-MiniLM-L6-v2\"\n\n# Document store with default credentials\ndocument_store = Neo4jDocumentStore(\n    url=\"bolt://localhost:7687\",\n    embedding_dim=384, # same as the embedding model\n)\n\npipeline = Pipeline()\npipeline.add_component(\"text_embedder\", SentenceTransformersTextEmbedder(model=model_name))\npipeline.add_component(\"retriever\", Neo4jEmbeddingRetriever(document_store=document_store))\npipeline.connect(\"text_embedder.embedding\", \"retriever.query_embedding\")\n\nresult = pipeline.run(\n    data={\n        \"text_embedder\": {\"text\": \"Query to be embedded\"},\n        \"retriever\": {\n            \"top_k\": 5,\n            \"filters\": {\"field\": \"release_date\", \"operator\": \"==\", \"value\": \"2018-12-09\"},\n        },\n    }\n)\n\n# Obtain retrieved documents from pipeline execution\ndocuments: List[Document] = result[\"retriever\"][\"documents\"]\n</code></pre> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>@component\nclass Neo4jEmbeddingRetriever:\n    \"\"\"\n    A component for retrieving documents from Neo4jDocumentStore.\n\n    ```py title=\"Retrieving documents assuming documents have been previously indexed\"\n    from haystack import Document, Pipeline\n    from haystack.components.embedders import SentenceTransformersTextEmbedder\n\n    from neo4j_haystack import Neo4jDocumentStore, Neo4jEmbeddingRetriever\n\n    model_name = \"sentence-transformers/all-MiniLM-L6-v2\"\n\n    # Document store with default credentials\n    document_store = Neo4jDocumentStore(\n        url=\"bolt://localhost:7687\",\n        embedding_dim=384, # same as the embedding model\n    )\n\n    pipeline = Pipeline()\n    pipeline.add_component(\"text_embedder\", SentenceTransformersTextEmbedder(model=model_name))\n    pipeline.add_component(\"retriever\", Neo4jEmbeddingRetriever(document_store=document_store))\n    pipeline.connect(\"text_embedder.embedding\", \"retriever.query_embedding\")\n\n    result = pipeline.run(\n        data={\n            \"text_embedder\": {\"text\": \"Query to be embedded\"},\n            \"retriever\": {\n                \"top_k\": 5,\n                \"filters\": {\"field\": \"release_date\", \"operator\": \"==\", \"value\": \"2018-12-09\"},\n            },\n        }\n    )\n\n    # Obtain retrieved documents from pipeline execution\n    documents: List[Document] = result[\"retriever\"][\"documents\"]\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        document_store: Neo4jDocumentStore,\n        filters: Optional[Dict[str, Any]] = None,\n        top_k: int = 10,\n        scale_score: bool = True,\n        return_embedding: bool = False,\n    ):\n        \"\"\"\n        Create a Neo4jEmbeddingRetriever component.\n\n        Args:\n            document_store: An instance of `Neo4jDocumentStore`.\n            filters: A dictionary with filters to narrow down the search space.\n            top_k: The maximum number of documents to retrieve.\n            scale_score: Whether to scale the scores of the retrieved documents or not.\n            return_embedding: Whether to return the embedding of the retrieved Documents.\n\n        Raises:\n            ValueError: If `document_store` is not an instance of `Neo4jDocumentStore`.\n        \"\"\"\n\n        if not isinstance(document_store, Neo4jDocumentStore):\n            msg = \"document_store must be an instance of Neo4jDocumentStore\"\n            raise ValueError(msg)\n\n        self._document_store = document_store\n\n        self._filters = filters\n        self._top_k = top_k\n        self._scale_score = scale_score\n        self._return_embedding = return_embedding\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n        \"\"\"\n        data = default_to_dict(\n            self,\n            document_store=self._document_store,\n            filters=self._filters,\n            top_k=self._top_k,\n            scale_score=self._scale_score,\n            return_embedding=self._return_embedding,\n        )\n        data[\"init_parameters\"][\"document_store\"] = self._document_store.to_dict()\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jEmbeddingRetriever\":\n        \"\"\"\n        Deserialize this component from a dictionary.\n        \"\"\"\n        document_store = Neo4jDocumentStore.from_dict(data[\"init_parameters\"][\"document_store\"])\n        data[\"init_parameters\"][\"document_store\"] = document_store\n        return default_from_dict(cls, data)\n\n    @component.output_types(documents=List[Document])\n    def run(\n        self,\n        query_embedding: List[float],\n        filters: Optional[Dict[str, Any]] = None,\n        top_k: Optional[int] = None,\n        scale_score: Optional[bool] = None,\n        return_embedding: Optional[bool] = None,\n    ):\n        \"\"\"\n        Run the Embedding Retriever on the given input data.\n\n        Args:\n            query_embedding: Embedding of the query.\n            filters: A dictionary with filters to narrow down the search space.\n            top_k: The maximum number of documents to return.\n            scale_score: Whether to scale the scores of the retrieved documents or not.\n            return_embedding: Whether to return the embedding of the retrieved Documents.\n\n        Returns:\n            The retrieved documents.\n        \"\"\"\n        docs = self._document_store.query_by_embedding(\n            query_embedding=query_embedding,\n            filters=filters or self._filters,\n            top_k=top_k or self._top_k,\n            scale_score=scale_score or self._scale_score,\n            return_embedding=return_embedding or self._return_embedding,\n        )\n\n        return {\"documents\": docs}\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jEmbeddingRetriever.__init__","title":"__init__","text":"<pre><code>__init__(\n    document_store: Neo4jDocumentStore,\n    filters: Optional[Dict[str, Any]] = None,\n    top_k: int = 10,\n    scale_score: bool = True,\n    return_embedding: bool = False,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>document_store</code>               (<code>Neo4jDocumentStore</code>)           \u2013            <p>An instance of <code>Neo4jDocumentStore</code>.</p> </li> <li> <code>filters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary with filters to narrow down the search space.</p> </li> <li> <code>top_k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of documents to retrieve.</p> </li> <li> <code>scale_score</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to scale the scores of the retrieved documents or not.</p> </li> <li> <code>return_embedding</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the embedding of the retrieved Documents.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>document_store</code> is not an instance of <code>Neo4jDocumentStore</code>.</p> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>def __init__(\n    self,\n    document_store: Neo4jDocumentStore,\n    filters: Optional[Dict[str, Any]] = None,\n    top_k: int = 10,\n    scale_score: bool = True,\n    return_embedding: bool = False,\n):\n    \"\"\"\n    Create a Neo4jEmbeddingRetriever component.\n\n    Args:\n        document_store: An instance of `Neo4jDocumentStore`.\n        filters: A dictionary with filters to narrow down the search space.\n        top_k: The maximum number of documents to retrieve.\n        scale_score: Whether to scale the scores of the retrieved documents or not.\n        return_embedding: Whether to return the embedding of the retrieved Documents.\n\n    Raises:\n        ValueError: If `document_store` is not an instance of `Neo4jDocumentStore`.\n    \"\"\"\n\n    if not isinstance(document_store, Neo4jDocumentStore):\n        msg = \"document_store must be an instance of Neo4jDocumentStore\"\n        raise ValueError(msg)\n\n    self._document_store = document_store\n\n    self._filters = filters\n    self._top_k = top_k\n    self._scale_score = scale_score\n    self._return_embedding = return_embedding\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jEmbeddingRetriever.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize this component to a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serialize this component to a dictionary.\n    \"\"\"\n    data = default_to_dict(\n        self,\n        document_store=self._document_store,\n        filters=self._filters,\n        top_k=self._top_k,\n        scale_score=self._scale_score,\n        return_embedding=self._return_embedding,\n    )\n    data[\"init_parameters\"][\"document_store\"] = self._document_store.to_dict()\n\n    return data\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jEmbeddingRetriever.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Neo4jEmbeddingRetriever\n</code></pre> <p>Deserialize this component from a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jEmbeddingRetriever\":\n    \"\"\"\n    Deserialize this component from a dictionary.\n    \"\"\"\n    document_store = Neo4jDocumentStore.from_dict(data[\"init_parameters\"][\"document_store\"])\n    data[\"init_parameters\"][\"document_store\"] = document_store\n    return default_from_dict(cls, data)\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jEmbeddingRetriever.run","title":"run","text":"<pre><code>run(\n    query_embedding: List[float],\n    filters: Optional[Dict[str, Any]] = None,\n    top_k: Optional[int] = None,\n    scale_score: Optional[bool] = None,\n    return_embedding: Optional[bool] = None,\n)\n</code></pre> <p>Run the Embedding Retriever on the given input data.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>Embedding of the query.</p> </li> <li> <code>filters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary with filters to narrow down the search space.</p> </li> <li> <code>top_k</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of documents to return.</p> </li> <li> <code>scale_score</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>Whether to scale the scores of the retrieved documents or not.</p> </li> <li> <code>return_embedding</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>Whether to return the embedding of the retrieved Documents.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The retrieved documents.</p> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>@component.output_types(documents=List[Document])\ndef run(\n    self,\n    query_embedding: List[float],\n    filters: Optional[Dict[str, Any]] = None,\n    top_k: Optional[int] = None,\n    scale_score: Optional[bool] = None,\n    return_embedding: Optional[bool] = None,\n):\n    \"\"\"\n    Run the Embedding Retriever on the given input data.\n\n    Args:\n        query_embedding: Embedding of the query.\n        filters: A dictionary with filters to narrow down the search space.\n        top_k: The maximum number of documents to return.\n        scale_score: Whether to scale the scores of the retrieved documents or not.\n        return_embedding: Whether to return the embedding of the retrieved Documents.\n\n    Returns:\n        The retrieved documents.\n    \"\"\"\n    docs = self._document_store.query_by_embedding(\n        query_embedding=query_embedding,\n        filters=filters or self._filters,\n        top_k=top_k or self._top_k,\n        scale_score=scale_score or self._scale_score,\n        return_embedding=return_embedding or self._return_embedding,\n    )\n\n    return {\"documents\": docs}\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jDynamicDocumentRetriever","title":"Neo4jDynamicDocumentRetriever","text":"<p>A component for retrieving Documents from Neo4j database using plain Cypher query.</p> <p>This component gives flexible way to retrieve data from Neo4j by running arbitrary Cypher query along with query parameters. Query parameters can be supplied in a pipeline from other components (or pipeline data).</p> <p>See the following documentation on how to compose Cypher queries with parameters:</p> <ul> <li>Overview of Cypher query syntax</li> <li>Cypher Query Parameters</li> </ul> <p>Above are resources which will help understand better Cypher query syntax and parameterization. Under the hood Neo4j Python Driver is used to query database and fetch results. You might be interested in the following documentation:</p> <ul> <li>Query the database</li> <li>Query parameters</li> <li>Data types and mapping to Cypher types</li> </ul> Note <p>Please consider data types mappings in Cypher query when working with parameters. Neo4j Python Driver handles type conversions/mappings. Specifically you can figure out in the documentation of the driver how to work with temporal types (e.g. <code>DateTime</code>).</p> <p>Query execution results will be mapped/converted to <code>haystack.Document</code> type. See more details in the RETURN clause documentation. There are two ways how Documents are being composed from query results.</p> <p>(1) Converting documents from nodes</p> Convert Neo4j `node` to `haystack.Document`<pre><code>client_config = Neo4jClientConfig(\n    \"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\"\n)\n\nretriever = Neo4jDynamicDocumentRetriever(\n    client_config=client_config, doc_node_name=\"doc\", verify_connectivity=True\n)\n\nresult = retriever.run(\n    query=\"MATCH (doc:Document) WHERE doc.year &gt; $year OR doc.year is NULL RETURN doc\",\n    parameters={\"year\": 2020}\n)\ndocuments: List[Document] = result[\"documents\"]\n</code></pre> <p>Please notice how <code>doc_node_name</code> attribute assumes <code>\"doc\"</code> node is going to be returned from the query. <code>Neo4jDynamicDocumentRetriever</code> will convert properties of the node (e.g. <code>id</code>, <code>content</code> etc) to <code>haystack.Document</code> type.</p> <p>(2) Converting documents from query output keys (e.g. column aliases)</p> <p>You might want to run a complex query which aggregates information from multiple sources (nodes) in Neo4j. In such case you can compose final Document from several dta points.</p> Convert Neo4j `node` to `haystack.Document`<pre><code># Configuration with default settings\nclient_config=Neo4jClientConfig()\n\nretriever = Neo4jDynamicDocumentRetriever(client_config=client_config, compose_doc_from_result=True)\n\nresult = retriever.run(\n    query=(\n        \"MATCH (doc:Document) \"\n        \"WHERE doc.year &gt; $year OR doc.year is NULL \"\n        \"RETURN doc.id as id, doc.content as content, doc.year as year\"\n    ),\n    parameters={\"year\": 2020},\n)\ndocuments: List[Document] = result[\"documents\"]\n</code></pre> <p>The above will produce Documents with <code>id</code>, <code>content</code> and <code>year</code>(meta) fields. Please notice <code>compose_doc_from_result</code> is set to <code>True</code> to enable such Document construction behavior.</p> <p>Below is an example of a pipeline which explores all ways how parameters could be supplied to the <code>Neo4jDynamicDocumentRetriever</code> component in the pipeline.</p> <pre><code>@component\nclass YearProvider:\n    @component.output_types(year_start=int, year_end=int)\n    def run(self, year_start: int, year_end: int):\n        return {\"year_start\": year_start, \"year_end\": year_end}\n\n# Configuration with default settings\nclient_config=Neo4jClientConfig()\n\nretriever = Neo4jDynamicDocumentRetriever(\n    client_config=client_config,\n    runtime_parameters=[\"year_start\", \"year_end\"],\n)\n\nquery = (\n    \"MATCH (doc:Document) \"\n    \"WHERE (doc.year &gt;= $year_start and doc.year &lt;= $year_end) AND doc.month = $month\"\n    \"RETURN doc LIMIT $num_return\"\n)\n\npipeline = Pipeline()\npipeline.add_component(\"year_provider\", YearProvider())\npipeline.add_component(\"retriever\", retriever)\npipeline.connect(\"year_provider.year_start\", \"retriever.year_start\")\npipeline.connect(\"year_provider.year_end\", \"retriever.year_end\")\n\nresult = pipeline.run(\n    data={\n        \"year_provider\": {\"year_start\": 2020, \"year_end\": 2021},\n        \"retriever\": {\n            \"query\": query,\n            \"parameters\": {\n                \"month\": \"02\",\n                \"num_return\": 2,\n            },\n        },\n    }\n)\n\ndocuments = result[\"retriever\"][\"documents\"]\n</code></pre> <p>Please notice the following from the example above:</p> <ul> <li><code>runtime_parameters</code> is a list of parameter names which are going to be input slots when connecting components     in a pipeline. In our case <code>year_start</code> and <code>year_end</code> parameters flow from the <code>year_provider</code> component into     <code>retriever</code>. The <code>query</code> uses those parameters in the <code>WHERE</code> clause.</li> <li><code>pipeline.run</code> specifies additional parameters to the <code>retriever</code> component which can be referenced in the     <code>query</code>. If parameter names clash those provided in the pipeline's data take precedence.</li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>@component\nclass Neo4jDynamicDocumentRetriever:\n    \"\"\"\n    A component for retrieving Documents from Neo4j database using plain Cypher query.\n\n    This component gives flexible way to retrieve data from Neo4j by running arbitrary Cypher query along with query\n    parameters. Query parameters can be supplied in a pipeline from other components (or pipeline data).\n\n    See the following documentation on how to compose Cypher queries with parameters:\n\n    - [Overview of Cypher query syntax](https://neo4j.com/docs/cypher-manual/current/queries/)\n    - [Cypher Query Parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/)\n\n    Above are resources which will help understand better Cypher query syntax and parameterization. Under the hood\n    [Neo4j Python Driver](https://neo4j.com/docs/python-manual/current/) is used to query database and fetch results.\n    You might be interested in the following documentation:\n\n    - [Query the database](https://neo4j.com/docs/python-manual/current/query-simple/)\n    - [Query parameters](https://neo4j.com/docs/python-manual/current/query-simple/#query-parameters)\n    - [Data types and mapping to Cypher types](https://neo4j.com/docs/python-manual/current/data-types/)\n\n    Note:\n        Please consider data types mappings in Cypher query when working with parameters. Neo4j Python Driver handles\n        type conversions/mappings. Specifically you can figure out in the documentation of the driver how to work with\n        temporal types (e.g. `DateTime`).\n\n    Query execution results will be mapped/converted to `haystack.Document` type. See more details in the\n    [RETURN clause](https://neo4j.com/docs/cypher-manual/current/clauses/return/) documentation. There are two\n    ways how Documents are being composed from query results.\n\n    (1) Converting documents from [nodes](https://neo4j.com/docs/cypher-manual/current/clauses/return/#return-nodes)\n\n    ```py title=\"Convert Neo4j `node` to `haystack.Document`\"\n    client_config = Neo4jClientConfig(\n        \"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\"\n    )\n\n    retriever = Neo4jDynamicDocumentRetriever(\n        client_config=client_config, doc_node_name=\"doc\", verify_connectivity=True\n    )\n\n    result = retriever.run(\n        query=\"MATCH (doc:Document) WHERE doc.year &gt; $year OR doc.year is NULL RETURN doc\",\n        parameters={\"year\": 2020}\n    )\n    documents: List[Document] = result[\"documents\"]\n    ```\n\n    Please notice how `doc_node_name` attribute assumes `\"doc\"` node is going to be returned from the query.\n    `Neo4jDynamicDocumentRetriever` will convert properties of the node (e.g. `id`, `content` etc) to\n    `haystack.Document` type.\n\n    (2) Converting documents from query output keys (e.g. [column aliases](https://neo4j.com/docs/cypher-manual/current/clauses/return/#return-column-alias))\n\n    You might want to run a complex query which aggregates information from multiple sources (nodes) in Neo4j. In such\n    case you can compose final Document from several dta points.\n\n    ```py title=\"Convert Neo4j `node` to `haystack.Document`\"\n    # Configuration with default settings\n    client_config=Neo4jClientConfig()\n\n    retriever = Neo4jDynamicDocumentRetriever(client_config=client_config, compose_doc_from_result=True)\n\n    result = retriever.run(\n        query=(\n            \"MATCH (doc:Document) \"\n            \"WHERE doc.year &gt; $year OR doc.year is NULL \"\n            \"RETURN doc.id as id, doc.content as content, doc.year as year\"\n        ),\n        parameters={\"year\": 2020},\n    )\n    documents: List[Document] = result[\"documents\"]\n    ```\n\n    The above will produce Documents with `id`, `content` and `year`(meta) fields. Please notice\n    `compose_doc_from_result` is set to `True` to enable such Document construction behavior.\n\n    Below is an example of a pipeline which explores all ways how parameters could be supplied to the\n    `Neo4jDynamicDocumentRetriever` component in the pipeline.\n\n    ```py\n    @component\n    class YearProvider:\n        @component.output_types(year_start=int, year_end=int)\n        def run(self, year_start: int, year_end: int):\n            return {\"year_start\": year_start, \"year_end\": year_end}\n\n    # Configuration with default settings\n    client_config=Neo4jClientConfig()\n\n    retriever = Neo4jDynamicDocumentRetriever(\n        client_config=client_config,\n        runtime_parameters=[\"year_start\", \"year_end\"],\n    )\n\n    query = (\n        \"MATCH (doc:Document) \"\n        \"WHERE (doc.year &gt;= $year_start and doc.year &lt;= $year_end) AND doc.month = $month\"\n        \"RETURN doc LIMIT $num_return\"\n    )\n\n    pipeline = Pipeline()\n    pipeline.add_component(\"year_provider\", YearProvider())\n    pipeline.add_component(\"retriever\", retriever)\n    pipeline.connect(\"year_provider.year_start\", \"retriever.year_start\")\n    pipeline.connect(\"year_provider.year_end\", \"retriever.year_end\")\n\n    result = pipeline.run(\n        data={\n            \"year_provider\": {\"year_start\": 2020, \"year_end\": 2021},\n            \"retriever\": {\n                \"query\": query,\n                \"parameters\": {\n                    \"month\": \"02\",\n                    \"num_return\": 2,\n                },\n            },\n        }\n    )\n\n    documents = result[\"retriever\"][\"documents\"]\n    ```\n\n    Please notice the following from the example above:\n\n    - `runtime_parameters` is a list of parameter names which are going to be input slots when connecting components\n        in a pipeline. In our case `year_start` and `year_end` parameters flow from the `year_provider` component into\n        `retriever`. The `query` uses those parameters in the `WHERE` clause.\n    - `pipeline.run` specifies additional parameters to the `retriever` component which can be referenced in the\n        `query`. If parameter names clash those provided in the pipeline's data take precedence.\n    \"\"\"\n\n    def __init__(\n        self,\n        client_config: Neo4jClientConfig,\n        query: Optional[str] = None,\n        runtime_parameters: Optional[List[str]] = None,\n        doc_node_name: Optional[str] = \"doc\",\n        compose_doc_from_result: Optional[bool] = False,\n        verify_connectivity: Optional[bool] = False,\n    ):\n        \"\"\"\n        Create a Neo4jDynamicDocumentRetriever component.\n\n        Args:\n            client_config: Neo4j client configuration to connect to database (e.g. credentials and connection settings).\n            query: Optional Cypher query for document retrieval. If `None` should be provided as component input.\n            runtime_parameters: list of input parameters/slots for connecting components in a pipeline.\n            doc_node_name: the name of the variable which is returned from Cypher query which contains Document\n                attributes (e.g. `id`, `content`, `meta` fields).\n            compose_doc_from_result: If `True` Document attributes will be constructed from Cypher query outputs (keys).\n                `doc_node_name` setting will be ignored in this case.\n            verify_connectivity: If `True` will verify connectivity with Neo4j database configured by `client_config`.\n\n        Raises:\n            ComponentError: In case neither `compose_doc_from_result` nor `doc_node_name` are defined.\n        \"\"\"\n        if not compose_doc_from_result and not doc_node_name:\n            raise ComponentError(\n                \"Please specify how Document is being composed out of Neo4j query response. \"\n                \"With `compose_doc_from_result` set to `True` documents will be created out of properties/keys \"\n                \"returned by the query.\"\n            )\n\n        self._client_config = client_config\n        self._query = query\n        self._runtime_parameters = runtime_parameters or []\n        self._doc_node_name = doc_node_name\n        self._compose_doc_from_result = compose_doc_from_result\n        self._verify_connectivity = verify_connectivity\n\n        self._neo4j_client = Neo4jClient(client_config)\n\n        # setup inputs\n        kwargs_input_slots = dict.fromkeys(self._runtime_parameters, Optional[Any])\n        component.set_input_types(self, **kwargs_input_slots)\n\n        # setup outputs\n        component.set_output_types(self, documents=List[Document])\n\n        if verify_connectivity:\n            self._neo4j_client.verify_connectivity()\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n        \"\"\"\n        data = default_to_dict(\n            self,\n            query=self._query,\n            runtime_parameters=self._runtime_parameters,\n            doc_node_name=self._doc_node_name,\n            compose_doc_from_result=self._compose_doc_from_result,\n            verify_connectivity=self._verify_connectivity,\n        )\n\n        data[\"init_parameters\"][\"client_config\"] = self._client_config.to_dict()\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jDynamicDocumentRetriever\":\n        \"\"\"\n        Deserialize this component from a dictionary.\n        \"\"\"\n        client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n        data[\"init_parameters\"][\"client_config\"] = client_config\n        return default_from_dict(cls, data)\n\n    def run(self, query: Optional[str] = None, parameters: Optional[Dict[str, Any]] = None, **kwargs: Dict[str, Any]):\n        \"\"\"\n        Runs the arbitrary Cypher `query` with `parameters` and returns Documents.\n\n        Args:\n            query: Cypher query to run.\n            parameters: Cypher query parameters which can be used as placeholders in the `query`.\n            kwargs: Arbitrary parameters supplied in a pipeline execution from other component's output slots, e.g.\n                `pipeline.connect(\"year_provider.year_start\", \"retriever.year_start\")`, where `year_start` will be part\n                of `kwargs`.\n\n        Returns:\n            Retrieved documents.\n        \"\"\"\n        query = query or self._query\n        if query is None:\n            raise ValueError(\n                \"`query` is mandatory input and should be provided either in component's constructor, pipeline input or\"\n                \"connection\"\n            )\n        kwargs = kwargs or {}\n        parameters = parameters or {}\n        parameters_combined = {**kwargs, **parameters}\n\n        documents: List[Document] = []\n        neo4j_query_result = self._neo4j_client.query_nodes(query, parameters_combined)\n\n        for record in neo4j_query_result:\n            data = record.data()\n            document_dict = data if self._compose_doc_from_result else data.get(cast(str, self._doc_node_name))\n            documents.append(Document.from_dict(document_dict))\n\n        return {\"documents\": documents}\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jDynamicDocumentRetriever.__init__","title":"__init__","text":"<pre><code>__init__(\n    client_config: Neo4jClientConfig,\n    query: Optional[str] = None,\n    runtime_parameters: Optional[List[str]] = None,\n    doc_node_name: Optional[str] = \"doc\",\n    compose_doc_from_result: Optional[bool] = False,\n    verify_connectivity: Optional[bool] = False,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>client_config</code>               (<code>Neo4jClientConfig</code>)           \u2013            <p>Neo4j client configuration to connect to database (e.g. credentials and connection settings).</p> </li> <li> <code>query</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Optional Cypher query for document retrieval. If <code>None</code> should be provided as component input.</p> </li> <li> <code>runtime_parameters</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>list of input parameters/slots for connecting components in a pipeline.</p> </li> <li> <code>doc_node_name</code>               (<code>Optional[str]</code>, default:                   <code>'doc'</code> )           \u2013            <p>the name of the variable which is returned from Cypher query which contains Document attributes (e.g. <code>id</code>, <code>content</code>, <code>meta</code> fields).</p> </li> <li> <code>compose_doc_from_result</code>               (<code>Optional[bool]</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> Document attributes will be constructed from Cypher query outputs (keys). <code>doc_node_name</code> setting will be ignored in this case.</p> </li> <li> <code>verify_connectivity</code>               (<code>Optional[bool]</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> will verify connectivity with Neo4j database configured by <code>client_config</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ComponentError</code>             \u2013            <p>In case neither <code>compose_doc_from_result</code> nor <code>doc_node_name</code> are defined.</p> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>def __init__(\n    self,\n    client_config: Neo4jClientConfig,\n    query: Optional[str] = None,\n    runtime_parameters: Optional[List[str]] = None,\n    doc_node_name: Optional[str] = \"doc\",\n    compose_doc_from_result: Optional[bool] = False,\n    verify_connectivity: Optional[bool] = False,\n):\n    \"\"\"\n    Create a Neo4jDynamicDocumentRetriever component.\n\n    Args:\n        client_config: Neo4j client configuration to connect to database (e.g. credentials and connection settings).\n        query: Optional Cypher query for document retrieval. If `None` should be provided as component input.\n        runtime_parameters: list of input parameters/slots for connecting components in a pipeline.\n        doc_node_name: the name of the variable which is returned from Cypher query which contains Document\n            attributes (e.g. `id`, `content`, `meta` fields).\n        compose_doc_from_result: If `True` Document attributes will be constructed from Cypher query outputs (keys).\n            `doc_node_name` setting will be ignored in this case.\n        verify_connectivity: If `True` will verify connectivity with Neo4j database configured by `client_config`.\n\n    Raises:\n        ComponentError: In case neither `compose_doc_from_result` nor `doc_node_name` are defined.\n    \"\"\"\n    if not compose_doc_from_result and not doc_node_name:\n        raise ComponentError(\n            \"Please specify how Document is being composed out of Neo4j query response. \"\n            \"With `compose_doc_from_result` set to `True` documents will be created out of properties/keys \"\n            \"returned by the query.\"\n        )\n\n    self._client_config = client_config\n    self._query = query\n    self._runtime_parameters = runtime_parameters or []\n    self._doc_node_name = doc_node_name\n    self._compose_doc_from_result = compose_doc_from_result\n    self._verify_connectivity = verify_connectivity\n\n    self._neo4j_client = Neo4jClient(client_config)\n\n    # setup inputs\n    kwargs_input_slots = dict.fromkeys(self._runtime_parameters, Optional[Any])\n    component.set_input_types(self, **kwargs_input_slots)\n\n    # setup outputs\n    component.set_output_types(self, documents=List[Document])\n\n    if verify_connectivity:\n        self._neo4j_client.verify_connectivity()\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jDynamicDocumentRetriever.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize this component to a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serialize this component to a dictionary.\n    \"\"\"\n    data = default_to_dict(\n        self,\n        query=self._query,\n        runtime_parameters=self._runtime_parameters,\n        doc_node_name=self._doc_node_name,\n        compose_doc_from_result=self._compose_doc_from_result,\n        verify_connectivity=self._verify_connectivity,\n    )\n\n    data[\"init_parameters\"][\"client_config\"] = self._client_config.to_dict()\n\n    return data\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jDynamicDocumentRetriever.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Neo4jDynamicDocumentRetriever\n</code></pre> <p>Deserialize this component from a dictionary.</p> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jDynamicDocumentRetriever\":\n    \"\"\"\n    Deserialize this component from a dictionary.\n    \"\"\"\n    client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n    data[\"init_parameters\"][\"client_config\"] = client_config\n    return default_from_dict(cls, data)\n</code></pre>"},{"location":"reference/neo4j_retriever/#neo4j_haystack.components.neo4j_retriever.Neo4jDynamicDocumentRetriever.run","title":"run","text":"<pre><code>run(\n    query: Optional[str] = None,\n    parameters: Optional[Dict[str, Any]] = None,\n    **kwargs: Dict[str, Any]\n)\n</code></pre> <p>Runs the arbitrary Cypher <code>query</code> with <code>parameters</code> and returns Documents.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Cypher query to run.</p> </li> <li> <code>parameters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Cypher query parameters which can be used as placeholders in the <code>query</code>.</p> </li> <li> <code>kwargs</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Arbitrary parameters supplied in a pipeline execution from other component's output slots, e.g. <code>pipeline.connect(\"year_provider.year_start\", \"retriever.year_start\")</code>, where <code>year_start</code> will be part of <code>kwargs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>Retrieved documents.</p> </li> </ul> Source code in <code>src/neo4j_haystack/components/neo4j_retriever.py</code> <pre><code>def run(self, query: Optional[str] = None, parameters: Optional[Dict[str, Any]] = None, **kwargs: Dict[str, Any]):\n    \"\"\"\n    Runs the arbitrary Cypher `query` with `parameters` and returns Documents.\n\n    Args:\n        query: Cypher query to run.\n        parameters: Cypher query parameters which can be used as placeholders in the `query`.\n        kwargs: Arbitrary parameters supplied in a pipeline execution from other component's output slots, e.g.\n            `pipeline.connect(\"year_provider.year_start\", \"retriever.year_start\")`, where `year_start` will be part\n            of `kwargs`.\n\n    Returns:\n        Retrieved documents.\n    \"\"\"\n    query = query or self._query\n    if query is None:\n        raise ValueError(\n            \"`query` is mandatory input and should be provided either in component's constructor, pipeline input or\"\n            \"connection\"\n        )\n    kwargs = kwargs or {}\n    parameters = parameters or {}\n    parameters_combined = {**kwargs, **parameters}\n\n    documents: List[Document] = []\n    neo4j_query_result = self._neo4j_client.query_nodes(query, parameters_combined)\n\n    for record in neo4j_query_result:\n        data = record.data()\n        document_dict = data if self._compose_doc_from_result else data.get(cast(str, self._doc_node_name))\n        documents.append(Document.from_dict(document_dict))\n\n    return {\"documents\": documents}\n</code></pre>"},{"location":"reference/neo4j_store/","title":"Neo4jDocumentStore","text":""},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore","title":"Neo4jDocumentStore","text":"<p>Document store for Neo4j Database with support for dense retrievals using     Vector Search Index</p> <p>The implementation is based on Python Driver for database access. Document properties are stored as graph nodes. Embeddings are stored as part of node properties along with the rest of attributes (including meta):</p> Document json representation (e.g. `Document.to_json`)<pre><code>{\n  \"id\": \"793764\",\n  \"content\": \"Aliens and UFOs are more real than ever before...\",\n  \"embedding\": [...],\n  \"score\": null,\n  \"meta\": {\n    \"title\": \"Alien Chronicles Top Ufo Encounters\",\n    \"runtime\": 70.0\n  }\n}\n</code></pre> <p>The following should be expected after writing documents to Neo4j (see <code>Neo4jDocumentStore.write_documents</code>).</p> Neo4j node json representation for a document (with comments)<pre><code>{\n  \"identity\": 18900, // Neo4j native id\n  \"labels\": [\"Document\"], // by default using \"Document\" label for the node\n  \"properties\": {\n    \"id\": \"793764\",\n    \"content\": \"Aliens and UFOs are more real than ever before...\",\n    \"embedding\": [...],\n\n    // Document.meta fields (same level as rest of attributes)\n    \"title\": \"Alien Chronicles Top Ufo Encounters\",\n    \"runtime\": 70.0\n  },\n  \"elementId\": \"18900\"\n}\n</code></pre> <p>Please notice the <code>embedding</code> property which is stored as part of Neo4j node properties. It has type <code>LIST&lt;FLOAT&gt;</code> and is assigned to the node using <code>db.create.setNodeVectorProperty</code> procedure. The node acts as a storage for the <code>embedding</code> but the actual dense retrieval is performed against a dedicated search index created automatically by <code>Neo4jDocumentStore</code>. The index is created using <code>db.index.vector.createNodeIndex()</code> Neo4j procedure and is based on the <code>embedding</code> property.</p> <p>Embedding dimension as well as similarity function (e.g. <code>cosine</code>) are configurable. At the moment Neo4j supports only cosine and euclidean(l2) similarity functions.</p> <p>Metadata filtering by <code>Neo4jDocumentStore</code> is performed using the standard <code>WHERE</code> Cypher query clause. Vector search is implemented by calling <code>db.index.vector.queryNodes()</code> procedure. Neo4j currently does not support metadata \"pre-filtering\" which runs in combination with vector search. First, vector search takes place and metadata is filtered based on its results.</p> <p>The metadata filtering can be further improved by creating/tweaking     Indexes for search performance. It can be managed directly in Neo4j as an administrative task.</p> <p>You have several options available for deploying/installing Neo4j. See more details in     Installation Operations Manual. As of Neo4j 5.13, the vector search index is no longer a beta feature.</p> <p>Bellow is an example how document store can be created:</p> <pre><code># Obtain list of documents - there are many options available in Haystack\ndocuments: List[Document] = ...\n\n# Create `Neo4jDocumentStore` with required credentials and Vector index configuration\ndocument_store = Neo4jDocumentStore(\n    url=\"bolt://localhost:7687\",\n    username=\"neo4j\",\n    password=\"passw0rd\",\n    database=\"neo4j\",\n    embedding_dim=384,\n    index=\"document-embeddings\", # The name of the Vector search index in Neo4j\n    node_label=\"Document\", # Providing a label to Neo4j nodes which store Documents\n)\n\n# Write documents to Neo4j. Respective nodes will be created.\ndocument_store.write_documents(documents)\n</code></pre> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>class Neo4jDocumentStore:\n    \"\"\"\n    Document store for [Neo4j Database](https://neo4j.com/) with support for dense retrievals using \\\n    [Vector Search Index](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/)\n\n    The implementation is based on [Python Driver](https://neo4j.com/docs/python-manual/current/) for database access.\n    Document properties are stored as graph nodes. Embeddings are stored as part of node properties along with the rest\n    of attributes (including meta):\n\n    ```py title=\"Document json representation (e.g. `Document.to_json`)\"\n    {\n      \"id\": \"793764\",\n      \"content\": \"Aliens and UFOs are more real than ever before...\",\n      \"embedding\": [...],\n      \"score\": null,\n      \"meta\": {\n        \"title\": \"Alien Chronicles Top Ufo Encounters\",\n        \"runtime\": 70.0\n      }\n    }\n    ```\n\n    The following should be expected after writing documents to Neo4j (see `Neo4jDocumentStore.write_documents`).\n\n    ```json title=\"Neo4j node json representation for a document (with comments)\"\n    {\n      \"identity\": 18900, // Neo4j native id\n      \"labels\": [\"Document\"], // by default using \"Document\" label for the node\n      \"properties\": {\n        \"id\": \"793764\",\n        \"content\": \"Aliens and UFOs are more real than ever before...\",\n        \"embedding\": [...],\n\n        // Document.meta fields (same level as rest of attributes)\n        \"title\": \"Alien Chronicles Top Ufo Encounters\",\n        \"runtime\": 70.0\n      },\n      \"elementId\": \"18900\"\n    }\n    ```\n\n    Please notice the `embedding` property which is stored as part of Neo4j node properties. It has type ``LIST&lt;FLOAT&gt;``\n    and is assigned to the node using ``db.create.setNodeVectorProperty`` procedure. The node acts as a storage for the\n    `embedding` but the actual dense retrieval is performed against a dedicated search index created automatically by\n    `Neo4jDocumentStore`. The index is created using `db.index.vector.createNodeIndex()` Neo4j procedure and is based\n    on the `embedding` property.\n\n    Embedding dimension as well as similarity function (e.g. `cosine`) are configurable.\n    At the moment Neo4j supports only cosine and euclidean(l2) similarity functions.\n\n    Metadata filtering by `Neo4jDocumentStore` is performed using the standard `WHERE` Cypher query clause.\n    Vector search is implemented by calling `db.index.vector.queryNodes()` procedure. **Neo4j currently does not support\n    metadata \"pre-filtering\" which runs in combination with vector search. First, vector search takes place and metadata\n    is filtered based on its results.**\n\n    The metadata filtering can be further improved by creating/tweaking \\\n    [Indexes for search performance](https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/).\n    It can be managed directly in Neo4j as an administrative task.\n\n    You have several options available for deploying/installing Neo4j. See more details in \\\n    [Installation Operations Manual](https://neo4j.com/docs/operations-manual/current/installation/).\n    As of Neo4j 5.13, the vector search index is no longer a beta feature.\n\n    Bellow is an example how document store can be created:\n\n    ```python\n    # Obtain list of documents - there are many options available in Haystack\n    documents: List[Document] = ...\n\n    # Create `Neo4jDocumentStore` with required credentials and Vector index configuration\n    document_store = Neo4jDocumentStore(\n        url=\"bolt://localhost:7687\",\n        username=\"neo4j\",\n        password=\"passw0rd\",\n        database=\"neo4j\",\n        embedding_dim=384,\n        index=\"document-embeddings\", # The name of the Vector search index in Neo4j\n        node_label=\"Document\", # Providing a label to Neo4j nodes which store Documents\n    )\n\n    # Write documents to Neo4j. Respective nodes will be created.\n    document_store.write_documents(documents)\n    ```\n    \"\"\"\n\n    SIMILARITY_MAP: ClassVar[Dict[str, SimilarityFunction]] = {\n        \"cosine\": \"cosine\",\n        \"l2\": \"euclidean\",\n    }\n\n    def __init__(\n        self,\n        url: Optional[str] = DEFAULT_NEO4J_URI,\n        database: Optional[str] = DEFAULT_NEO4J_DATABASE,\n        username: Optional[str] = DEFAULT_NEO4J_USERNAME,\n        password: Optional[str] = DEFAULT_NEO4J_PASSWORD,\n        client_config: Optional[Neo4jClientConfig] = None,\n        index: str = \"document-embeddings\",\n        node_label: str = \"Document\",\n        embedding_dim: int = 768,\n        embedding_field: str = \"embedding\",\n        similarity: str = \"cosine\",\n        progress_bar: bool = False,\n        create_index_if_missing: Optional[bool] = True,\n        recreate_index: Optional[bool] = False,\n        write_batch_size: int = 100,\n        verify_connectivity: Optional[bool] = True,\n        document_marshaller: Optional[QueryParametersMarshaller] = None,\n        neo4j_client: Optional[Neo4jClient] = None,\n    ):\n        \"\"\"\n        Constructor method\n\n        Args:\n            url: URI pointing to Neo4j instance see (https://neo4j.com/docs/api/python-driver/current/api.html#uri)\n            database: Neo4j database to interact with.\n            username: Username to authenticate with the database.\n            password: Password credential for the given username.\n            client_config: Advanced client configuration to control various settings of underlying neo4j python\n                driver. See `Neo4jClientConfig` for more details. The mandatory `url` attribute will be set on\n                the `client_config` in case it was provided in the config itself.\n            index: The name of Neo4j Vector Search Index used for storing and querying embeddings.\n            node_label: The name of the label used in Neo4j to represent `haystack.Document`.\n                Neo4j nodes are used primarily as storage for Document attributes and metadata filtering.\n                The filtering process includes `node_label` in database queries (e.g.\n                `:::cypher MATCH (doc:&lt;node_label&gt;) RETURN doc`). Together with the `self.index` it identifies where\n                documents are located in the database.\n            embedding_dim: embedding dimension specified for the Vector search index.\n            embedding_field: the name of embedding field which is created as a Neo4j node property containing an\n                embedding vector. By default it is the same as in `haystack.schema.Document`. It is used during\n                index creation and querying embeddings.\n            similarity: similarity function specified during Vector search index creation. Supported values are\n                \"cosine\" and \"l2\".\n            progress_bar: Shows a tqdm progress bar.\n            create_index_if_missing: Will create vector index during class initialization if it is not yet available\n                in the `database`. Will only take effect if `recreate_index` is not `True`.\n            recreate_index: If `True` will delete existing index and its data (documents) and create a new\n                index. Useful for testing purposes when a new DocumentStore initializes with a clean database state.\n            write_batch_size: Number of documents to write at once. When working with large number of documents\n                batching can help reduce memory footprint.\n            verify_connectivity: If `True` will check connection to the database using provided credentials during\n                creation of the Document Store.\n            document_marshaller: A custom marshaller, if provided, to convert `haystack.Document` to a dictionary to be\n                stored as Neo4j node properties. **Neo4j can not store nested properties in a node** so this\n                customization point should be used in rare occasions in case default implementation\n                (see `_DefaultDocumentMarshaller`) is not sufficient.\n\n        Raises:\n            ValueError: In case similarity function specified is not supported\n        \"\"\"\n\n        super().__init__()\n\n        self.index = index\n        self.node_label = node_label\n        self.embedding_dim = embedding_dim\n        self.embedding_field = embedding_field\n\n        self.similarity = similarity\n        self.similarity_function = self._get_distance(similarity)\n\n        self.progress_bar = progress_bar\n        self.create_index_if_missing = create_index_if_missing\n        self.recreate_index = recreate_index\n        self.write_batch_size = write_batch_size\n        self.verify_connectivity = verify_connectivity\n\n        self.document_marshaller = document_marshaller or _DefaultDocumentMarshaller()\n\n        self.filter_parser = FilterParser()\n\n        if neo4j_client:\n            self.neo4j_client = neo4j_client\n        else:\n            if client_config and not client_config.url:\n                client_config.url = url\n            self.client_config = client_config or Neo4jClientConfig(url, database, username, password)\n            self.neo4j_client = Neo4jClient(self.client_config)\n\n        if verify_connectivity:\n            self.neo4j_client.verify_connectivity()\n\n        if recreate_index:\n            self.delete_index()\n            self.create_index()\n        elif create_index_if_missing:\n            self.neo4j_client.create_index_if_missing(\n                self.index, self.node_label, self.embedding_field, self.embedding_dim, self.similarity_function\n            )\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Serializes this store to a dictionary.\n        \"\"\"\n        data = default_to_dict(\n            self,\n            index=self.index,\n            node_label=self.node_label,\n            embedding_dim=self.embedding_dim,\n            embedding_field=self.embedding_field,\n            similarity=self.similarity,\n            progress_bar=self.progress_bar,\n            create_index_if_missing=self.create_index_if_missing,\n            recreate_index=self.recreate_index,\n            write_batch_size=self.write_batch_size,\n            verify_connectivity=self.verify_connectivity,\n        )\n\n        data[\"init_parameters\"][\"client_config\"] = self.client_config.to_dict()\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jDocumentStore\":\n        \"\"\"\n        Deserializes the store from a dictionary.\n        \"\"\"\n        client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n        data[\"init_parameters\"][\"client_config\"] = client_config\n\n        return default_from_dict(cls, data)\n\n    def count_documents(self) -&gt; int:\n        \"\"\"\n        Returns the number of documents stored.\n        \"\"\"\n        return self.count_documents_with_filter()\n\n    def filter_documents(self, filters: Optional[FilterType] = None) -&gt; List[Document]:\n        \"\"\"\n        Returns the documents that match the filters provided.\n\n        Args:\n            filters: Optional filters to narrow down the documents which should be returned.\n                Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n\n        Returns:\n            A list of found documents.\n        \"\"\"\n        return list(self.get_all_documents_generator(filters, return_embedding=True))\n\n    def write_documents(\n        self,\n        documents: List[Document],\n        policy: DuplicatePolicy = DuplicatePolicy.NONE,\n    ) -&gt; int:\n        \"\"\"\n        Writes documents to the DocumentStore.\n\n        Args:\n            documents: List of `haystack.Document`. If they already contain the embeddings, we'll index\n                them right away in Neo4j. If not, you can later call `update_embeddings` to create and index them.\n            policy: Handle duplicates document based on parameter options. Parameter options:\n\n                - `SKIP`: Ignore the duplicates documents.\n                - `OVERWRITE`: Update any existing documents with the same ID when adding documents.\n                - `FAIL`: An error is raised if the document ID of the document being added already exists\n\n        Raises:\n            DuplicateDocumentError: Exception triggers on duplicate document.\n            ValueError: If `documents` parameter is not a list of of type `haystack.Document`.\n\n        Returns:\n            Number of written documents.\n        \"\"\"\n\n        for doc in documents:\n            if not isinstance(doc, Document):\n                msg = f\"DocumentStore.write_documents() expects a list of Documents but got an element of {type(doc)}.\"\n                raise ValueError(msg)\n\n        if len(documents) == 0:\n            logger.warning(\"Calling Neo4jDocumentStore.write_documents() with an empty list\")\n            return 0\n\n        batch_size = self.write_batch_size\n        document_objects = self._handle_duplicate_documents(documents, policy)\n\n        documents_written = 0\n        batched_documents = get_batches_from_generator(document_objects, batch_size)\n        with tqdm(\n            total=len(document_objects),\n            desc=f\"Write Documents&lt;index: {self.index},node_label: {self.node_label}&gt;\",\n            unit=\" docs\",\n            disable=not self.progress_bar,\n        ) as progress_bar:\n            for document_batch in batched_documents:\n                records = [self._document_to_neo4j_record(doc) for doc in document_batch]\n                embedding_field = self.embedding_field\n                self.neo4j_client.merge_nodes(self.node_label, embedding_field, records)\n                documents_written += len(records)\n                progress_bar.update(batch_size)\n\n        return documents_written\n\n    def delete_documents(self, document_ids: List[str]) -&gt; None:\n        \"\"\"\n        Deletes all documents with a matching document_ids from the DocumentStore.\n        Fails with `MissingDocumentError` if no document with this id is present in the DocumentStore.\n\n        Args:\n            document_ids: Document ids of documents to be removed.\n        \"\"\"\n        self.delete_all_documents(document_ids)\n\n    def update_embeddings(\n        self,\n        documents: List[Document],\n        batch_size: int = 100,\n    ):\n        \"\"\"\n        Updates the embeddings in the document store for given `documents`.\n        This can be useful if want to add or change the embeddings for your documents (e.g. after changing the embedder\n        configuration).\n\n        Args:\n            documents: Documents with non-null embeddings to be updated.\n            batch_size: When working with large number of documents, batching can help reduce memory footprint.\n        \"\"\"\n\n        document_count = len(documents)\n        logger.debug(\"Updating embeddings for %s docs...\", document_count)\n\n        with tqdm(\n            total=document_count, disable=not self.progress_bar, unit=\" docs\", desc=\"Updating embeddings\"\n        ) as progress_bar:\n            for document_batch in get_batches_from_generator(documents, batch_size):\n                only_embeddings = [{\"id\": doc.id, self.embedding_field: doc.embedding} for doc in document_batch]\n\n                self.neo4j_client.update_embedding(\n                    self.node_label,\n                    self.embedding_field,\n                    only_embeddings,\n                )\n\n                progress_bar.update(batch_size)\n\n    def get_all_documents_generator(\n        self,\n        filters: Optional[FilterType] = None,\n        return_embedding: Optional[bool] = None,\n        batch_size: int = 1000,\n    ) -&gt; Generator[Document, None, None]:\n        \"\"\"\n        Get all documents from the document store. Under-the-hood, documents are fetched in batches from the\n        document store and yielded as individual documents. This method can be used to iteratively process\n        a large number of documents without having to load all documents in memory. Such mechanism is natively\n        supported by underlying Neo4j Python Driver (an internal buffer which is depleted while being read and filled\n        up while data is coming from the database)\n\n        Args:\n            filters: Optional filters to narrow down the documents which should be returned.\n                Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n            return_embedding: To return document embedding. By default is `None` which should reduce amount of data\n                returned (considering embeddings are usually large in size)\n            batch_size: When working with large number of documents, batching can help reduce memory footprint.\n                This parameter controls how many documents are retrieved at once from Neo4j.\n\n        Returns:\n            A Generator of found documents.\n        \"\"\"\n\n        filter_ast = self._parse_filters(filters=filters)\n        skip_properties = [] if return_embedding else [self.embedding_field]\n\n        records = self.neo4j_client.find_nodes(self.node_label, filter_ast, skip_properties, fetch_size=batch_size)\n\n        return (self._neo4j_record_to_document(rec) for rec in records)\n\n    def get_document_by_id(self, document_id: str) -&gt; Optional[Document]:\n        \"\"\"\n        Retrieves a document by its `id`.\n\n        Args:\n            document_id: id of the Document to retrieve.\n\n        Returns:\n            A found document with matching `document_id` if exactly one is found, otherwise `None` is returned\n        \"\"\"\n\n        records = self.get_documents_by_id([document_id])\n        number_found = len(records)\n\n        if number_found &gt; 1:\n            logger.warn(\n                f\"get_document_by_id: Found more than one document for a given id(`{id}`). \"\n                \"Expected: 1, Found: {number_found}. Please make sure your data has unique ids\"\n            )\n\n        return records[0] if number_found &gt; 0 else None\n\n    def get_documents_by_id(\n        self,\n        document_ids: List[str],\n        batch_size: int = 1_000,\n    ) -&gt; List[Document]:\n        \"\"\"\n        Retrieves all documents using their ids.\n\n        Args:\n            document_ids: List of ids to retrieve.\n            batch_size: Number of documents to retrieve at a time. When working with large number of documents,\n                batching can help reduce memory footprint.\n\n        Returns:\n            List of found Documents.\n        \"\"\"\n\n        documents: List[Document] = []\n        for batch_ids in get_batches_from_generator(document_ids, batch_size):\n            filter_ast = self.filter_parser.comparison_op(\"id\", COMPARISON_OPS.OP_IN, list(batch_ids))\n            records = self.neo4j_client.find_nodes(self.node_label, filter_ast)\n            documents.extend([self._neo4j_record_to_document(rec) for rec in records])\n\n        return documents\n\n    def count_documents_with_filter(\n        self,\n        filters: Optional[FilterType] = None,\n    ) -&gt; int:\n        \"\"\"\n        Return the count of filtered documents in the document store.\n\n        Args:\n            filters: Narrow down the documents which should be counted.\n                Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n\n        Returns:\n            Found documents count with respective filters applied.\n        \"\"\"\n\n        filter_ast = self._parse_filters(filters=filters)\n\n        return self.neo4j_client.count_nodes(self.node_label, filter_ast)\n\n    def query_by_embedding(\n        self,\n        query_embedding: List[float],\n        filters: Optional[Dict[str, Any]] = None,\n        top_k: int = 10,\n        return_embedding: Optional[bool] = None,\n        scale_score: bool = True,\n        expand_top_k: Optional[int] = None,\n    ) -&gt; List[Document]:\n        \"\"\"\n        Find the document that is most similar to the provided `query_emb` by using a vector similarity metric.\n\n        Args:\n            query_embedding: Embedding of the query (e.g. gathered from Dense Retrievers)\n            filters: Optional filters to narrow down the documents which should be returned after vector search.\n                Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n                Vector search happens first yielding `top_k` results, filtering is applied afterwards. Use\n                `expand_top_k` parameter to increase amount of documents retrieved from `index` (`expand_top_k` take\n                precedence if provided), filtering will make sure to return `top_k` out of `expand_top_k` documents\n                ordered by score.\n            top_k: How many documents to return.\n            return_embedding: To return document embedding. By default is `None` which should reduce amount of data\n                returned (considering embeddings are usually large in size)\n            scale_score: Whether to scale the similarity score to the unit interval (range of [0,1]).\n                If true (default) similarity scores (e.g. cosine or dot_product) which naturally have a different value\n                range will be scaled to a range of [0,1], where 1 means extremely relevant. Otherwise raw similarity\n                scores (e.g. cosine or dot_product) will be used.\n            expand_top_k: The value will override `top_k` for vector search if provided. Should be used in case\n                `filters` are expected to be applied on a greater amount of documents. After filtering takes place\n                `top_k` documents retrieved ordered by score.\n\n        Returns:\n            Found `top_k` documents.\n        \"\"\"\n\n        filter_ast = self._parse_filters(filters=filters)\n        skip_properties = [] if return_embedding else [self.embedding_field]\n\n        records = self.neo4j_client.query_embeddings(\n            self.index, top_k, query_embedding, filter_ast, skip_properties, expand_top_k\n        )\n        results = [self._neo4j_record_to_document(rec) for rec in records]\n\n        if scale_score:\n            for document in results:\n                document.score = self._scale_to_unit_interval(document.score)\n\n        return results\n\n    def delete_all_documents(\n        self,\n        document_ids: Optional[List[str]] = None,\n        filters: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Delete documents from the document store. All documents will be deleted, in case either `filters` or\n        `document_ids` are defined only filtered subset will be deleted.\n\n        Args:\n            document_ids: Optional list of document ids to narrow down the documents to be deleted.\n            filters: Optional filters to narrow down the documents which should be deleted.\n                Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n        \"\"\"\n\n        filter_ast = self._parse_filters(ids=document_ids, filters=filters)\n        self.neo4j_client.delete_nodes(self.node_label, filter_ast)\n\n    def delete_index(self):\n        \"\"\"\n        Deletes an existing index. The index including all data will be removed. The implementation deletes the index\n        itself as well as all nodes having `self.node_label` label\n        \"\"\"\n\n        try:\n            self.neo4j_client.delete_index(self.index)\n        except DatabaseError as err:\n            if err.code == \"Neo.DatabaseError.Schema.IndexDropFailed\":\n                logger.debug(\"Could not remove index `{index}`. Most probably it does not exist.\")\n            else:\n                raise\n\n        self.delete_all_documents()\n\n    def create_index(self):\n        self.neo4j_client.create_index(\n            self.index, self.node_label, self.embedding_field, self.embedding_dim, self.similarity_function\n        )\n\n    def update_document_meta(self, document_id: str, meta: Dict[str, Any]):\n        \"\"\"\n        Updates metadata properties in Neo4j for a Document found by its `document_id`. Please see details on how\n        properties in nodes are being mutated in Neo4j for a given `meta` dictionary (https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map)\n\n        Args:\n            document_id: The Document id to update in Neo4j\n            meta: Dictionary of new metadata. Will replace property values in case those already exist in the\n                corresponding Neo4j node. Please notice it is assumed Document metadata has same schema (e.g. same\n                amount of properties and its names) as in originally created nodes in Neo4j. Otherwise some side effects\n                might be produced (e.g. a property is renamed in `meta` which leaves an old one in Neo4j).\n        \"\"\"\n\n        updated_record = self.neo4j_client.update_node(self.node_label, document_id, meta)\n\n        if not updated_record:\n            logger.warning(\n                \"update_document_meta: Could not find document with id(%s) to update its meta attributes. \"\n                \"Please check if provided id is valid\",\n                document_id,\n            )\n\n    def _handle_duplicate_documents(\n        self,\n        documents: List[Document],\n        policy: DuplicatePolicy = None,\n    ):\n        \"\"\"\n        Checks whether any of the passed documents is already existing in the chosen index and returns a list of\n        documents that are not in the index yet.\n\n        :param documents: A list of Haystack Document objects.\n        :param policy: Handle duplicates document based on parameter options.\n                                    Parameter options : ( 'skip','overwrite','fail')\n                                    skip (default option): Ignore the duplicates documents\n                                    overwrite: Update any existing documents with the same ID when adding documents.\n                                    fail: an error is raised if the document ID of the document being added already\n                                    exists.\n        :return: A list of `haystack.Document` objects.\n        \"\"\"\n\n        if policy in (DuplicatePolicy.SKIP, DuplicatePolicy.FAIL):\n            documents = self._drop_duplicate_documents(documents)\n            documents_found = self.get_documents_by_id(document_ids=[doc.id for doc in documents])\n            ids_exist_in_db: List[str] = [doc.id for doc in documents_found]\n\n            if len(ids_exist_in_db) &gt; 0 and policy == DuplicatePolicy.FAIL:\n                msg = f\"Document with ids '{', '.join(ids_exist_in_db)} already exists in index = '{self.index}'.\"\n                raise DuplicateDocumentError(msg)\n\n            documents = list(filter(lambda doc: doc.id not in ids_exist_in_db, documents))\n\n        return documents\n\n    def _drop_duplicate_documents(self, documents: List[Document]) -&gt; List[Document]:\n        \"\"\"\n        Drop duplicates documents based on same hash ID\n\n        :param documents: A list of Haystack Document objects.\n        :param index: name of the index\n        :return: A list of Haystack Document objects.\n        \"\"\"\n        _hash_ids: Set = set()\n        _documents: List[Document] = []\n\n        for document in documents:\n            if document.id in _hash_ids:\n                logger.info(\n                    \"Duplicate Documents: Document with id '%s' already exists in index '%s'\",\n                    document.id,\n                    self.index,\n                )\n                continue\n            _documents.append(document)\n            _hash_ids.add(document.id)\n\n        return _documents\n\n    def _get_distance(self, similarity: str) -&gt; SimilarityFunction:\n        \"\"\"\n        Validates similarity function so that it is supported by neo4j vector index.\n        Only \"cosine\" and \"l2\" are supported aat the moment.\n\n        Args:\n            similarity: Common similarity values accepted by DocumentStores in Haystack,\n                e.g. \"cosine\", \"dot_product\", \"l2\".\n\n        Raises:\n            ValueError: If given similarity is not supported by neo4j.\n\n        Returns:\n            Similarity function supported by Neo4j vector index (\"cosine\" or \"euclidean\").\n        \"\"\"\n        try:\n            return self.SIMILARITY_MAP[similarity]\n        except KeyError as exc:\n            raise ValueError(\n                f\"Provided similarity '{similarity}' is not supported by Neo4jDocumentStore. \"\n                f\"Please choose one of the options: {', '.join(self.SIMILARITY_MAP.keys())}\"\n            ) from exc\n\n    def _parse_filters(\n        self,\n        *,\n        ids: Optional[List[str]] = None,\n        filters: Optional[Dict[str, Any]] = None,\n    ) -&gt; Optional[OperatorAST]:\n        \"\"\"\n        Utility method which combines different filters in order to build a final one to be sent to `Neo4jClient`\n        for execution. `FilterParser` will parse given `filters` as well as additional conditions (e.g. `ids`)\n        and combine all those into a final syntax tree with `FilterParser.combine` (by default combines filters\n        with `OP_AND` operator).\n\n        Args:\n            ids: Optional list of document ids to create a corresponding filter's ``IN`` expression,\n                e.g. ``\"ids IN ['id1', 'id2']\"``\n            filters: Filters to be parsed by `FilterParser.parse` in order to build a syntax tree.\n\n        Returns:\n            A syntax tree representing `filters` with additional conditions if any. `None` if none of conditions\n            are defined.\n        \"\"\"\n        ids_ast = self.filter_parser.comparison_op(\"id\", COMPARISON_OPS.OP_IN, ids) if ids else None\n        filter_ast = self.filter_parser.parse(filters) if filters else None\n\n        return self.filter_parser.combine(ids_ast, filter_ast)\n\n    def _neo4j_record_to_document(self, record: Neo4jRecord) -&gt; Document:\n        \"\"\"\n        Creates `Document` from Neo4j record (`dict`).\n        \"\"\"\n        return Document.from_dict(record)\n\n    def _document_to_neo4j_record(self, document: Document) -&gt; Neo4jRecord:\n        \"\"\"\n        Creates Neo4j record (`dict`) from a `Document` using a configured marshaller. Please notice `meta` fields will\n        be stored on same level as `Document` fields. **Such logic assumes attribute names (keys) do not clash**.\n        \"\"\"\n        return self.document_marshaller.marshal(document)\n\n    def _scale_to_unit_interval(self, score: float) -&gt; float:\n        return (score + 1) / 2 if self.similarity == \"cosine\" else float(1 / (1 + np.exp(-score / 100)))\n\n    def __del__(self):\n        self.neo4j_client.close_driver()\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    url: Optional[str] = DEFAULT_NEO4J_URI,\n    database: Optional[str] = DEFAULT_NEO4J_DATABASE,\n    username: Optional[str] = DEFAULT_NEO4J_USERNAME,\n    password: Optional[str] = DEFAULT_NEO4J_PASSWORD,\n    client_config: Optional[Neo4jClientConfig] = None,\n    index: str = \"document-embeddings\",\n    node_label: str = \"Document\",\n    embedding_dim: int = 768,\n    embedding_field: str = \"embedding\",\n    similarity: str = \"cosine\",\n    progress_bar: bool = False,\n    create_index_if_missing: Optional[bool] = True,\n    recreate_index: Optional[bool] = False,\n    write_batch_size: int = 100,\n    verify_connectivity: Optional[bool] = True,\n    document_marshaller: Optional[QueryParametersMarshaller] = None,\n    neo4j_client: Optional[Neo4jClient] = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>Optional[str]</code>, default:                   <code>DEFAULT_NEO4J_URI</code> )           \u2013            <p>URI pointing to Neo4j instance see (https://neo4j.com/docs/api/python-driver/current/api.html#uri)</p> </li> <li> <code>database</code>               (<code>Optional[str]</code>, default:                   <code>DEFAULT_NEO4J_DATABASE</code> )           \u2013            <p>Neo4j database to interact with.</p> </li> <li> <code>username</code>               (<code>Optional[str]</code>, default:                   <code>DEFAULT_NEO4J_USERNAME</code> )           \u2013            <p>Username to authenticate with the database.</p> </li> <li> <code>password</code>               (<code>Optional[str]</code>, default:                   <code>DEFAULT_NEO4J_PASSWORD</code> )           \u2013            <p>Password credential for the given username.</p> </li> <li> <code>client_config</code>               (<code>Optional[Neo4jClientConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Advanced client configuration to control various settings of underlying neo4j python driver. See <code>Neo4jClientConfig</code> for more details. The mandatory <code>url</code> attribute will be set on the <code>client_config</code> in case it was provided in the config itself.</p> </li> <li> <code>index</code>               (<code>str</code>, default:                   <code>'document-embeddings'</code> )           \u2013            <p>The name of Neo4j Vector Search Index used for storing and querying embeddings.</p> </li> <li> <code>node_label</code>               (<code>str</code>, default:                   <code>'Document'</code> )           \u2013            <p>The name of the label used in Neo4j to represent <code>haystack.Document</code>. Neo4j nodes are used primarily as storage for Document attributes and metadata filtering. The filtering process includes <code>node_label</code> in database queries (e.g. <code>MATCH (doc:&lt;node_label&gt;) RETURN doc</code>). Together with the <code>self.index</code> it identifies where documents are located in the database.</p> </li> <li> <code>embedding_dim</code>               (<code>int</code>, default:                   <code>768</code> )           \u2013            <p>embedding dimension specified for the Vector search index.</p> </li> <li> <code>embedding_field</code>               (<code>str</code>, default:                   <code>'embedding'</code> )           \u2013            <p>the name of embedding field which is created as a Neo4j node property containing an embedding vector. By default it is the same as in <code>haystack.schema.Document</code>. It is used during index creation and querying embeddings.</p> </li> <li> <code>similarity</code>               (<code>str</code>, default:                   <code>'cosine'</code> )           \u2013            <p>similarity function specified during Vector search index creation. Supported values are \"cosine\" and \"l2\".</p> </li> <li> <code>progress_bar</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shows a tqdm progress bar.</p> </li> <li> <code>create_index_if_missing</code>               (<code>Optional[bool]</code>, default:                   <code>True</code> )           \u2013            <p>Will create vector index during class initialization if it is not yet available in the <code>database</code>. Will only take effect if <code>recreate_index</code> is not <code>True</code>.</p> </li> <li> <code>recreate_index</code>               (<code>Optional[bool]</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code> will delete existing index and its data (documents) and create a new index. Useful for testing purposes when a new DocumentStore initializes with a clean database state.</p> </li> <li> <code>write_batch_size</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Number of documents to write at once. When working with large number of documents batching can help reduce memory footprint.</p> </li> <li> <code>verify_connectivity</code>               (<code>Optional[bool]</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code> will check connection to the database using provided credentials during creation of the Document Store.</p> </li> <li> <code>document_marshaller</code>               (<code>Optional[QueryParametersMarshaller]</code>, default:                   <code>None</code> )           \u2013            <p>A custom marshaller, if provided, to convert <code>haystack.Document</code> to a dictionary to be stored as Neo4j node properties. Neo4j can not store nested properties in a node so this customization point should be used in rare occasions in case default implementation (see <code>_DefaultDocumentMarshaller</code>) is not sufficient.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>In case similarity function specified is not supported</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = DEFAULT_NEO4J_URI,\n    database: Optional[str] = DEFAULT_NEO4J_DATABASE,\n    username: Optional[str] = DEFAULT_NEO4J_USERNAME,\n    password: Optional[str] = DEFAULT_NEO4J_PASSWORD,\n    client_config: Optional[Neo4jClientConfig] = None,\n    index: str = \"document-embeddings\",\n    node_label: str = \"Document\",\n    embedding_dim: int = 768,\n    embedding_field: str = \"embedding\",\n    similarity: str = \"cosine\",\n    progress_bar: bool = False,\n    create_index_if_missing: Optional[bool] = True,\n    recreate_index: Optional[bool] = False,\n    write_batch_size: int = 100,\n    verify_connectivity: Optional[bool] = True,\n    document_marshaller: Optional[QueryParametersMarshaller] = None,\n    neo4j_client: Optional[Neo4jClient] = None,\n):\n    \"\"\"\n    Constructor method\n\n    Args:\n        url: URI pointing to Neo4j instance see (https://neo4j.com/docs/api/python-driver/current/api.html#uri)\n        database: Neo4j database to interact with.\n        username: Username to authenticate with the database.\n        password: Password credential for the given username.\n        client_config: Advanced client configuration to control various settings of underlying neo4j python\n            driver. See `Neo4jClientConfig` for more details. The mandatory `url` attribute will be set on\n            the `client_config` in case it was provided in the config itself.\n        index: The name of Neo4j Vector Search Index used for storing and querying embeddings.\n        node_label: The name of the label used in Neo4j to represent `haystack.Document`.\n            Neo4j nodes are used primarily as storage for Document attributes and metadata filtering.\n            The filtering process includes `node_label` in database queries (e.g.\n            `:::cypher MATCH (doc:&lt;node_label&gt;) RETURN doc`). Together with the `self.index` it identifies where\n            documents are located in the database.\n        embedding_dim: embedding dimension specified for the Vector search index.\n        embedding_field: the name of embedding field which is created as a Neo4j node property containing an\n            embedding vector. By default it is the same as in `haystack.schema.Document`. It is used during\n            index creation and querying embeddings.\n        similarity: similarity function specified during Vector search index creation. Supported values are\n            \"cosine\" and \"l2\".\n        progress_bar: Shows a tqdm progress bar.\n        create_index_if_missing: Will create vector index during class initialization if it is not yet available\n            in the `database`. Will only take effect if `recreate_index` is not `True`.\n        recreate_index: If `True` will delete existing index and its data (documents) and create a new\n            index. Useful for testing purposes when a new DocumentStore initializes with a clean database state.\n        write_batch_size: Number of documents to write at once. When working with large number of documents\n            batching can help reduce memory footprint.\n        verify_connectivity: If `True` will check connection to the database using provided credentials during\n            creation of the Document Store.\n        document_marshaller: A custom marshaller, if provided, to convert `haystack.Document` to a dictionary to be\n            stored as Neo4j node properties. **Neo4j can not store nested properties in a node** so this\n            customization point should be used in rare occasions in case default implementation\n            (see `_DefaultDocumentMarshaller`) is not sufficient.\n\n    Raises:\n        ValueError: In case similarity function specified is not supported\n    \"\"\"\n\n    super().__init__()\n\n    self.index = index\n    self.node_label = node_label\n    self.embedding_dim = embedding_dim\n    self.embedding_field = embedding_field\n\n    self.similarity = similarity\n    self.similarity_function = self._get_distance(similarity)\n\n    self.progress_bar = progress_bar\n    self.create_index_if_missing = create_index_if_missing\n    self.recreate_index = recreate_index\n    self.write_batch_size = write_batch_size\n    self.verify_connectivity = verify_connectivity\n\n    self.document_marshaller = document_marshaller or _DefaultDocumentMarshaller()\n\n    self.filter_parser = FilterParser()\n\n    if neo4j_client:\n        self.neo4j_client = neo4j_client\n    else:\n        if client_config and not client_config.url:\n            client_config.url = url\n        self.client_config = client_config or Neo4jClientConfig(url, database, username, password)\n        self.neo4j_client = Neo4jClient(self.client_config)\n\n    if verify_connectivity:\n        self.neo4j_client.verify_connectivity()\n\n    if recreate_index:\n        self.delete_index()\n        self.create_index()\n    elif create_index_if_missing:\n        self.neo4j_client.create_index_if_missing(\n            self.index, self.node_label, self.embedding_field, self.embedding_dim, self.similarity_function\n        )\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Serializes this store to a dictionary.</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serializes this store to a dictionary.\n    \"\"\"\n    data = default_to_dict(\n        self,\n        index=self.index,\n        node_label=self.node_label,\n        embedding_dim=self.embedding_dim,\n        embedding_field=self.embedding_field,\n        similarity=self.similarity,\n        progress_bar=self.progress_bar,\n        create_index_if_missing=self.create_index_if_missing,\n        recreate_index=self.recreate_index,\n        write_batch_size=self.write_batch_size,\n        verify_connectivity=self.verify_connectivity,\n    )\n\n    data[\"init_parameters\"][\"client_config\"] = self.client_config.to_dict()\n\n    return data\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Neo4jDocumentStore\n</code></pre> <p>Deserializes the store from a dictionary.</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Neo4jDocumentStore\":\n    \"\"\"\n    Deserializes the store from a dictionary.\n    \"\"\"\n    client_config = Neo4jClientConfig.from_dict(data[\"init_parameters\"][\"client_config\"])\n    data[\"init_parameters\"][\"client_config\"] = client_config\n\n    return default_from_dict(cls, data)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.count_documents","title":"count_documents","text":"<pre><code>count_documents() -&gt; int\n</code></pre> <p>Returns the number of documents stored.</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def count_documents(self) -&gt; int:\n    \"\"\"\n    Returns the number of documents stored.\n    \"\"\"\n    return self.count_documents_with_filter()\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.filter_documents","title":"filter_documents","text":"<pre><code>filter_documents(filters: Optional[FilterType] = None) -&gt; List[Document]\n</code></pre> <p>Returns the documents that match the filters provided.</p> <p>Parameters:</p> <ul> <li> <code>filters</code>               (<code>Optional[FilterType]</code>, default:                   <code>None</code> )           \u2013            <p>Optional filters to narrow down the documents which should be returned. Learn more about filtering syntax in Metadata Filtering.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Document]</code>           \u2013            <p>A list of found documents.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def filter_documents(self, filters: Optional[FilterType] = None) -&gt; List[Document]:\n    \"\"\"\n    Returns the documents that match the filters provided.\n\n    Args:\n        filters: Optional filters to narrow down the documents which should be returned.\n            Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n\n    Returns:\n        A list of found documents.\n    \"\"\"\n    return list(self.get_all_documents_generator(filters, return_embedding=True))\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.write_documents","title":"write_documents","text":"<pre><code>write_documents(\n    documents: List[Document], policy: DuplicatePolicy = DuplicatePolicy.NONE\n) -&gt; int\n</code></pre> <p>Writes documents to the DocumentStore.</p> <p>Parameters:</p> <ul> <li> <code>documents</code>               (<code>List[Document]</code>)           \u2013            <p>List of <code>haystack.Document</code>. If they already contain the embeddings, we'll index them right away in Neo4j. If not, you can later call <code>update_embeddings</code> to create and index them.</p> </li> <li> <code>policy</code>               (<code>DuplicatePolicy</code>, default:                   <code>NONE</code> )           \u2013            <p>Handle duplicates document based on parameter options. Parameter options:</p> <ul> <li><code>SKIP</code>: Ignore the duplicates documents.</li> <li><code>OVERWRITE</code>: Update any existing documents with the same ID when adding documents.</li> <li><code>FAIL</code>: An error is raised if the document ID of the document being added already exists</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>DuplicateDocumentError</code>             \u2013            <p>Exception triggers on duplicate document.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If <code>documents</code> parameter is not a list of of type <code>haystack.Document</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of written documents.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def write_documents(\n    self,\n    documents: List[Document],\n    policy: DuplicatePolicy = DuplicatePolicy.NONE,\n) -&gt; int:\n    \"\"\"\n    Writes documents to the DocumentStore.\n\n    Args:\n        documents: List of `haystack.Document`. If they already contain the embeddings, we'll index\n            them right away in Neo4j. If not, you can later call `update_embeddings` to create and index them.\n        policy: Handle duplicates document based on parameter options. Parameter options:\n\n            - `SKIP`: Ignore the duplicates documents.\n            - `OVERWRITE`: Update any existing documents with the same ID when adding documents.\n            - `FAIL`: An error is raised if the document ID of the document being added already exists\n\n    Raises:\n        DuplicateDocumentError: Exception triggers on duplicate document.\n        ValueError: If `documents` parameter is not a list of of type `haystack.Document`.\n\n    Returns:\n        Number of written documents.\n    \"\"\"\n\n    for doc in documents:\n        if not isinstance(doc, Document):\n            msg = f\"DocumentStore.write_documents() expects a list of Documents but got an element of {type(doc)}.\"\n            raise ValueError(msg)\n\n    if len(documents) == 0:\n        logger.warning(\"Calling Neo4jDocumentStore.write_documents() with an empty list\")\n        return 0\n\n    batch_size = self.write_batch_size\n    document_objects = self._handle_duplicate_documents(documents, policy)\n\n    documents_written = 0\n    batched_documents = get_batches_from_generator(document_objects, batch_size)\n    with tqdm(\n        total=len(document_objects),\n        desc=f\"Write Documents&lt;index: {self.index},node_label: {self.node_label}&gt;\",\n        unit=\" docs\",\n        disable=not self.progress_bar,\n    ) as progress_bar:\n        for document_batch in batched_documents:\n            records = [self._document_to_neo4j_record(doc) for doc in document_batch]\n            embedding_field = self.embedding_field\n            self.neo4j_client.merge_nodes(self.node_label, embedding_field, records)\n            documents_written += len(records)\n            progress_bar.update(batch_size)\n\n    return documents_written\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.delete_documents","title":"delete_documents","text":"<pre><code>delete_documents(document_ids: List[str]) -&gt; None\n</code></pre> <p>Deletes all documents with a matching document_ids from the DocumentStore. Fails with <code>MissingDocumentError</code> if no document with this id is present in the DocumentStore.</p> <p>Parameters:</p> <ul> <li> <code>document_ids</code>               (<code>List[str]</code>)           \u2013            <p>Document ids of documents to be removed.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def delete_documents(self, document_ids: List[str]) -&gt; None:\n    \"\"\"\n    Deletes all documents with a matching document_ids from the DocumentStore.\n    Fails with `MissingDocumentError` if no document with this id is present in the DocumentStore.\n\n    Args:\n        document_ids: Document ids of documents to be removed.\n    \"\"\"\n    self.delete_all_documents(document_ids)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.update_embeddings","title":"update_embeddings","text":"<pre><code>update_embeddings(documents: List[Document], batch_size: int = 100)\n</code></pre> <p>Updates the embeddings in the document store for given <code>documents</code>. This can be useful if want to add or change the embeddings for your documents (e.g. after changing the embedder configuration).</p> <p>Parameters:</p> <ul> <li> <code>documents</code>               (<code>List[Document]</code>)           \u2013            <p>Documents with non-null embeddings to be updated.</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>When working with large number of documents, batching can help reduce memory footprint.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def update_embeddings(\n    self,\n    documents: List[Document],\n    batch_size: int = 100,\n):\n    \"\"\"\n    Updates the embeddings in the document store for given `documents`.\n    This can be useful if want to add or change the embeddings for your documents (e.g. after changing the embedder\n    configuration).\n\n    Args:\n        documents: Documents with non-null embeddings to be updated.\n        batch_size: When working with large number of documents, batching can help reduce memory footprint.\n    \"\"\"\n\n    document_count = len(documents)\n    logger.debug(\"Updating embeddings for %s docs...\", document_count)\n\n    with tqdm(\n        total=document_count, disable=not self.progress_bar, unit=\" docs\", desc=\"Updating embeddings\"\n    ) as progress_bar:\n        for document_batch in get_batches_from_generator(documents, batch_size):\n            only_embeddings = [{\"id\": doc.id, self.embedding_field: doc.embedding} for doc in document_batch]\n\n            self.neo4j_client.update_embedding(\n                self.node_label,\n                self.embedding_field,\n                only_embeddings,\n            )\n\n            progress_bar.update(batch_size)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.get_all_documents_generator","title":"get_all_documents_generator","text":"<pre><code>get_all_documents_generator(\n    filters: Optional[FilterType] = None,\n    return_embedding: Optional[bool] = None,\n    batch_size: int = 1000,\n) -&gt; Generator[Document, None, None]\n</code></pre> <p>Get all documents from the document store. Under-the-hood, documents are fetched in batches from the document store and yielded as individual documents. This method can be used to iteratively process a large number of documents without having to load all documents in memory. Such mechanism is natively supported by underlying Neo4j Python Driver (an internal buffer which is depleted while being read and filled up while data is coming from the database)</p> <p>Parameters:</p> <ul> <li> <code>filters</code>               (<code>Optional[FilterType]</code>, default:                   <code>None</code> )           \u2013            <p>Optional filters to narrow down the documents which should be returned. Learn more about filtering syntax in Metadata Filtering.</p> </li> <li> <code>return_embedding</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>To return document embedding. By default is <code>None</code> which should reduce amount of data returned (considering embeddings are usually large in size)</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>When working with large number of documents, batching can help reduce memory footprint. This parameter controls how many documents are retrieved at once from Neo4j.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>A Generator of found documents.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def get_all_documents_generator(\n    self,\n    filters: Optional[FilterType] = None,\n    return_embedding: Optional[bool] = None,\n    batch_size: int = 1000,\n) -&gt; Generator[Document, None, None]:\n    \"\"\"\n    Get all documents from the document store. Under-the-hood, documents are fetched in batches from the\n    document store and yielded as individual documents. This method can be used to iteratively process\n    a large number of documents without having to load all documents in memory. Such mechanism is natively\n    supported by underlying Neo4j Python Driver (an internal buffer which is depleted while being read and filled\n    up while data is coming from the database)\n\n    Args:\n        filters: Optional filters to narrow down the documents which should be returned.\n            Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n        return_embedding: To return document embedding. By default is `None` which should reduce amount of data\n            returned (considering embeddings are usually large in size)\n        batch_size: When working with large number of documents, batching can help reduce memory footprint.\n            This parameter controls how many documents are retrieved at once from Neo4j.\n\n    Returns:\n        A Generator of found documents.\n    \"\"\"\n\n    filter_ast = self._parse_filters(filters=filters)\n    skip_properties = [] if return_embedding else [self.embedding_field]\n\n    records = self.neo4j_client.find_nodes(self.node_label, filter_ast, skip_properties, fetch_size=batch_size)\n\n    return (self._neo4j_record_to_document(rec) for rec in records)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.get_document_by_id","title":"get_document_by_id","text":"<pre><code>get_document_by_id(document_id: str) -&gt; Optional[Document]\n</code></pre> <p>Retrieves a document by its <code>id</code>.</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>id of the Document to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Document]</code>           \u2013            <p>A found document with matching <code>document_id</code> if exactly one is found, otherwise <code>None</code> is returned</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def get_document_by_id(self, document_id: str) -&gt; Optional[Document]:\n    \"\"\"\n    Retrieves a document by its `id`.\n\n    Args:\n        document_id: id of the Document to retrieve.\n\n    Returns:\n        A found document with matching `document_id` if exactly one is found, otherwise `None` is returned\n    \"\"\"\n\n    records = self.get_documents_by_id([document_id])\n    number_found = len(records)\n\n    if number_found &gt; 1:\n        logger.warn(\n            f\"get_document_by_id: Found more than one document for a given id(`{id}`). \"\n            \"Expected: 1, Found: {number_found}. Please make sure your data has unique ids\"\n        )\n\n    return records[0] if number_found &gt; 0 else None\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.get_documents_by_id","title":"get_documents_by_id","text":"<pre><code>get_documents_by_id(\n    document_ids: List[str], batch_size: int = 1000\n) -&gt; List[Document]\n</code></pre> <p>Retrieves all documents using their ids.</p> <p>Parameters:</p> <ul> <li> <code>document_ids</code>               (<code>List[str]</code>)           \u2013            <p>List of ids to retrieve.</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of documents to retrieve at a time. When working with large number of documents, batching can help reduce memory footprint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Document]</code>           \u2013            <p>List of found Documents.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def get_documents_by_id(\n    self,\n    document_ids: List[str],\n    batch_size: int = 1_000,\n) -&gt; List[Document]:\n    \"\"\"\n    Retrieves all documents using their ids.\n\n    Args:\n        document_ids: List of ids to retrieve.\n        batch_size: Number of documents to retrieve at a time. When working with large number of documents,\n            batching can help reduce memory footprint.\n\n    Returns:\n        List of found Documents.\n    \"\"\"\n\n    documents: List[Document] = []\n    for batch_ids in get_batches_from_generator(document_ids, batch_size):\n        filter_ast = self.filter_parser.comparison_op(\"id\", COMPARISON_OPS.OP_IN, list(batch_ids))\n        records = self.neo4j_client.find_nodes(self.node_label, filter_ast)\n        documents.extend([self._neo4j_record_to_document(rec) for rec in records])\n\n    return documents\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.count_documents_with_filter","title":"count_documents_with_filter","text":"<pre><code>count_documents_with_filter(filters: Optional[FilterType] = None) -&gt; int\n</code></pre> <p>Return the count of filtered documents in the document store.</p> <p>Parameters:</p> <ul> <li> <code>filters</code>               (<code>Optional[FilterType]</code>, default:                   <code>None</code> )           \u2013            <p>Narrow down the documents which should be counted. Learn more about filtering syntax in Metadata Filtering.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Found documents count with respective filters applied.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def count_documents_with_filter(\n    self,\n    filters: Optional[FilterType] = None,\n) -&gt; int:\n    \"\"\"\n    Return the count of filtered documents in the document store.\n\n    Args:\n        filters: Narrow down the documents which should be counted.\n            Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n\n    Returns:\n        Found documents count with respective filters applied.\n    \"\"\"\n\n    filter_ast = self._parse_filters(filters=filters)\n\n    return self.neo4j_client.count_nodes(self.node_label, filter_ast)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.query_by_embedding","title":"query_by_embedding","text":"<pre><code>query_by_embedding(\n    query_embedding: List[float],\n    filters: Optional[Dict[str, Any]] = None,\n    top_k: int = 10,\n    return_embedding: Optional[bool] = None,\n    scale_score: bool = True,\n    expand_top_k: Optional[int] = None,\n) -&gt; List[Document]\n</code></pre> <p>Find the document that is most similar to the provided <code>query_emb</code> by using a vector similarity metric.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>Embedding of the query (e.g. gathered from Dense Retrievers)</p> </li> <li> <code>filters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional filters to narrow down the documents which should be returned after vector search. Learn more about filtering syntax in Metadata Filtering. Vector search happens first yielding <code>top_k</code> results, filtering is applied afterwards. Use <code>expand_top_k</code> parameter to increase amount of documents retrieved from <code>index</code> (<code>expand_top_k</code> take precedence if provided), filtering will make sure to return <code>top_k</code> out of <code>expand_top_k</code> documents ordered by score.</p> </li> <li> <code>top_k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>How many documents to return.</p> </li> <li> <code>return_embedding</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>To return document embedding. By default is <code>None</code> which should reduce amount of data returned (considering embeddings are usually large in size)</p> </li> <li> <code>scale_score</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to scale the similarity score to the unit interval (range of [0,1]). If true (default) similarity scores (e.g. cosine or dot_product) which naturally have a different value range will be scaled to a range of [0,1], where 1 means extremely relevant. Otherwise raw similarity scores (e.g. cosine or dot_product) will be used.</p> </li> <li> <code>expand_top_k</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The value will override <code>top_k</code> for vector search if provided. Should be used in case <code>filters</code> are expected to be applied on a greater amount of documents. After filtering takes place <code>top_k</code> documents retrieved ordered by score.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Document]</code>           \u2013            <p>Found <code>top_k</code> documents.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def query_by_embedding(\n    self,\n    query_embedding: List[float],\n    filters: Optional[Dict[str, Any]] = None,\n    top_k: int = 10,\n    return_embedding: Optional[bool] = None,\n    scale_score: bool = True,\n    expand_top_k: Optional[int] = None,\n) -&gt; List[Document]:\n    \"\"\"\n    Find the document that is most similar to the provided `query_emb` by using a vector similarity metric.\n\n    Args:\n        query_embedding: Embedding of the query (e.g. gathered from Dense Retrievers)\n        filters: Optional filters to narrow down the documents which should be returned after vector search.\n            Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n            Vector search happens first yielding `top_k` results, filtering is applied afterwards. Use\n            `expand_top_k` parameter to increase amount of documents retrieved from `index` (`expand_top_k` take\n            precedence if provided), filtering will make sure to return `top_k` out of `expand_top_k` documents\n            ordered by score.\n        top_k: How many documents to return.\n        return_embedding: To return document embedding. By default is `None` which should reduce amount of data\n            returned (considering embeddings are usually large in size)\n        scale_score: Whether to scale the similarity score to the unit interval (range of [0,1]).\n            If true (default) similarity scores (e.g. cosine or dot_product) which naturally have a different value\n            range will be scaled to a range of [0,1], where 1 means extremely relevant. Otherwise raw similarity\n            scores (e.g. cosine or dot_product) will be used.\n        expand_top_k: The value will override `top_k` for vector search if provided. Should be used in case\n            `filters` are expected to be applied on a greater amount of documents. After filtering takes place\n            `top_k` documents retrieved ordered by score.\n\n    Returns:\n        Found `top_k` documents.\n    \"\"\"\n\n    filter_ast = self._parse_filters(filters=filters)\n    skip_properties = [] if return_embedding else [self.embedding_field]\n\n    records = self.neo4j_client.query_embeddings(\n        self.index, top_k, query_embedding, filter_ast, skip_properties, expand_top_k\n    )\n    results = [self._neo4j_record_to_document(rec) for rec in records]\n\n    if scale_score:\n        for document in results:\n            document.score = self._scale_to_unit_interval(document.score)\n\n    return results\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.delete_all_documents","title":"delete_all_documents","text":"<pre><code>delete_all_documents(\n    document_ids: Optional[List[str]] = None,\n    filters: Optional[Dict[str, Any]] = None,\n)\n</code></pre> <p>Delete documents from the document store. All documents will be deleted, in case either <code>filters</code> or <code>document_ids</code> are defined only filtered subset will be deleted.</p> <p>Parameters:</p> <ul> <li> <code>document_ids</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of document ids to narrow down the documents to be deleted.</p> </li> <li> <code>filters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional filters to narrow down the documents which should be deleted. Learn more about filtering syntax in Metadata Filtering.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def delete_all_documents(\n    self,\n    document_ids: Optional[List[str]] = None,\n    filters: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Delete documents from the document store. All documents will be deleted, in case either `filters` or\n    `document_ids` are defined only filtered subset will be deleted.\n\n    Args:\n        document_ids: Optional list of document ids to narrow down the documents to be deleted.\n        filters: Optional filters to narrow down the documents which should be deleted.\n            Learn more about filtering syntax in [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n    \"\"\"\n\n    filter_ast = self._parse_filters(ids=document_ids, filters=filters)\n    self.neo4j_client.delete_nodes(self.node_label, filter_ast)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.delete_index","title":"delete_index","text":"<pre><code>delete_index()\n</code></pre> <p>Deletes an existing index. The index including all data will be removed. The implementation deletes the index itself as well as all nodes having <code>self.node_label</code> label</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def delete_index(self):\n    \"\"\"\n    Deletes an existing index. The index including all data will be removed. The implementation deletes the index\n    itself as well as all nodes having `self.node_label` label\n    \"\"\"\n\n    try:\n        self.neo4j_client.delete_index(self.index)\n    except DatabaseError as err:\n        if err.code == \"Neo.DatabaseError.Schema.IndexDropFailed\":\n            logger.debug(\"Could not remove index `{index}`. Most probably it does not exist.\")\n        else:\n            raise\n\n    self.delete_all_documents()\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore.update_document_meta","title":"update_document_meta","text":"<pre><code>update_document_meta(document_id: str, meta: Dict[str, Any])\n</code></pre> <p>Updates metadata properties in Neo4j for a Document found by its <code>document_id</code>. Please see details on how properties in nodes are being mutated in Neo4j for a given <code>meta</code> dictionary (https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map)</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>The Document id to update in Neo4j</p> </li> <li> <code>meta</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Dictionary of new metadata. Will replace property values in case those already exist in the corresponding Neo4j node. Please notice it is assumed Document metadata has same schema (e.g. same amount of properties and its names) as in originally created nodes in Neo4j. Otherwise some side effects might be produced (e.g. a property is renamed in <code>meta</code> which leaves an old one in Neo4j).</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def update_document_meta(self, document_id: str, meta: Dict[str, Any]):\n    \"\"\"\n    Updates metadata properties in Neo4j for a Document found by its `document_id`. Please see details on how\n    properties in nodes are being mutated in Neo4j for a given `meta` dictionary (https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map)\n\n    Args:\n        document_id: The Document id to update in Neo4j\n        meta: Dictionary of new metadata. Will replace property values in case those already exist in the\n            corresponding Neo4j node. Please notice it is assumed Document metadata has same schema (e.g. same\n            amount of properties and its names) as in originally created nodes in Neo4j. Otherwise some side effects\n            might be produced (e.g. a property is renamed in `meta` which leaves an old one in Neo4j).\n    \"\"\"\n\n    updated_record = self.neo4j_client.update_node(self.node_label, document_id, meta)\n\n    if not updated_record:\n        logger.warning(\n            \"update_document_meta: Could not find document with id(%s) to update its meta attributes. \"\n            \"Please check if provided id is valid\",\n            document_id,\n        )\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore._handle_duplicate_documents","title":"_handle_duplicate_documents","text":"<pre><code>_handle_duplicate_documents(\n    documents: List[Document], policy: DuplicatePolicy = None\n)\n</code></pre> <p>Checks whether any of the passed documents is already existing in the chosen index and returns a list of documents that are not in the index yet.</p> <p>:param documents: A list of Haystack Document objects. :param policy: Handle duplicates document based on parameter options.                             Parameter options : ( 'skip','overwrite','fail')                             skip (default option): Ignore the duplicates documents                             overwrite: Update any existing documents with the same ID when adding documents.                             fail: an error is raised if the document ID of the document being added already                             exists. :return: A list of <code>haystack.Document</code> objects.</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def _handle_duplicate_documents(\n    self,\n    documents: List[Document],\n    policy: DuplicatePolicy = None,\n):\n    \"\"\"\n    Checks whether any of the passed documents is already existing in the chosen index and returns a list of\n    documents that are not in the index yet.\n\n    :param documents: A list of Haystack Document objects.\n    :param policy: Handle duplicates document based on parameter options.\n                                Parameter options : ( 'skip','overwrite','fail')\n                                skip (default option): Ignore the duplicates documents\n                                overwrite: Update any existing documents with the same ID when adding documents.\n                                fail: an error is raised if the document ID of the document being added already\n                                exists.\n    :return: A list of `haystack.Document` objects.\n    \"\"\"\n\n    if policy in (DuplicatePolicy.SKIP, DuplicatePolicy.FAIL):\n        documents = self._drop_duplicate_documents(documents)\n        documents_found = self.get_documents_by_id(document_ids=[doc.id for doc in documents])\n        ids_exist_in_db: List[str] = [doc.id for doc in documents_found]\n\n        if len(ids_exist_in_db) &gt; 0 and policy == DuplicatePolicy.FAIL:\n            msg = f\"Document with ids '{', '.join(ids_exist_in_db)} already exists in index = '{self.index}'.\"\n            raise DuplicateDocumentError(msg)\n\n        documents = list(filter(lambda doc: doc.id not in ids_exist_in_db, documents))\n\n    return documents\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore._drop_duplicate_documents","title":"_drop_duplicate_documents","text":"<pre><code>_drop_duplicate_documents(documents: List[Document]) -&gt; List[Document]\n</code></pre> <p>Drop duplicates documents based on same hash ID</p> <p>:param documents: A list of Haystack Document objects. :param index: name of the index :return: A list of Haystack Document objects.</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def _drop_duplicate_documents(self, documents: List[Document]) -&gt; List[Document]:\n    \"\"\"\n    Drop duplicates documents based on same hash ID\n\n    :param documents: A list of Haystack Document objects.\n    :param index: name of the index\n    :return: A list of Haystack Document objects.\n    \"\"\"\n    _hash_ids: Set = set()\n    _documents: List[Document] = []\n\n    for document in documents:\n        if document.id in _hash_ids:\n            logger.info(\n                \"Duplicate Documents: Document with id '%s' already exists in index '%s'\",\n                document.id,\n                self.index,\n            )\n            continue\n        _documents.append(document)\n        _hash_ids.add(document.id)\n\n    return _documents\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore._get_distance","title":"_get_distance","text":"<pre><code>_get_distance(similarity: str) -&gt; SimilarityFunction\n</code></pre> <p>Validates similarity function so that it is supported by neo4j vector index. Only \"cosine\" and \"l2\" are supported aat the moment.</p> <p>Parameters:</p> <ul> <li> <code>similarity</code>               (<code>str</code>)           \u2013            <p>Common similarity values accepted by DocumentStores in Haystack, e.g. \"cosine\", \"dot_product\", \"l2\".</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If given similarity is not supported by neo4j.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SimilarityFunction</code>           \u2013            <p>Similarity function supported by Neo4j vector index (\"cosine\" or \"euclidean\").</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def _get_distance(self, similarity: str) -&gt; SimilarityFunction:\n    \"\"\"\n    Validates similarity function so that it is supported by neo4j vector index.\n    Only \"cosine\" and \"l2\" are supported aat the moment.\n\n    Args:\n        similarity: Common similarity values accepted by DocumentStores in Haystack,\n            e.g. \"cosine\", \"dot_product\", \"l2\".\n\n    Raises:\n        ValueError: If given similarity is not supported by neo4j.\n\n    Returns:\n        Similarity function supported by Neo4j vector index (\"cosine\" or \"euclidean\").\n    \"\"\"\n    try:\n        return self.SIMILARITY_MAP[similarity]\n    except KeyError as exc:\n        raise ValueError(\n            f\"Provided similarity '{similarity}' is not supported by Neo4jDocumentStore. \"\n            f\"Please choose one of the options: {', '.join(self.SIMILARITY_MAP.keys())}\"\n        ) from exc\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore._parse_filters","title":"_parse_filters","text":"<pre><code>_parse_filters(\n    *, ids: Optional[List[str]] = None, filters: Optional[Dict[str, Any]] = None\n) -&gt; Optional[OperatorAST]\n</code></pre> <p>Utility method which combines different filters in order to build a final one to be sent to <code>Neo4jClient</code> for execution. <code>FilterParser</code> will parse given <code>filters</code> as well as additional conditions (e.g. <code>ids</code>) and combine all those into a final syntax tree with <code>FilterParser.combine</code> (by default combines filters with <code>OP_AND</code> operator).</p> <p>Parameters:</p> <ul> <li> <code>ids</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of document ids to create a corresponding filter's <code>IN</code> expression, e.g. <code>\"ids IN ['id1', 'id2']\"</code></p> </li> <li> <code>filters</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Filters to be parsed by <code>FilterParser.parse</code> in order to build a syntax tree.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[OperatorAST]</code>           \u2013            <p>A syntax tree representing <code>filters</code> with additional conditions if any. <code>None</code> if none of conditions</p> </li> <li> <code>Optional[OperatorAST]</code>           \u2013            <p>are defined.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def _parse_filters(\n    self,\n    *,\n    ids: Optional[List[str]] = None,\n    filters: Optional[Dict[str, Any]] = None,\n) -&gt; Optional[OperatorAST]:\n    \"\"\"\n    Utility method which combines different filters in order to build a final one to be sent to `Neo4jClient`\n    for execution. `FilterParser` will parse given `filters` as well as additional conditions (e.g. `ids`)\n    and combine all those into a final syntax tree with `FilterParser.combine` (by default combines filters\n    with `OP_AND` operator).\n\n    Args:\n        ids: Optional list of document ids to create a corresponding filter's ``IN`` expression,\n            e.g. ``\"ids IN ['id1', 'id2']\"``\n        filters: Filters to be parsed by `FilterParser.parse` in order to build a syntax tree.\n\n    Returns:\n        A syntax tree representing `filters` with additional conditions if any. `None` if none of conditions\n        are defined.\n    \"\"\"\n    ids_ast = self.filter_parser.comparison_op(\"id\", COMPARISON_OPS.OP_IN, ids) if ids else None\n    filter_ast = self.filter_parser.parse(filters) if filters else None\n\n    return self.filter_parser.combine(ids_ast, filter_ast)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore._neo4j_record_to_document","title":"_neo4j_record_to_document","text":"<pre><code>_neo4j_record_to_document(record: Neo4jRecord) -&gt; Document\n</code></pre> <p>Creates <code>Document</code> from Neo4j record (<code>dict</code>).</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def _neo4j_record_to_document(self, record: Neo4jRecord) -&gt; Document:\n    \"\"\"\n    Creates `Document` from Neo4j record (`dict`).\n    \"\"\"\n    return Document.from_dict(record)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store.Neo4jDocumentStore._document_to_neo4j_record","title":"_document_to_neo4j_record","text":"<pre><code>_document_to_neo4j_record(document: Document) -&gt; Neo4jRecord\n</code></pre> <p>Creates Neo4j record (<code>dict</code>) from a <code>Document</code> using a configured marshaller. Please notice <code>meta</code> fields will be stored on same level as <code>Document</code> fields. Such logic assumes attribute names (keys) do not clash.</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def _document_to_neo4j_record(self, document: Document) -&gt; Neo4jRecord:\n    \"\"\"\n    Creates Neo4j record (`dict`) from a `Document` using a configured marshaller. Please notice `meta` fields will\n    be stored on same level as `Document` fields. **Such logic assumes attribute names (keys) do not clash**.\n    \"\"\"\n    return self.document_marshaller.marshal(document)\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store._DefaultDocumentMarshaller","title":"_DefaultDocumentMarshaller","text":"<p>               Bases: <code>QueryParametersMarshaller</code></p> <p>Default marshaller to convert <code>haystack.Document</code> before storing it in Neo4j node. As we can not store nested attributes in the node we make sure all nested fields (including <code>meta</code>) are flattened. Produced nested property names are concatenated with a given separator (e.g. \".\").</p> <p>Please take a look at             Property, structural, and constructed values         to better understand what values can be stored as properties.</p> <p>TODO: The logic can be improved so that nested attributes get stored as relations and nodes in Neo4j</p> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>class _DefaultDocumentMarshaller(QueryParametersMarshaller):\n    \"\"\"\n    Default marshaller to convert `haystack.Document` before storing it in Neo4j node.\n    As we can not store nested attributes in the node we make sure all nested fields (including `meta`) are flattened.\n    Produced nested property names are concatenated with a given separator (e.g. \".\").\n\n    Please take a look at \\\n            [Property, structural, and constructed values](https://neo4j.com/docs/cypher-manual/current/values-and-types/property-structural-constructed/)\n            to better understand what values can be stored as properties.\n\n    **TODO: The logic can be improved so that nested attributes get stored as relations and nodes in Neo4j**\n    \"\"\"\n\n    def __init__(self, property_separator=\".\"):\n        self.property_separator = property_separator\n\n    def supports(self, document: Any) -&gt; bool:\n        return isinstance(document, Document)\n\n    def marshal(self, document: Document) -&gt; Any:\n        \"\"\"\n        Converts `haystack.Document` by using `to_dict` method and then flattens any dictionary fields in case there\n        are any (in some cases such are being used in `meta` attributes). Once flattened we inspect attribute values\n        for unsupported types, e.g. custom types which are non-primitives. `list` of non-primitive types is skipped\n        when encountered.\n\n        Args:\n            document: The document to be converted to a Neo4j record.\n\n        Returns:\n            A document converted to a `dict` with flattened nested fields.\n        \"\"\"\n        converted_doc = document.to_dict(flatten=True)\n        doc_object = flatten_dict(converted_doc, separator=self.property_separator)\n\n        return self._exclude_non_serializable_objects(doc_object)\n\n    def _exclude_non_serializable_objects(self, doc_object: Dict[str, Any]):\n        obj_keys = list(doc_object.keys())\n        for prop_name in obj_keys:\n            if isinstance(doc_object[prop_name], (list, set, tuple)) and len(doc_object[prop_name]) &gt; 0:\n                value_seq = doc_object[prop_name]\n                first_value = value_seq[0]\n                is_simple = self._is_simple_neo4j_type(first_value)\n                is_homogeneous = True\n\n                if is_simple:\n                    for value in value_seq:\n                        if not isinstance(value, type(first_value)):\n                            is_homogeneous = False\n                            break\n\n                if not is_simple or not is_homogeneous:\n                    doc_object.pop(prop_name)\n                    logger.warning(\n                        \"At the moment nested (complex) objects are not allowed as `list` values in Document object. \"\n                        f\"Property `{prop_name}` will be skipped and not stored in Neo4j node\"\n                    )\n        return doc_object\n\n    def _is_simple_neo4j_type(self, obj: Any):\n        return isinstance(obj, (bool, str, int, float, type(None), bytes))\n</code></pre>"},{"location":"reference/neo4j_store/#neo4j_haystack.document_stores.neo4j_store._DefaultDocumentMarshaller.marshal","title":"marshal","text":"<pre><code>marshal(document: Document) -&gt; Any\n</code></pre> <p>Converts <code>haystack.Document</code> by using <code>to_dict</code> method and then flattens any dictionary fields in case there are any (in some cases such are being used in <code>meta</code> attributes). Once flattened we inspect attribute values for unsupported types, e.g. custom types which are non-primitives. <code>list</code> of non-primitive types is skipped when encountered.</p> <p>Parameters:</p> <ul> <li> <code>document</code>               (<code>Document</code>)           \u2013            <p>The document to be converted to a Neo4j record.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>A document converted to a <code>dict</code> with flattened nested fields.</p> </li> </ul> Source code in <code>src/neo4j_haystack/document_stores/neo4j_store.py</code> <pre><code>def marshal(self, document: Document) -&gt; Any:\n    \"\"\"\n    Converts `haystack.Document` by using `to_dict` method and then flattens any dictionary fields in case there\n    are any (in some cases such are being used in `meta` attributes). Once flattened we inspect attribute values\n    for unsupported types, e.g. custom types which are non-primitives. `list` of non-primitive types is skipped\n    when encountered.\n\n    Args:\n        document: The document to be converted to a Neo4j record.\n\n    Returns:\n        A document converted to a `dict` with flattened nested fields.\n    \"\"\"\n    converted_doc = document.to_dict(flatten=True)\n    doc_object = flatten_dict(converted_doc, separator=self.property_separator)\n\n    return self._exclude_non_serializable_objects(doc_object)\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/","title":"Neo4jQueryConverter","text":""},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.NodeVisitor","title":"NodeVisitor","text":"<p>A base class for a converter which is responsible for converting filters abstract syntax tree into a particular DocumentStore specific syntax (e.g. SQL/Cypher queries). It provides a basic structure for a \"Visitor Pattern\" where each node of the tree could be \"visited\" (a method called with the node as a parameter).</p> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>class NodeVisitor:\n    \"\"\"\n    A base class for a converter which is responsible for converting filters abstract syntax tree into a\n    particular DocumentStore specific syntax (e.g. SQL/Cypher queries). It provides a basic structure for a\n    \"Visitor Pattern\" where each node of the tree could be \"visited\" (a method called with the node as a parameter).\n    \"\"\"\n\n    PREFIX = \"visit\"\n\n    def visit(self, node: AST) -&gt; Any:\n        \"\"\"\n        Resolves a method name (visitor) to be called with a particular AST `node`. The visitor is responsible for\n        handling logic of the node (e.g. converting it to a database specific query). The method to be called is\n        determined by a descriptor (python friendly name, e.g. ``logical_op`` for a node of type `LogicalOp`).\n\n        If visitor method could not be found a generic exception is raised.\n\n        Args:\n            node: `AST` node to be visited.\n\n        Returns:\n            Any result implementing class is planning to return.\n        \"\"\"\n        visitor = getattr(self, self._descriptor(node), self.generic_visit)\n        return visitor(node)\n\n    def generic_visit(self, node: AST):\n        \"\"\"\n        A fallback visitor in case no specific ones have been found. Raises error by default.\n        \"\"\"\n        raise Exception(f\"No {self._descriptor(node)} method\")\n\n    def _descriptor(self, node: AST) -&gt; str:\n        \"\"\"\n        Composes a full name for the visitor method with the prefix, e.g. ``\"visit_\"`` + ``\"logical_op\"``.\n        \"\"\"\n        return f\"{self.PREFIX}_{node.descriptor}\"\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.NodeVisitor.visit","title":"visit","text":"<pre><code>visit(node: AST) -&gt; Any\n</code></pre> <p>Resolves a method name (visitor) to be called with a particular AST <code>node</code>. The visitor is responsible for handling logic of the node (e.g. converting it to a database specific query). The method to be called is determined by a descriptor (python friendly name, e.g. <code>logical_op</code> for a node of type <code>LogicalOp</code>).</p> <p>If visitor method could not be found a generic exception is raised.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>AST</code>)           \u2013            <p><code>AST</code> node to be visited.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Any result implementing class is planning to return.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def visit(self, node: AST) -&gt; Any:\n    \"\"\"\n    Resolves a method name (visitor) to be called with a particular AST `node`. The visitor is responsible for\n    handling logic of the node (e.g. converting it to a database specific query). The method to be called is\n    determined by a descriptor (python friendly name, e.g. ``logical_op`` for a node of type `LogicalOp`).\n\n    If visitor method could not be found a generic exception is raised.\n\n    Args:\n        node: `AST` node to be visited.\n\n    Returns:\n        Any result implementing class is planning to return.\n    \"\"\"\n    visitor = getattr(self, self._descriptor(node), self.generic_visit)\n    return visitor(node)\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.NodeVisitor.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node: AST)\n</code></pre> <p>A fallback visitor in case no specific ones have been found. Raises error by default.</p> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def generic_visit(self, node: AST):\n    \"\"\"\n    A fallback visitor in case no specific ones have been found. Raises error by default.\n    \"\"\"\n    raise Exception(f\"No {self._descriptor(node)} method\")\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.NodeVisitor._descriptor","title":"_descriptor","text":"<pre><code>_descriptor(node: AST) -&gt; str\n</code></pre> <p>Composes a full name for the visitor method with the prefix, e.g. <code>\"visit_\"</code> + <code>\"logical_op\"</code>.</p> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _descriptor(self, node: AST) -&gt; str:\n    \"\"\"\n    Composes a full name for the visitor method with the prefix, e.g. ``\"visit_\"`` + ``\"logical_op\"``.\n    \"\"\"\n    return f\"{self.PREFIX}_{node.descriptor}\"\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter","title":"Neo4jQueryConverter","text":"<p>               Bases: <code>NodeVisitor</code></p> <p>This class acts as a visitor for all nodes in an abstract syntax tree built by the <code>FilterParser</code>. Its job is to traverse the tree and \"visit\" (call respective method) nodes to accomplish the conversion between metadata filters into Neo4j Cypher expressions. Resulting Cypher query is then used as part of the <code>WHERE</code> Neo4j clause and is based on the following concepts:</p> <ul> <li>WHERE clause</li> <li>Comparison operators</li> <li>Working with null</li> </ul> <p>below is an example usage of the converter:</p> <pre><code>parser = FilterParser()\nconverter = Neo4jQueryConverter(\"doc\")\n\nfilters = {\n    \"operator\": \"OR\",\n    \"conditions\": [\n        {\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"news\"},\n                {\"field\": \"meta.likes\", \"operator\": \"!=\", \"value\": 100},\n            ],\n        },\n        {\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"blog\"},\n                {\"field\": \"meta.likes\", \"operator\": \"&gt;=\", \"value\": 500},\n            ],\n        },\n    ],\n}\n\nfilter_ast = parser.parse(filters)\ncypher_query, params = converter.convert(filter_ast)\n</code></pre> <p>The above code will produce the following Neo4j Cypher query (<code>cypher_query</code>):</p> <pre><code>((doc.type = $fv_type AND doc.likes &lt; $fv_likes) OR (doc.type = $fv_type_1 AND doc.likes &gt;= $fv_likes_1))\n</code></pre> <p>with parameters (<code>params</code>):</p> <pre><code>{\"fv_type\": \"news\", \"fv_likes\": 100, \"fv_type_1\": \"blog\", \"fv_likes_1\": 500}\n</code></pre> <p>The reason Cypher query is accompanied with parameters is because we delegate data type conversion of parameter values to Neo4j Python Driver instead of repeating the logic in this class. See the full mapping of core and extended types in the Data Types document.</p> <p>The conversion logic of this class starts with root node of the abstract syntax tree which is usually a logical operator (e.g. \"$and\") and calls <code>visit</code> method with that node. Depending on type of the node respective visitor method is called:</p> <ul> <li><code>visit_logical_op</code> if node represents a logical operator (<code>LogicalOp</code>)</li> <li><code>visit_comparison_op</code> if node represents a comparison operator (<code>LogicalOp</code>)</li> </ul> <p>Each visitor is responsible of producing a Cypher expression which is then combined with other expressions up in the tree. Parentheses are used to group expressions if required.</p> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>class Neo4jQueryConverter(NodeVisitor):\n    \"\"\"\n    This class acts as a visitor for all nodes in an abstract syntax tree built by the `FilterParser`. Its job is\n    to traverse the tree and \"visit\" (call respective method) nodes to accomplish the conversion between metadata\n    filters into Neo4j Cypher expressions. Resulting Cypher query is then used as part of the ``WHERE`` Neo4j clause and\n    is based on the following concepts:\n\n    - [WHERE clause](https://neo4j.com/docs/cypher-manual/current/clauses/where/)\n    - [Comparison operators](https://neo4j.com/docs/cypher-manual/current/syntax/operators/#query-operators-comparison)\n    - [Working with null](https://neo4j.com/docs/cypher-manual/current/values-and-types/working-with-null/)\n\n    below is an example usage of the converter:\n\n    ```python\n    parser = FilterParser()\n    converter = Neo4jQueryConverter(\"doc\")\n\n    filters = {\n        \"operator\": \"OR\",\n        \"conditions\": [\n            {\n                \"operator\": \"AND\",\n                \"conditions\": [\n                    {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"news\"},\n                    {\"field\": \"meta.likes\", \"operator\": \"!=\", \"value\": 100},\n                ],\n            },\n            {\n                \"operator\": \"AND\",\n                \"conditions\": [\n                    {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"blog\"},\n                    {\"field\": \"meta.likes\", \"operator\": \"&gt;=\", \"value\": 500},\n                ],\n            },\n        ],\n    }\n\n    filter_ast = parser.parse(filters)\n    cypher_query, params = converter.convert(filter_ast)\n    ```\n\n    The above code will produce the following Neo4j Cypher query (``cypher_query``):\n\n    ```cypher\n    ((doc.type = $fv_type AND doc.likes &lt; $fv_likes) OR (doc.type = $fv_type_1 AND doc.likes &gt;= $fv_likes_1))\n    ```\n\n    with parameters (``params``):\n\n    ```python\n    {\"fv_type\": \"news\", \"fv_likes\": 100, \"fv_type_1\": \"blog\", \"fv_likes_1\": 500}\n    ```\n\n    The reason Cypher query is accompanied with parameters is because **we delegate data type conversion of parameter\n    values to Neo4j Python Driver instead of repeating the logic in this class**. See the full mapping of core and\n    extended types in the [Data Types](https://neo4j.com/docs/api/python-driver/current/api.html#data-types) document.\n\n    The conversion logic of this class starts with root node of the abstract syntax tree which is usually a logical\n    operator (e.g. \"$and\") and calls `visit` method with that node. Depending on type of the node respective visitor\n    method is called:\n\n    - `visit_logical_op` if node represents a logical operator (`LogicalOp`)\n    - `visit_comparison_op` if node represents a comparison operator (`LogicalOp`)\n\n    Each visitor is responsible of producing a Cypher expression which is then combined with other expressions up in\n    the tree. Parentheses are used to group expressions if required.\n    \"\"\"\n\n    COMPARISON_MAPPING: ClassVar[Dict[str, str]] = {\n        OP_EQ: \"=\",\n        OP_NEQ: \"&lt;&gt;\",\n        OP_GT: \"&gt;\",\n        OP_GTE: \"&gt;=\",\n        OP_LT: \"&lt;\",\n        OP_LTE: \"&lt;=\",\n    }\n\n    LOGICAL_MAPPING: ClassVar[Dict[str, str]] = {\n        OP_AND: \"AND\",\n        OP_OR: \"OR\",\n        OP_NOT: \"NOT\",\n    }\n\n    EMPTY_EXPR = \"\"\n\n    def __init__(\n        self,\n        field_name_prefix: Optional[str] = None,\n        include_null_values_when_not_equal: Optional[bool] = False,\n        flatten_field_name: Optional[bool] = True,\n    ):\n        \"\"\"\n        Constructs a new `Neo4jQueryConverter` instance.\n\n        Args:\n            field_name_prefix: A prefix to be added to field names in Cypher queries (e.g. `:::cypher doc.age = 20`,\n                where ``\"doc\"`` is the prefix).\n            include_null_values_when_not_equal: When `True` will enable additional Cypher expressions for\n                inequality operators \"not in\" and \"!=\" so that `null` values are considered as \"not equal\" instead of\n                being skipped. **This is experimental and by default is disabled**.\n            flatten_field_name: In case filed names are composite/nested like \"meta.age\" replace dot (\".\") with\n                underscores (\"_\").\n        \"\"\"\n        self._field_name_prefix = field_name_prefix\n        self._include_null_values_when_not_equal = include_null_values_when_not_equal\n        self._flatten_field_name = flatten_field_name\n        self._params: Dict[str, Any] = {}\n\n    def convert(self, op_tree: AST) -&gt; Tuple[str, Dict[str, Any]]:\n        \"\"\"\n        The method to be called for converting metadata filter AST into Cypher expression. It starts with calling\n        `self.visit` for the root node of the tree.\n\n        Examples:\n            &gt;&gt;&gt; op_tree = FilterParser().parse({ \"age\", 30 })\n            &gt;&gt;&gt; Neo4jQueryConverter(\"n\").convert(op_tree)\n            ('n.age = $fv_age', {'$fv_age': 30})\n\n        Args:\n            op_tree: The abstract syntax tree representing a parsed metadata filter. See `FilterParser` to learn\n                about parsing logic.\n\n        Returns:\n            Cypher expression along with parameters used in the expression.\n        \"\"\"\n        self._params = {}\n\n        cypher_query = self.visit(op_tree)\n\n        return cypher_query, self._params\n\n    def visit_logical_op(self, node: LogicalOp) -&gt; str:\n        \"\"\"\n        Handles logical operators of type `LogicalOp` by visiting all its operands first. This might result in\n        recursive calls as operands might be logical operators as well. Once all operands render its own Cypher\n        expressions all of those expressions are combined in a single query using operator of the `node` (e.g. \"AND\").\n\n        If there are more than one operand parentheses are used to group all expressions.\n\n        Examples:\n            &gt;&gt;&gt; operand1 = ComparisonOp(\"age\", \"!=\", 20)\n            &gt;&gt;&gt; operand2 = ComparisonOp(\"age\", \"&lt;=\", 30)\n            &gt;&gt;&gt; logical_op = LogicalOp([operand1, operand2], \"OR\")\n            &gt;&gt;&gt; self.visit_logical_op(operator)\n            \"(doc.age &lt;&gt; 20 OR doc.age &lt;= 30\"\n\n        Args:\n            node: The logical operator `AST` node to be converted.\n\n        Returns:\n            Cypher expression converted from the logical operator.\n        \"\"\"\n        operands = [self.visit(operand) for operand in node.operands]\n\n        if node.op == OP_NOT:\n            return self._wrap_in_parentheses(*operands, join_operator=\"AND\", prefix_expr=\"NOT \")\n\n        return self._wrap_in_parentheses(*operands, join_operator=self.LOGICAL_MAPPING[node.op])\n\n    def visit_comparison_op(self, node: ComparisonOp) -&gt; str:\n        \"\"\"\n        Handles comparison operators of type `ComparisonOp` by checking each operator type and delegating to\n        appropriate method for translating the operator to a Cypher comparison expression. Each comparison expression\n        might produce respective query parameters (and its values) which are added to the common parameters dictionary.\n        Parameter names are unique in order to avoid clashes between potentially multiple comparison operators.\n\n        Examples:\n            &gt;&gt;&gt; operator = ComparisonOp(\"age\", \"!=\", 20)\n            &gt;&gt;&gt; self.visit_comparison_op(operator)\n            \"doc.age &lt;&gt; 20\"\n\n            &gt;&gt;&gt; operator = ComparisonOp(\"age\", \"in\", [10, 11])\n            &gt;&gt;&gt; self.visit_comparison_op(operator)\n            \"doc.age IN [10, 11]\"\n\n        Args:\n            node: The comparison operator `AST` node to be converted.\n\n        Returns:\n            Cypher expression converted from a comparison operator.\n        \"\"\"\n        field_param = self._field_param(node)\n\n        # default comparison expression syntax (e.g. \"field_name &gt;= field_value\")\n        cypher_expr = self._op_default(field_param)\n\n        if node.op == OP_EXISTS:\n            cypher_expr = self._op_exists(field_param)\n        elif node.op == OP_NEQ:\n            cypher_expr = self._op_neq(field_param)\n        elif node.op == OP_IN:\n            cypher_expr = self._op_in(field_param)\n        elif node.op == OP_NIN:\n            cypher_expr = self._op_nin(field_param)\n\n        self._update_query_parameters(cypher_expr.params)\n\n        return cypher_expr.query\n\n    def _field_is_null_expr(self, param: CypherFieldParam) -&gt; str:\n        \"\"\"\n        Constructs \"IS NULL\" Cypher operator for the provided field (e.g. `:::cypher doc.age IS NULL`).\n        Non-empty expression will be returned only when `self._include_null_values_when_not_equal` is set to\n        `True`.\n\n        Note:\n            This is experimental feature and is disabled as of now\n\n        Additional \"IS NULL\" checks can be useful for non-equality checks (e.g. ``\"doc.age &lt;&gt; 0\"``) as by default Neo4j\n        skips properties with null values, see [Operators Equality](https://neo4j.com/docs/cypher-manual/current/syntax/operators/#_equality)\n        manual. The `:::cypher doc.age &lt;&gt; 0 OR doc.age IS NULL` expression will make sure all nodes are included in\n        comparison.\n\n        Args:\n            param: Field parameter metadata to be use in he Cypher expression.\n\n        Returns:\n            Cypher \"IS NULL\" query clause for a given `param.field_name`. Empty `str` if logic is disabled by\n                `self._include_null_values_when_not_equal`.\n        \"\"\"\n        return f\"{param.field_name} is NULL\" if self._include_null_values_when_not_equal else self.EMPTY_EXPR\n\n    def _op_exists(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n        \"\"\"\n        Translates ``\"exists\"`` metadata filter into ``\"IS NULL / IS NOT NULL\"`` Cypher expression. Useful for checking\n        absent properties. See more details in Neo4j documentation:\n\n        - [Filter on `null`](https://neo4j.com/docs/cypher-manual/current/clauses/where/#filter-on-null)\n        - [Property existence checking](https://neo4j.com/docs/cypher-manual/current/clauses/where/#property-existence-checking)\n\n        An example metadata filter would look as follows `:::py { \"age\": { \"$exists\": True } }`, which translates into\n        `::cypher doc.age IS NOT NULL` Cypher expression. With `False` in the filter value expression would become\n        `:::cypher doc.age IS NULL`.\n\n        Args:\n            param: Field parameter metadata to be use in he Cypher expression.\n\n        Returns:\n            Cypher expression to check if property is ``null`` (property existence in Neo4j)\n        \"\"\"\n        return self._cypher_expression(f\"{param.field_name} {'IS NOT' if param.field_value else 'IS'} NULL\")\n\n    def _op_neq(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n        \"\"\"\n        Translates ``\"!=\"`` (not equal) metadata filter into ``\"&lt;&gt;\"`` Cypher expression.\n\n        Args:\n            param: Field parameter metadata to be use in he Cypher expression.\n\n        Returns:\n            Cypher expression using Cypher inequality operator, e.g. `:::cypher doc.age &lt;&gt; 18`.\n        \"\"\"\n        return self._cypher_expression(\n            self._wrap_in_parentheses(\n                f\"{param.field_name} {param.op} {param.field_param_ref}\",\n                self._field_is_null_expr(param),\n                join_operator=\"OR\",\n            ),\n            param,\n        )\n\n    def _op_in(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n        \"\"\"\n        Translates ``\"in\"`` (element exists in a list) metadata filter into ``\"IN\"`` Cypher expression.\n        See more details in Neo4j documentation:\n\n        - [IN operator](https://neo4j.com/docs/cypher-manual/current/clauses/where/#where-in-operator)\n        - [Conditional expressions](https://neo4j.com/docs/cypher-manual/current/queries/case/)\n        - [Function ``any()``](https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any)\n\n        Please notice a combination of \"CASE\" expression and \"IN\" operator are being used to comply with\n        all metadata filtering options. In simple cases we would expect the following Cypher expression to be built:\n        `:::cypher \"doc.age in [20, 30]\"`,however, if the ``\"age\"`` property is a list the expression\n        would not work in Neo4j. Thus ``CASE`` checks the type of the property and if its a list ``any()`` function\n        evaluates every element in the list with \"IN\" operator.\n\n        Args:\n            param: Field parameter metadata to be use in he Cypher expression.\n\n        Returns:\n            Cypher expression using Cypher ``IN`` operator.\n        \"\"\"\n        return self._cypher_expression(\n            f\"CASE valueType({param.field_name}) STARTS WITH 'LIST' \"\n            f\"WHEN true THEN any(val IN {param.field_name} WHERE val IN {param.field_param_ref}) \"\n            f\"ELSE {param.field_name} IN {param.field_param_ref} END\",\n            param,\n        )\n\n    def _op_nin(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n        \"\"\"\n        Translates ``\"not in\"`` (element **not** in a list) metadata filter into ``\"NOT..IN\"`` Cypher expression. See\n        documentation of the [_op_in][neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._op_in]\n        method for more details.\n\n        Additional \"IS NULL\" expression will be added if such configuration is enabled. See implementation of\n            [_field_is_null_expr][neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._field_is_null_expr].\n\n        Args:\n            param: Field parameter metadata to be use in he Cypher expression.\n\n        Returns:\n            Cypher expression using Cypher ``NOT IN`` operator, e.g. ``\"NOT doc.age IN [20, 30]\"``.\n        \"\"\"\n        return self._cypher_expression(\n            self._wrap_in_parentheses(\n                (\n                    f\"CASE valueType({param.field_name}) STARTS WITH 'LIST' \"\n                    f\"WHEN true THEN any(val IN {param.field_name} WHERE NOT val IN {param.field_param_ref}) \"\n                    f\"ELSE NOT {param.field_name} IN {param.field_param_ref} END\"\n                ),\n                self._field_is_null_expr(param),\n                join_operator=\"OR\",\n            ),\n            param,\n        )\n\n    def _op_default(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n        \"\"\"\n        Default method to translate comparison metadata filter into Cypher expression.\n        The mapping between metadata filter operators and Neo4j operators is stored in `self.COMPARISON_MAPPING`.\n\n        Args:\n            param: Field parameter metadata to be use in he Cypher expression.\n\n        Returns:\n            Cypher expression using Cypher operator, e.g. `:::cypher doc.age &gt; 18`\n        \"\"\"\n        return self._cypher_expression(f\"{param.field_name} {param.op} {param.field_param_ref}\", param)\n\n    def _cypher_expression(self, query: str, field_param: Optional[CypherFieldParam] = None) -&gt; CypherQueryExpression:\n        \"\"\"\n        A factory method to create `CypherQueryExpression` data structure comprised of a Cypher query and\n        respective query parameters.\n\n        Args:\n            query: Cypher query (expression)\n            field_param: Optional parameters to be added to the query execution.\n\n        Returns:\n            Data class with query and parameters if any.\n        \"\"\"\n        params = {field_param.field_param_name: field_param.field_value} if field_param else {}\n        return CypherQueryExpression(query, params)\n\n    def _wrap_in_parentheses(\n        self, *cypher_expressions: str, join_operator: str = \"AND\", prefix_expr: Optional[str] = None\n    ) -&gt; str:\n        \"\"\"\n        Wraps given list of Cypher expressions in parentheses and combines them with a given operator which is\n        \"AND\" by default. For example if `:::py cypher_expressions=(\"age &gt; $fv_age\", \"height &lt;&gt; $fv_height\")`\n        the method will return `:::cypher (\"age &gt; $fv_age AND height &lt;&gt; $fv_height\")`.\n\n        For a single Cypher expression no parentheses are added and no operator is used.\n\n        Args:\n            join_operator: Logical operator to combine given expressions.\n            prefix_expr: Additional operators to be added in-front of the final Cypher query. Could be ``\"NOT \"`` in\n                order to add negation to the combined expressions.\n\n        Returns:\n            Cypher query expression, wrapped in parentheses if needed.\n        \"\"\"\n        valid_cypher_expressions = [expr for expr in cypher_expressions if expr]\n\n        # we expect at least one expression to be provided\n        result = valid_cypher_expressions[0]\n\n        if len(valid_cypher_expressions) &gt; 1:\n            logical_expression = f\" {join_operator} \".join(valid_cypher_expressions)\n            result = f\"({logical_expression})\"\n\n        return f\"{prefix_expr}{result}\" if prefix_expr else result\n\n    def _field_param(self, node: ComparisonOp) -&gt; CypherFieldParam:\n        \"\"\"\n        Constructs `CypherFieldParam` data class with aggregated information about comparison operation.\n        Below is an example with resolved attribute values:\n\n        ```python\n        CypherFieldParam(\n            field_name=\"doc.age\",\n            field_param_name=\"fv_age\",\n            field_param_ref=\"$fv_age\", # to be referenced in Cypher query\n            field_value=10,\n            op=\"&lt;&gt;\", # mapped from \"$ne\" to \"&lt;&gt;\"\n        )\n        ```\n\n        In a simplest case information from `CypherFieldParam` could be converted into `:::cypher doc.age &lt;&gt; $fv_age`,\n        ``params={\"fv_age\": 10}``\n\n        Args:\n            node: Comparison `AST` node.\n\n        Returns:\n            CypherFieldParam: data class with required field parameter metadata.\n        \"\"\"\n\n        field_name = node.field_name\n        if \".\" in field_name and self._flatten_field_name:\n            field_name = field_name.replace(\".\", \"_\")\n\n        field_param_name = self._generate_param_name(field_name)\n        field_value = self._normalize_field_type(node.field_value)\n\n        return CypherFieldParam(\n            field_name=f\"{self._field_name_prefix}.{field_name}\" if self._field_name_prefix else field_name,\n            field_param_name=field_param_name,\n            field_param_ref=f\"${field_param_name}\",\n            field_value=field_value,\n            op=self.COMPARISON_MAPPING.get(node.op),\n        )\n\n    def _normalize_field_type(self, field_value: FieldValueType) -&gt; FieldValueType:\n        \"\"\"\n        Adjusts field value type if need. Generally we delegate the type conversion of python field values (data types)\n        to `neo4j` python driver. This way we reduce amount of logic in the converter and rely on the driver to make\n        sure field value types are properly mapped between Python and Neo4j. In some cases though we can handle\n        additional conversions which are not supported by the driver. See example below:\n\n        The following Metadata filter query `:::py { \"age\": {30, 20 ,40} }` should produce `IN` Cypher clause, e.g.\n        `:::cypher doc.age IN [20, 30, 40]`. However neo4j python driver does not accept `set` python type, thus we\n        convert it to `list` to make such filters possible.\n\n        Args:\n            field_value: Field value to be adjusted to be compatible with Neo4j types.\n\n        Returns:\n            Adjusted field value type if required.\n        \"\"\"\n        if isinstance(field_value, set):\n            return sorted(field_value)\n\n        return field_value\n\n    def _update_query_parameters(self, params: Dict[str, Any]):\n        \"\"\"\n        Updates Cypher query parameters with a given parameter set in `params`.\n\n        Args:\n            params: Parameters to be added to the final set of parameters which will be returned along with\n                the generated Cypher query.\n        \"\"\"\n        self._params.update(params)\n\n    def _generate_param_name(self, field_name: str) -&gt; str:\n        \"\"\"\n        Generates a new Cypher query parameter name ensuring it is unique in a given parameter dictionary\n        `self._params`. For example if `self._params` is equal to ``{ \"fv_age\": 20 }`` a new parameter name called\n        ``fv_age_1`` will be generated by adding appropriate incremented index.\n\n        Args:\n            field_name: The nme of the filed to be generated. ``\"fv_\"`` prefix is added to all fields to avoid\n                collisions with parameters given during Cypher query execution.\n\n        Returns:\n            A new parameter name, with an unique index if needed.\n        \"\"\"\n        i = 0\n        field_param_name = f\"fv_{field_name}\"\n        while field_param_name in self._params:\n            i += 1\n            field_param_name = f\"fv_{field_name}_{i}\"\n        return field_param_name\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter.__init__","title":"__init__","text":"<pre><code>__init__(\n    field_name_prefix: Optional[str] = None,\n    include_null_values_when_not_equal: Optional[bool] = False,\n    flatten_field_name: Optional[bool] = True,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>field_name_prefix</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>A prefix to be added to field names in Cypher queries (e.g. <code>doc.age = 20</code>, where <code>\"doc\"</code> is the prefix).</p> </li> <li> <code>include_null_values_when_not_equal</code>               (<code>Optional[bool]</code>, default:                   <code>False</code> )           \u2013            <p>When <code>True</code> will enable additional Cypher expressions for inequality operators \"not in\" and \"!=\" so that <code>null</code> values are considered as \"not equal\" instead of being skipped. This is experimental and by default is disabled.</p> </li> <li> <code>flatten_field_name</code>               (<code>Optional[bool]</code>, default:                   <code>True</code> )           \u2013            <p>In case filed names are composite/nested like \"meta.age\" replace dot (\".\") with underscores (\"_\").</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def __init__(\n    self,\n    field_name_prefix: Optional[str] = None,\n    include_null_values_when_not_equal: Optional[bool] = False,\n    flatten_field_name: Optional[bool] = True,\n):\n    \"\"\"\n    Constructs a new `Neo4jQueryConverter` instance.\n\n    Args:\n        field_name_prefix: A prefix to be added to field names in Cypher queries (e.g. `:::cypher doc.age = 20`,\n            where ``\"doc\"`` is the prefix).\n        include_null_values_when_not_equal: When `True` will enable additional Cypher expressions for\n            inequality operators \"not in\" and \"!=\" so that `null` values are considered as \"not equal\" instead of\n            being skipped. **This is experimental and by default is disabled**.\n        flatten_field_name: In case filed names are composite/nested like \"meta.age\" replace dot (\".\") with\n            underscores (\"_\").\n    \"\"\"\n    self._field_name_prefix = field_name_prefix\n    self._include_null_values_when_not_equal = include_null_values_when_not_equal\n    self._flatten_field_name = flatten_field_name\n    self._params: Dict[str, Any] = {}\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter.convert","title":"convert","text":"<pre><code>convert(op_tree: AST) -&gt; Tuple[str, Dict[str, Any]]\n</code></pre> <p>The method to be called for converting metadata filter AST into Cypher expression. It starts with calling <code>self.visit</code> for the root node of the tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; op_tree = FilterParser().parse({ \"age\", 30 })\n&gt;&gt;&gt; Neo4jQueryConverter(\"n\").convert(op_tree)\n('n.age = $fv_age', {'$fv_age': 30})\n</code></pre> <p>Parameters:</p> <ul> <li> <code>op_tree</code>               (<code>AST</code>)           \u2013            <p>The abstract syntax tree representing a parsed metadata filter. See <code>FilterParser</code> to learn about parsing logic.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[str, Dict[str, Any]]</code>           \u2013            <p>Cypher expression along with parameters used in the expression.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def convert(self, op_tree: AST) -&gt; Tuple[str, Dict[str, Any]]:\n    \"\"\"\n    The method to be called for converting metadata filter AST into Cypher expression. It starts with calling\n    `self.visit` for the root node of the tree.\n\n    Examples:\n        &gt;&gt;&gt; op_tree = FilterParser().parse({ \"age\", 30 })\n        &gt;&gt;&gt; Neo4jQueryConverter(\"n\").convert(op_tree)\n        ('n.age = $fv_age', {'$fv_age': 30})\n\n    Args:\n        op_tree: The abstract syntax tree representing a parsed metadata filter. See `FilterParser` to learn\n            about parsing logic.\n\n    Returns:\n        Cypher expression along with parameters used in the expression.\n    \"\"\"\n    self._params = {}\n\n    cypher_query = self.visit(op_tree)\n\n    return cypher_query, self._params\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter.visit_logical_op","title":"visit_logical_op","text":"<pre><code>visit_logical_op(node: LogicalOp) -&gt; str\n</code></pre> <p>Handles logical operators of type <code>LogicalOp</code> by visiting all its operands first. This might result in recursive calls as operands might be logical operators as well. Once all operands render its own Cypher expressions all of those expressions are combined in a single query using operator of the <code>node</code> (e.g. \"AND\").</p> <p>If there are more than one operand parentheses are used to group all expressions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; operand1 = ComparisonOp(\"age\", \"!=\", 20)\n&gt;&gt;&gt; operand2 = ComparisonOp(\"age\", \"&lt;=\", 30)\n&gt;&gt;&gt; logical_op = LogicalOp([operand1, operand2], \"OR\")\n&gt;&gt;&gt; self.visit_logical_op(operator)\n\"(doc.age &lt;&gt; 20 OR doc.age &lt;= 30\"\n</code></pre> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>LogicalOp</code>)           \u2013            <p>The logical operator <code>AST</code> node to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Cypher expression converted from the logical operator.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def visit_logical_op(self, node: LogicalOp) -&gt; str:\n    \"\"\"\n    Handles logical operators of type `LogicalOp` by visiting all its operands first. This might result in\n    recursive calls as operands might be logical operators as well. Once all operands render its own Cypher\n    expressions all of those expressions are combined in a single query using operator of the `node` (e.g. \"AND\").\n\n    If there are more than one operand parentheses are used to group all expressions.\n\n    Examples:\n        &gt;&gt;&gt; operand1 = ComparisonOp(\"age\", \"!=\", 20)\n        &gt;&gt;&gt; operand2 = ComparisonOp(\"age\", \"&lt;=\", 30)\n        &gt;&gt;&gt; logical_op = LogicalOp([operand1, operand2], \"OR\")\n        &gt;&gt;&gt; self.visit_logical_op(operator)\n        \"(doc.age &lt;&gt; 20 OR doc.age &lt;= 30\"\n\n    Args:\n        node: The logical operator `AST` node to be converted.\n\n    Returns:\n        Cypher expression converted from the logical operator.\n    \"\"\"\n    operands = [self.visit(operand) for operand in node.operands]\n\n    if node.op == OP_NOT:\n        return self._wrap_in_parentheses(*operands, join_operator=\"AND\", prefix_expr=\"NOT \")\n\n    return self._wrap_in_parentheses(*operands, join_operator=self.LOGICAL_MAPPING[node.op])\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter.visit_comparison_op","title":"visit_comparison_op","text":"<pre><code>visit_comparison_op(node: ComparisonOp) -&gt; str\n</code></pre> <p>Handles comparison operators of type <code>ComparisonOp</code> by checking each operator type and delegating to appropriate method for translating the operator to a Cypher comparison expression. Each comparison expression might produce respective query parameters (and its values) which are added to the common parameters dictionary. Parameter names are unique in order to avoid clashes between potentially multiple comparison operators.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; operator = ComparisonOp(\"age\", \"!=\", 20)\n&gt;&gt;&gt; self.visit_comparison_op(operator)\n\"doc.age &lt;&gt; 20\"\n</code></pre> <pre><code>&gt;&gt;&gt; operator = ComparisonOp(\"age\", \"in\", [10, 11])\n&gt;&gt;&gt; self.visit_comparison_op(operator)\n\"doc.age IN [10, 11]\"\n</code></pre> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>ComparisonOp</code>)           \u2013            <p>The comparison operator <code>AST</code> node to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Cypher expression converted from a comparison operator.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def visit_comparison_op(self, node: ComparisonOp) -&gt; str:\n    \"\"\"\n    Handles comparison operators of type `ComparisonOp` by checking each operator type and delegating to\n    appropriate method for translating the operator to a Cypher comparison expression. Each comparison expression\n    might produce respective query parameters (and its values) which are added to the common parameters dictionary.\n    Parameter names are unique in order to avoid clashes between potentially multiple comparison operators.\n\n    Examples:\n        &gt;&gt;&gt; operator = ComparisonOp(\"age\", \"!=\", 20)\n        &gt;&gt;&gt; self.visit_comparison_op(operator)\n        \"doc.age &lt;&gt; 20\"\n\n        &gt;&gt;&gt; operator = ComparisonOp(\"age\", \"in\", [10, 11])\n        &gt;&gt;&gt; self.visit_comparison_op(operator)\n        \"doc.age IN [10, 11]\"\n\n    Args:\n        node: The comparison operator `AST` node to be converted.\n\n    Returns:\n        Cypher expression converted from a comparison operator.\n    \"\"\"\n    field_param = self._field_param(node)\n\n    # default comparison expression syntax (e.g. \"field_name &gt;= field_value\")\n    cypher_expr = self._op_default(field_param)\n\n    if node.op == OP_EXISTS:\n        cypher_expr = self._op_exists(field_param)\n    elif node.op == OP_NEQ:\n        cypher_expr = self._op_neq(field_param)\n    elif node.op == OP_IN:\n        cypher_expr = self._op_in(field_param)\n    elif node.op == OP_NIN:\n        cypher_expr = self._op_nin(field_param)\n\n    self._update_query_parameters(cypher_expr.params)\n\n    return cypher_expr.query\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._field_is_null_expr","title":"_field_is_null_expr","text":"<pre><code>_field_is_null_expr(param: CypherFieldParam) -&gt; str\n</code></pre> <p>Constructs \"IS NULL\" Cypher operator for the provided field (e.g. <code>doc.age IS NULL</code>). Non-empty expression will be returned only when <code>self._include_null_values_when_not_equal</code> is set to <code>True</code>.</p> Note <p>This is experimental feature and is disabled as of now</p> <p>Additional \"IS NULL\" checks can be useful for non-equality checks (e.g. <code>\"doc.age &lt;&gt; 0\"</code>) as by default Neo4j skips properties with null values, see Operators Equality manual. The <code>doc.age &lt;&gt; 0 OR doc.age IS NULL</code> expression will make sure all nodes are included in comparison.</p> <p>Parameters:</p> <ul> <li> <code>param</code>               (<code>CypherFieldParam</code>)           \u2013            <p>Field parameter metadata to be use in he Cypher expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Cypher \"IS NULL\" query clause for a given <code>param.field_name</code>. Empty <code>str</code> if logic is disabled by <code>self._include_null_values_when_not_equal</code>.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _field_is_null_expr(self, param: CypherFieldParam) -&gt; str:\n    \"\"\"\n    Constructs \"IS NULL\" Cypher operator for the provided field (e.g. `:::cypher doc.age IS NULL`).\n    Non-empty expression will be returned only when `self._include_null_values_when_not_equal` is set to\n    `True`.\n\n    Note:\n        This is experimental feature and is disabled as of now\n\n    Additional \"IS NULL\" checks can be useful for non-equality checks (e.g. ``\"doc.age &lt;&gt; 0\"``) as by default Neo4j\n    skips properties with null values, see [Operators Equality](https://neo4j.com/docs/cypher-manual/current/syntax/operators/#_equality)\n    manual. The `:::cypher doc.age &lt;&gt; 0 OR doc.age IS NULL` expression will make sure all nodes are included in\n    comparison.\n\n    Args:\n        param: Field parameter metadata to be use in he Cypher expression.\n\n    Returns:\n        Cypher \"IS NULL\" query clause for a given `param.field_name`. Empty `str` if logic is disabled by\n            `self._include_null_values_when_not_equal`.\n    \"\"\"\n    return f\"{param.field_name} is NULL\" if self._include_null_values_when_not_equal else self.EMPTY_EXPR\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._op_exists","title":"_op_exists","text":"<pre><code>_op_exists(param: CypherFieldParam) -&gt; CypherQueryExpression\n</code></pre> <p>Translates <code>\"exists\"</code> metadata filter into <code>\"IS NULL / IS NOT NULL\"</code> Cypher expression. Useful for checking absent properties. See more details in Neo4j documentation:</p> <ul> <li>Filter on <code>null</code></li> <li>Property existence checking</li> </ul> <p>An example metadata filter would look as follows <code>{ \"age\": { \"$exists\": True } }</code>, which translates into <code>::cypher doc.age IS NOT NULL</code> Cypher expression. With <code>False</code> in the filter value expression would become <code>doc.age IS NULL</code>.</p> <p>Parameters:</p> <ul> <li> <code>param</code>               (<code>CypherFieldParam</code>)           \u2013            <p>Field parameter metadata to be use in he Cypher expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CypherQueryExpression</code>           \u2013            <p>Cypher expression to check if property is <code>null</code> (property existence in Neo4j)</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _op_exists(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n    \"\"\"\n    Translates ``\"exists\"`` metadata filter into ``\"IS NULL / IS NOT NULL\"`` Cypher expression. Useful for checking\n    absent properties. See more details in Neo4j documentation:\n\n    - [Filter on `null`](https://neo4j.com/docs/cypher-manual/current/clauses/where/#filter-on-null)\n    - [Property existence checking](https://neo4j.com/docs/cypher-manual/current/clauses/where/#property-existence-checking)\n\n    An example metadata filter would look as follows `:::py { \"age\": { \"$exists\": True } }`, which translates into\n    `::cypher doc.age IS NOT NULL` Cypher expression. With `False` in the filter value expression would become\n    `:::cypher doc.age IS NULL`.\n\n    Args:\n        param: Field parameter metadata to be use in he Cypher expression.\n\n    Returns:\n        Cypher expression to check if property is ``null`` (property existence in Neo4j)\n    \"\"\"\n    return self._cypher_expression(f\"{param.field_name} {'IS NOT' if param.field_value else 'IS'} NULL\")\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._op_neq","title":"_op_neq","text":"<pre><code>_op_neq(param: CypherFieldParam) -&gt; CypherQueryExpression\n</code></pre> <p>Translates <code>\"!=\"</code> (not equal) metadata filter into <code>\"&lt;&gt;\"</code> Cypher expression.</p> <p>Parameters:</p> <ul> <li> <code>param</code>               (<code>CypherFieldParam</code>)           \u2013            <p>Field parameter metadata to be use in he Cypher expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CypherQueryExpression</code>           \u2013            <p>Cypher expression using Cypher inequality operator, e.g. <code>doc.age &lt;&gt; 18</code>.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _op_neq(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n    \"\"\"\n    Translates ``\"!=\"`` (not equal) metadata filter into ``\"&lt;&gt;\"`` Cypher expression.\n\n    Args:\n        param: Field parameter metadata to be use in he Cypher expression.\n\n    Returns:\n        Cypher expression using Cypher inequality operator, e.g. `:::cypher doc.age &lt;&gt; 18`.\n    \"\"\"\n    return self._cypher_expression(\n        self._wrap_in_parentheses(\n            f\"{param.field_name} {param.op} {param.field_param_ref}\",\n            self._field_is_null_expr(param),\n            join_operator=\"OR\",\n        ),\n        param,\n    )\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._op_in","title":"_op_in","text":"<pre><code>_op_in(param: CypherFieldParam) -&gt; CypherQueryExpression\n</code></pre> <p>Translates <code>\"in\"</code> (element exists in a list) metadata filter into <code>\"IN\"</code> Cypher expression. See more details in Neo4j documentation:</p> <ul> <li>IN operator</li> <li>Conditional expressions</li> <li>Function <code>any()</code></li> </ul> <p>Please notice a combination of \"CASE\" expression and \"IN\" operator are being used to comply with all metadata filtering options. In simple cases we would expect the following Cypher expression to be built: <code>\"doc.age in [20, 30]\"</code>,however, if the <code>\"age\"</code> property is a list the expression would not work in Neo4j. Thus <code>CASE</code> checks the type of the property and if its a list <code>any()</code> function evaluates every element in the list with \"IN\" operator.</p> <p>Parameters:</p> <ul> <li> <code>param</code>               (<code>CypherFieldParam</code>)           \u2013            <p>Field parameter metadata to be use in he Cypher expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CypherQueryExpression</code>           \u2013            <p>Cypher expression using Cypher <code>IN</code> operator.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _op_in(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n    \"\"\"\n    Translates ``\"in\"`` (element exists in a list) metadata filter into ``\"IN\"`` Cypher expression.\n    See more details in Neo4j documentation:\n\n    - [IN operator](https://neo4j.com/docs/cypher-manual/current/clauses/where/#where-in-operator)\n    - [Conditional expressions](https://neo4j.com/docs/cypher-manual/current/queries/case/)\n    - [Function ``any()``](https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any)\n\n    Please notice a combination of \"CASE\" expression and \"IN\" operator are being used to comply with\n    all metadata filtering options. In simple cases we would expect the following Cypher expression to be built:\n    `:::cypher \"doc.age in [20, 30]\"`,however, if the ``\"age\"`` property is a list the expression\n    would not work in Neo4j. Thus ``CASE`` checks the type of the property and if its a list ``any()`` function\n    evaluates every element in the list with \"IN\" operator.\n\n    Args:\n        param: Field parameter metadata to be use in he Cypher expression.\n\n    Returns:\n        Cypher expression using Cypher ``IN`` operator.\n    \"\"\"\n    return self._cypher_expression(\n        f\"CASE valueType({param.field_name}) STARTS WITH 'LIST' \"\n        f\"WHEN true THEN any(val IN {param.field_name} WHERE val IN {param.field_param_ref}) \"\n        f\"ELSE {param.field_name} IN {param.field_param_ref} END\",\n        param,\n    )\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._op_nin","title":"_op_nin","text":"<pre><code>_op_nin(param: CypherFieldParam) -&gt; CypherQueryExpression\n</code></pre> <p>Translates <code>\"not in\"</code> (element not in a list) metadata filter into <code>\"NOT..IN\"</code> Cypher expression. See documentation of the _op_in method for more details.</p> <p>Additional \"IS NULL\" expression will be added if such configuration is enabled. See implementation of     _field_is_null_expr.</p> <p>Parameters:</p> <ul> <li> <code>param</code>               (<code>CypherFieldParam</code>)           \u2013            <p>Field parameter metadata to be use in he Cypher expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CypherQueryExpression</code>           \u2013            <p>Cypher expression using Cypher <code>NOT IN</code> operator, e.g. <code>\"NOT doc.age IN [20, 30]\"</code>.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _op_nin(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n    \"\"\"\n    Translates ``\"not in\"`` (element **not** in a list) metadata filter into ``\"NOT..IN\"`` Cypher expression. See\n    documentation of the [_op_in][neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._op_in]\n    method for more details.\n\n    Additional \"IS NULL\" expression will be added if such configuration is enabled. See implementation of\n        [_field_is_null_expr][neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._field_is_null_expr].\n\n    Args:\n        param: Field parameter metadata to be use in he Cypher expression.\n\n    Returns:\n        Cypher expression using Cypher ``NOT IN`` operator, e.g. ``\"NOT doc.age IN [20, 30]\"``.\n    \"\"\"\n    return self._cypher_expression(\n        self._wrap_in_parentheses(\n            (\n                f\"CASE valueType({param.field_name}) STARTS WITH 'LIST' \"\n                f\"WHEN true THEN any(val IN {param.field_name} WHERE NOT val IN {param.field_param_ref}) \"\n                f\"ELSE NOT {param.field_name} IN {param.field_param_ref} END\"\n            ),\n            self._field_is_null_expr(param),\n            join_operator=\"OR\",\n        ),\n        param,\n    )\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._op_default","title":"_op_default","text":"<pre><code>_op_default(param: CypherFieldParam) -&gt; CypherQueryExpression\n</code></pre> <p>Default method to translate comparison metadata filter into Cypher expression. The mapping between metadata filter operators and Neo4j operators is stored in <code>self.COMPARISON_MAPPING</code>.</p> <p>Parameters:</p> <ul> <li> <code>param</code>               (<code>CypherFieldParam</code>)           \u2013            <p>Field parameter metadata to be use in he Cypher expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CypherQueryExpression</code>           \u2013            <p>Cypher expression using Cypher operator, e.g. <code>doc.age &gt; 18</code></p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _op_default(self, param: CypherFieldParam) -&gt; CypherQueryExpression:\n    \"\"\"\n    Default method to translate comparison metadata filter into Cypher expression.\n    The mapping between metadata filter operators and Neo4j operators is stored in `self.COMPARISON_MAPPING`.\n\n    Args:\n        param: Field parameter metadata to be use in he Cypher expression.\n\n    Returns:\n        Cypher expression using Cypher operator, e.g. `:::cypher doc.age &gt; 18`\n    \"\"\"\n    return self._cypher_expression(f\"{param.field_name} {param.op} {param.field_param_ref}\", param)\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._cypher_expression","title":"_cypher_expression","text":"<pre><code>_cypher_expression(\n    query: str, field_param: Optional[CypherFieldParam] = None\n) -&gt; CypherQueryExpression\n</code></pre> <p>A factory method to create <code>CypherQueryExpression</code> data structure comprised of a Cypher query and respective query parameters.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>Cypher query (expression)</p> </li> <li> <code>field_param</code>               (<code>Optional[CypherFieldParam]</code>, default:                   <code>None</code> )           \u2013            <p>Optional parameters to be added to the query execution.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CypherQueryExpression</code>           \u2013            <p>Data class with query and parameters if any.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _cypher_expression(self, query: str, field_param: Optional[CypherFieldParam] = None) -&gt; CypherQueryExpression:\n    \"\"\"\n    A factory method to create `CypherQueryExpression` data structure comprised of a Cypher query and\n    respective query parameters.\n\n    Args:\n        query: Cypher query (expression)\n        field_param: Optional parameters to be added to the query execution.\n\n    Returns:\n        Data class with query and parameters if any.\n    \"\"\"\n    params = {field_param.field_param_name: field_param.field_value} if field_param else {}\n    return CypherQueryExpression(query, params)\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._wrap_in_parentheses","title":"_wrap_in_parentheses","text":"<pre><code>_wrap_in_parentheses(\n    *cypher_expressions: str,\n    join_operator: str = \"AND\",\n    prefix_expr: Optional[str] = None\n) -&gt; str\n</code></pre> <p>Wraps given list of Cypher expressions in parentheses and combines them with a given operator which is \"AND\" by default. For example if <code>cypher_expressions=(\"age &gt; $fv_age\", \"height &lt;&gt; $fv_height\")</code> the method will return <code>(\"age &gt; $fv_age AND height &lt;&gt; $fv_height\")</code>.</p> <p>For a single Cypher expression no parentheses are added and no operator is used.</p> <p>Parameters:</p> <ul> <li> <code>join_operator</code>               (<code>str</code>, default:                   <code>'AND'</code> )           \u2013            <p>Logical operator to combine given expressions.</p> </li> <li> <code>prefix_expr</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Additional operators to be added in-front of the final Cypher query. Could be <code>\"NOT \"</code> in order to add negation to the combined expressions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Cypher query expression, wrapped in parentheses if needed.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _wrap_in_parentheses(\n    self, *cypher_expressions: str, join_operator: str = \"AND\", prefix_expr: Optional[str] = None\n) -&gt; str:\n    \"\"\"\n    Wraps given list of Cypher expressions in parentheses and combines them with a given operator which is\n    \"AND\" by default. For example if `:::py cypher_expressions=(\"age &gt; $fv_age\", \"height &lt;&gt; $fv_height\")`\n    the method will return `:::cypher (\"age &gt; $fv_age AND height &lt;&gt; $fv_height\")`.\n\n    For a single Cypher expression no parentheses are added and no operator is used.\n\n    Args:\n        join_operator: Logical operator to combine given expressions.\n        prefix_expr: Additional operators to be added in-front of the final Cypher query. Could be ``\"NOT \"`` in\n            order to add negation to the combined expressions.\n\n    Returns:\n        Cypher query expression, wrapped in parentheses if needed.\n    \"\"\"\n    valid_cypher_expressions = [expr for expr in cypher_expressions if expr]\n\n    # we expect at least one expression to be provided\n    result = valid_cypher_expressions[0]\n\n    if len(valid_cypher_expressions) &gt; 1:\n        logical_expression = f\" {join_operator} \".join(valid_cypher_expressions)\n        result = f\"({logical_expression})\"\n\n    return f\"{prefix_expr}{result}\" if prefix_expr else result\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._field_param","title":"_field_param","text":"<pre><code>_field_param(node: ComparisonOp) -&gt; CypherFieldParam\n</code></pre> <p>Constructs <code>CypherFieldParam</code> data class with aggregated information about comparison operation. Below is an example with resolved attribute values:</p> <pre><code>CypherFieldParam(\n    field_name=\"doc.age\",\n    field_param_name=\"fv_age\",\n    field_param_ref=\"$fv_age\", # to be referenced in Cypher query\n    field_value=10,\n    op=\"&lt;&gt;\", # mapped from \"$ne\" to \"&lt;&gt;\"\n)\n</code></pre> <p>In a simplest case information from <code>CypherFieldParam</code> could be converted into <code>doc.age &lt;&gt; $fv_age</code>, <code>params={\"fv_age\": 10}</code></p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>ComparisonOp</code>)           \u2013            <p>Comparison <code>AST</code> node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CypherFieldParam</code> (              <code>CypherFieldParam</code> )          \u2013            <p>data class with required field parameter metadata.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _field_param(self, node: ComparisonOp) -&gt; CypherFieldParam:\n    \"\"\"\n    Constructs `CypherFieldParam` data class with aggregated information about comparison operation.\n    Below is an example with resolved attribute values:\n\n    ```python\n    CypherFieldParam(\n        field_name=\"doc.age\",\n        field_param_name=\"fv_age\",\n        field_param_ref=\"$fv_age\", # to be referenced in Cypher query\n        field_value=10,\n        op=\"&lt;&gt;\", # mapped from \"$ne\" to \"&lt;&gt;\"\n    )\n    ```\n\n    In a simplest case information from `CypherFieldParam` could be converted into `:::cypher doc.age &lt;&gt; $fv_age`,\n    ``params={\"fv_age\": 10}``\n\n    Args:\n        node: Comparison `AST` node.\n\n    Returns:\n        CypherFieldParam: data class with required field parameter metadata.\n    \"\"\"\n\n    field_name = node.field_name\n    if \".\" in field_name and self._flatten_field_name:\n        field_name = field_name.replace(\".\", \"_\")\n\n    field_param_name = self._generate_param_name(field_name)\n    field_value = self._normalize_field_type(node.field_value)\n\n    return CypherFieldParam(\n        field_name=f\"{self._field_name_prefix}.{field_name}\" if self._field_name_prefix else field_name,\n        field_param_name=field_param_name,\n        field_param_ref=f\"${field_param_name}\",\n        field_value=field_value,\n        op=self.COMPARISON_MAPPING.get(node.op),\n    )\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._normalize_field_type","title":"_normalize_field_type","text":"<pre><code>_normalize_field_type(field_value: FieldValueType) -&gt; FieldValueType\n</code></pre> <p>Adjusts field value type if need. Generally we delegate the type conversion of python field values (data types) to <code>neo4j</code> python driver. This way we reduce amount of logic in the converter and rely on the driver to make sure field value types are properly mapped between Python and Neo4j. In some cases though we can handle additional conversions which are not supported by the driver. See example below:</p> <p>The following Metadata filter query <code>{ \"age\": {30, 20 ,40} }</code> should produce <code>IN</code> Cypher clause, e.g. <code>doc.age IN [20, 30, 40]</code>. However neo4j python driver does not accept <code>set</code> python type, thus we convert it to <code>list</code> to make such filters possible.</p> <p>Parameters:</p> <ul> <li> <code>field_value</code>               (<code>FieldValueType</code>)           \u2013            <p>Field value to be adjusted to be compatible with Neo4j types.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FieldValueType</code>           \u2013            <p>Adjusted field value type if required.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _normalize_field_type(self, field_value: FieldValueType) -&gt; FieldValueType:\n    \"\"\"\n    Adjusts field value type if need. Generally we delegate the type conversion of python field values (data types)\n    to `neo4j` python driver. This way we reduce amount of logic in the converter and rely on the driver to make\n    sure field value types are properly mapped between Python and Neo4j. In some cases though we can handle\n    additional conversions which are not supported by the driver. See example below:\n\n    The following Metadata filter query `:::py { \"age\": {30, 20 ,40} }` should produce `IN` Cypher clause, e.g.\n    `:::cypher doc.age IN [20, 30, 40]`. However neo4j python driver does not accept `set` python type, thus we\n    convert it to `list` to make such filters possible.\n\n    Args:\n        field_value: Field value to be adjusted to be compatible with Neo4j types.\n\n    Returns:\n        Adjusted field value type if required.\n    \"\"\"\n    if isinstance(field_value, set):\n        return sorted(field_value)\n\n    return field_value\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._update_query_parameters","title":"_update_query_parameters","text":"<pre><code>_update_query_parameters(params: Dict[str, Any])\n</code></pre> <p>Updates Cypher query parameters with a given parameter set in <code>params</code>.</p> <p>Parameters:</p> <ul> <li> <code>params</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Parameters to be added to the final set of parameters which will be returned along with the generated Cypher query.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _update_query_parameters(self, params: Dict[str, Any]):\n    \"\"\"\n    Updates Cypher query parameters with a given parameter set in `params`.\n\n    Args:\n        params: Parameters to be added to the final set of parameters which will be returned along with\n            the generated Cypher query.\n    \"\"\"\n    self._params.update(params)\n</code></pre>"},{"location":"reference/metadata_filter/neo4j_query_converter/#neo4j_haystack.metadata_filter.neo4j_query_converter.Neo4jQueryConverter._generate_param_name","title":"_generate_param_name","text":"<pre><code>_generate_param_name(field_name: str) -&gt; str\n</code></pre> <p>Generates a new Cypher query parameter name ensuring it is unique in a given parameter dictionary <code>self._params</code>. For example if <code>self._params</code> is equal to <code>{ \"fv_age\": 20 }</code> a new parameter name called <code>fv_age_1</code> will be generated by adding appropriate incremented index.</p> <p>Parameters:</p> <ul> <li> <code>field_name</code>               (<code>str</code>)           \u2013            <p>The nme of the filed to be generated. <code>\"fv_\"</code> prefix is added to all fields to avoid collisions with parameters given during Cypher query execution.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A new parameter name, with an unique index if needed.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/neo4j_query_converter.py</code> <pre><code>def _generate_param_name(self, field_name: str) -&gt; str:\n    \"\"\"\n    Generates a new Cypher query parameter name ensuring it is unique in a given parameter dictionary\n    `self._params`. For example if `self._params` is equal to ``{ \"fv_age\": 20 }`` a new parameter name called\n    ``fv_age_1`` will be generated by adding appropriate incremented index.\n\n    Args:\n        field_name: The nme of the filed to be generated. ``\"fv_\"`` prefix is added to all fields to avoid\n            collisions with parameters given during Cypher query execution.\n\n    Returns:\n        A new parameter name, with an unique index if needed.\n    \"\"\"\n    i = 0\n    field_param_name = f\"fv_{field_name}\"\n    while field_param_name in self._params:\n        i += 1\n        field_param_name = f\"fv_{field_name}_{i}\"\n    return field_param_name\n</code></pre>"},{"location":"reference/metadata_filter/parser/","title":"FilterParser","text":""},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.AST","title":"AST","text":"<p>A base class for nodes of an abstract syntax tree for metadata filters. Its <code>descriptor</code> property provides a python friendly name (e.g. potentially used as a method name)</p> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>class AST:\n    \"\"\"\n    A base class for nodes of an abstract syntax tree for metadata filters. Its `descriptor` property provides a python\n    friendly name (e.g. potentially used as a method name)\n    \"\"\"\n\n    @property\n    def descriptor(self) -&gt; str:\n        return type(self).__name__.lower()\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.LogicalOp","title":"LogicalOp","text":"<p>               Bases: <code>AST</code></p> <p><code>AST</code> node which represents a logical operator e.g. \"AND\", \"OR\", \"NOT\". Logical operator is comprised of an operator (e.g. \"AND\") and respective operands - expressions participating in the logical evaluation syntax. For example one could read it the following way: <code>\"operand1 AND operand2\"</code>, where <code>\"AND\"</code> is the operator and <code>\"operand1\", \"operand2\"</code> are <code>AST</code> nodes which might evaluate into:</p> <ul> <li>simple expressions like <code>\"field1 = 1 AND field2 &gt;= 2\"</code></li> <li>more complex expressions like <code>\"(field1 = 1 OR field2 &lt; 4) AND field3 &gt; 2\"</code></li> </ul> <p>Please notice the actual representation of expressions is managed by a separate component which knows how to parse the syntax tree and translate its nodes (<code>AST</code>) into DocumentStore's specific filtering syntax.</p> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>class LogicalOp(AST):\n    \"\"\"\n    `AST` node which represents a logical operator e.g. \"AND\", \"OR\", \"NOT\".\n    Logical operator is comprised of an operator (e.g. \"AND\") and respective operands - expressions participating in\n    the logical evaluation syntax. For example one could read it the following way: ``\"operand1 AND operand2\"``, where\n    ``\"AND\"`` is the operator and ``\"operand1\", \"operand2\"`` are `AST` nodes which might evaluate into:\n\n    * simple expressions like ``\"field1 = 1 AND field2 &gt;= 2\"``\n    * more complex expressions like ``\"(field1 = 1 OR field2 &lt; 4) AND field3 &gt; 2\"``\n\n    Please notice the actual representation of expressions is managed by a separate component which knows how to parse\n    the syntax tree and translate its nodes (`AST`) into DocumentStore's specific filtering syntax.\n    \"\"\"\n\n    def __init__(self, operands: Sequence[AST], op: str):\n        if OpType.from_op(op) != OpType.LOGICAL:\n            raise Neo4jFilterParserError(\n                f\"The '{op}' logical operator is not supported. Consider using one of: {LOGICAL_OPS}.\"\n            )\n\n        self.operands = operands\n        self.op = op\n\n    @property\n    def descriptor(self) -&gt; str:\n        return \"logical_op\"\n\n    def __repr__(self):\n        return f\"&lt;LogicalOp {self.op=}, {self.operands=}&gt;\"\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.ComparisonOp","title":"ComparisonOp","text":"<p>               Bases: <code>AST</code></p> <p>This <code>AST</code> node represents a comparison operator in filters syntax tree (e.g. \"==\", \"in\", \"&lt;=\" etc). Comparison operator is comprised of an operator, a field name and field value. For example one could read it in the following way: <code>\"age == 20\"</code>, where</p> <ul> <li><code>\"==\"</code> - is the operator</li> <li><code>\"age\"</code> - is a field name</li> <li>\"20\" - is a comparison value.</li> </ul> <p>Please notice the actual representation of comparison expressions is managed by a separate component which knows how to translate the <code>ComparisonOp</code> into DocumentStore's specific filtering syntax.</p> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>class ComparisonOp(AST):\n    \"\"\"\n    This `AST` node represents a comparison operator in filters syntax tree (e.g. \"==\", \"in\", \"&lt;=\" etc).\n    Comparison operator is comprised of an operator, a field name and field value. For example one could\n    read it in the following way: ``\"age == 20\"``, where\n\n    - ``\"==\"`` - is the operator\n    - ``\"age\"`` - is a field name\n    - \"20\" - is a comparison value.\n\n    Please notice the actual representation of comparison expressions is managed by a separate component which knows how\n    to translate the `ComparisonOp` into DocumentStore's specific filtering syntax.\n    \"\"\"\n\n    def __init__(self, field_name: str, op: str, field_value: FieldValueType):\n        if OpType.from_op(op) != OpType.COMPARISON:\n            raise Neo4jFilterParserError(\n                f\"The '{op}' comparison operator is not supported. Consider using one of: {COMPARISON_OPS}.\"\n            )\n\n        self.field_name = field_name\n        self.op = op\n        self.field_value = field_value\n\n    @property\n    def descriptor(self) -&gt; str:\n        return \"comparison_op\"\n\n    def __repr__(self):\n        return f\"&lt;ComparisonOp {self.field_name=}, {self.op=}, {self.field_value=}&gt;\"\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.FilterParser","title":"FilterParser","text":"<p>The implementation of metadata filter parser into an abstract syntax tree comprised of respective <code>AST</code> nodes. The tree structure has a single root node and, depending on actual filters provided, can result into a number of Logical nodes as well as Comparison (leaf) nodes. The parsing logic takes into consideration rules documented in the following document Metadata Filtering.</p> <p><code>FilterParser</code> does not depend on actual DocumentStore implementation. Its single purpose is to parse filters into a tree of <code>AST</code> nodes by applying metadata filtering rules (including default operators behavior).</p> <p>With a given example of a metadata filter parsing below:</p> <pre><code>filters = {\n    \"operator\": \"OR\",\n    \"conditions\": [\n        {\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"news\"},\n                {\"field\": \"meta.likes\", \"operator\": \"!=\", \"value\": 100},\n            ],\n        },\n        {\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"blog\"},\n                {\"field\": \"meta.likes\", \"operator\": \"&gt;=\", \"value\": 500},\n            ],\n        },\n    ],\n}\nop_tree = FilterParser().parse(filters)\n</code></pre> <p>We should expect the following tree structure (<code>op_tree</code>) after parsing:</p> <pre><code>                                        +-------------+\n                                        | &lt;LogicalOp&gt; |\n                                        |  op: \"OR\"   |\n                                        +-------------+\n                          +-------------+  operands   +----------------+\n                          |             +-------------+                |\n                          |                                            |\n                    +-----+-------+                              +-----+-------+\n                    | &lt;LogicalOp&gt; |                              | &lt;LogicalOp&gt; |\n                    |  op: \"AND\"  |                              |  op: \"AND\"  |\n                    +-------------+                              +-------------+\n           +--------+  operands   +----+                 +-------+  operands   +-------+\n           |        +-------------+    |                 |       +-------------+       |\n           |                           |                 |                             |\n+----------+---------+  +--------------+------+   +------+-------------+   +-----------+---------+\n|   &lt;ComparisonOp&gt;   |  |   &lt;ComparisonOp&gt;    |   |   &lt;ComparisonOp&gt;   |   |   &lt;ComparisonOp&gt;    |\n|                    |  |                     |   |                    |   |                     |\n| field_name: \"type\" |  | field_name: \"likes\" |   | field_name: \"type\" |   | field_name: \"likes\" |\n| op: \"==\"           |  | op: \"&gt;=\"            |   | op: \"==\"           |   | op: \"!=\"            |\n| field_value: \"blog\"|  | field_value: 500    |   | field_value: \"news\"|   | field_value: 100    |\n+--------------------+  +---------------------+   +--------------------+   +---------------------+\n</code></pre> <p>Having such a tree DocumentStore should be able to traverse it and interpret into a Document Store specific syntax.</p> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>class FilterParser:\n    \"\"\"\n    The implementation of metadata filter parser into an abstract syntax tree comprised of respective\n    `AST` nodes. The tree structure has a single root node and, depending on actual filters provided, can result\n    into a number of Logical nodes as well as Comparison (leaf) nodes. The parsing logic takes into consideration rules\n    documented in the following document [Metadata Filtering](https://docs.haystack.deepset.ai/v2.0/docs/metadata-filtering).\n\n    `FilterParser` does not depend on actual DocumentStore implementation. Its single purpose is to parse filters into a\n    tree of `AST` nodes by applying metadata filtering rules (including default operators behavior).\n\n    With a given example of a metadata filter parsing below:\n\n    ```py\n    filters = {\n        \"operator\": \"OR\",\n        \"conditions\": [\n            {\n                \"operator\": \"AND\",\n                \"conditions\": [\n                    {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"news\"},\n                    {\"field\": \"meta.likes\", \"operator\": \"!=\", \"value\": 100},\n                ],\n            },\n            {\n                \"operator\": \"AND\",\n                \"conditions\": [\n                    {\"field\": \"meta.type\", \"operator\": \"==\", \"value\": \"blog\"},\n                    {\"field\": \"meta.likes\", \"operator\": \"&gt;=\", \"value\": 500},\n                ],\n            },\n        ],\n    }\n    op_tree = FilterParser().parse(filters)\n    ```\n\n    We should expect the following tree structure (`op_tree`) after parsing:\n\n    ```console\n                                            +-------------+\n                                            | &lt;LogicalOp&gt; |\n                                            |  op: \"OR\"   |\n                                            +-------------+\n                              +-------------+  operands   +----------------+\n                              |             +-------------+                |\n                              |                                            |\n                        +-----+-------+                              +-----+-------+\n                        | &lt;LogicalOp&gt; |                              | &lt;LogicalOp&gt; |\n                        |  op: \"AND\"  |                              |  op: \"AND\"  |\n                        +-------------+                              +-------------+\n               +--------+  operands   +----+                 +-------+  operands   +-------+\n               |        +-------------+    |                 |       +-------------+       |\n               |                           |                 |                             |\n    +----------+---------+  +--------------+------+   +------+-------------+   +-----------+---------+\n    |   &lt;ComparisonOp&gt;   |  |   &lt;ComparisonOp&gt;    |   |   &lt;ComparisonOp&gt;   |   |   &lt;ComparisonOp&gt;    |\n    |                    |  |                     |   |                    |   |                     |\n    | field_name: \"type\" |  | field_name: \"likes\" |   | field_name: \"type\" |   | field_name: \"likes\" |\n    | op: \"==\"           |  | op: \"&gt;=\"            |   | op: \"==\"           |   | op: \"!=\"            |\n    | field_value: \"blog\"|  | field_value: 500    |   | field_value: \"news\"|   | field_value: 100    |\n    +--------------------+  +---------------------+   +--------------------+   +---------------------+\n    ```\n\n    Having such a tree DocumentStore should be able to traverse it and interpret into a Document Store specific syntax.\n    \"\"\"\n\n    def __init__(self, flatten_field_name=True) -&gt; None:\n        self.flatten_field_name = flatten_field_name\n\n    def comparison_op(self, field_name: str, op: str, field_value: FieldValueType) -&gt; ComparisonOp:\n        return ComparisonOp(field_name, op, field_value)\n\n    def logical_op(self, op: str, operands: Sequence[AST]) -&gt; LogicalOp:\n        return LogicalOp(operands, op)\n\n    def combine(self, *operands: Optional[OperatorAST], default_op: str = LOGICAL_OPS.OP_AND) -&gt; Optional[OperatorAST]:\n        \"\"\"\n        Combines several operands (standalone filter values) into a logical operator if number of operands is greater\n        than one. Operands with `None` value are skipped (e.g. empty strings).\n\n        Args:\n            default_op: Default operator to be used to construct the `LogicalOp`, defaults to `OP_AND`\n\n        Returns:\n            Logical operator with `operands` or the operand itself if it is the only provided in arguments.\n        \"\"\"\n        valid_operands = [op for op in operands if op]\n\n        if len(valid_operands) == 0:\n            return None\n\n        return valid_operands[0] if len(valid_operands) == 1 else self.logical_op(default_op, valid_operands)\n\n    def _parse_comparison_op(self, filters: FilterType) -&gt; ComparisonOp:\n        \"\"\"\n        Parsing a comparison operator dictionary.\n\n        Args:\n            filters: Comparison filter dictionary with `field`, `operator` and `value` keys expected.\n\n        Raises:\n            Neo4jFilterParserError: If required `field` or `value` comparison dictionary keys are missing.\n\n        Returns:\n           `AST` node representing the comparison expression in abstract syntax tree.\n        \"\"\"\n\n        operator = filters[\"operator\"]\n        field_name = filters.get(\"field\")\n        filter_value = filters.get(\"value\")\n\n        if not field_name:\n            raise Neo4jFilterParserError(f\"`field` is mandatory in comparison filter dictionary: `{filters}`.\")\n\n        if filter_value is None:\n            raise Neo4jFilterParserError(f\"`value` is mandatory in comparison filter dictionary: `{filters}`.\")\n\n        return self.comparison_op(field_name, operator, filter_value)\n\n    def _parse_logical_op(self, filters: FilterType) -&gt; LogicalOp:\n        \"\"\"\n        This method is responsible of parsing logical operators. It returns `LogicalOp` with specific operator\n        (e.g. \"OR\") and its operands (list of `AST` nodes). Operands are parsed by calling `:::py self._parse_tree`\n        which might result in further recursive parsing flow.\n\n        Args:\n            filters: Logical filter with conditions.\n\n        Raises:\n            Neo4jFilterParserError: If required `conditions` logic dictionary key is missing or is not a `list` with at\n                least one item.\n\n        Returns:\n            The instance of `LogicalOp` with the list parsed operands.\n        \"\"\"\n\n        op = filters[\"operator\"]\n        conditions = filters.get(\"conditions\")\n\n        if not conditions or not isinstance(conditions, list) or len(conditions) &lt; 1:\n            raise Neo4jFilterParserError(\"Can not parse logical operator with empty or absent conditions\")\n\n        operands: List[AST] = [self._parse_tree(condition) for condition in conditions]\n\n        return self.logical_op(op, operands)\n\n    def _parse_tree(self, filters: FilterType) -&gt; OperatorAST:\n        \"\"\"\n        This parses filters dictionary and identifies operations based on its \"operator\" type,\n        e.g. \"AND\" would be resolved to a logical operator type (`OpType.LOGICAL`). Once recognized the parsing\n        of the operator and its filter will be delegated to a respective method (e.g. `self._parse_logical_op` or\n        `self._parse_comparison_op`).\n\n        Args:\n            filters: Metadata filters dictionary. Could be the full filter value or a smaller filters chunk.\n\n        Raises:\n            Neo4jFilterParserError: If required `operator` dictionary key is missing.\n            Neo4jFilterParserError: If `filters` is not a dictionary.\n            Neo4jFilterParserError: If operator value is unknown.\n\n        Returns:\n            A root `AST` node of parsed filter.\n        \"\"\"\n\n        if not isinstance(filters, dict):\n            raise Neo4jFilterParserError(\"Filter must be a dictionary.\")\n\n        if \"operator\" not in filters:\n            raise Neo4jFilterParserError(\"`operator` must ne present in both comparison and logic dictionaries.\")\n\n        operator = filters[\"operator\"]\n        op_type = OpType.from_op(operator)\n\n        if op_type == OpType.LOGICAL:\n            return self._parse_logical_op(filters)\n        elif op_type == OpType.COMPARISON:\n            return self._parse_comparison_op(filters)\n        else:\n            raise Neo4jFilterParserError(\n                f\"Unknown operator({operator}) in filter dictionary. Should be either \"\n                f\"comparison({COMPARISON_OPS}) or logical({LOGICAL_OPS})\"\n            )\n\n    def parse(self, filters: FilterType) -&gt; OperatorAST:\n        \"\"\"\n        This is the entry point to parse a given metadata filter into an abstract syntax tree. The implementation\n        delegates the parsing logic to the private `self._parse_tree` method.\n\n        Args:\n            filters: Metadata filters to be parsed.\n\n        Raises:\n            Neo4jFilterParserError: In case parsing results in empty `AST` tree or more than one root node has been\n                created after parsing.\n\n        Returns:\n            Abstract syntax tree representing `filters`. You should expect a single root operator returned, which\n            could used to traverse the whole tree.\n        \"\"\"\n\n        return self._parse_tree(filters)\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.FilterParser.combine","title":"combine","text":"<pre><code>combine(\n    *operands: Optional[OperatorAST], default_op: str = LOGICAL_OPS.OP_AND\n) -&gt; Optional[OperatorAST]\n</code></pre> <p>Combines several operands (standalone filter values) into a logical operator if number of operands is greater than one. Operands with <code>None</code> value are skipped (e.g. empty strings).</p> <p>Parameters:</p> <ul> <li> <code>default_op</code>               (<code>str</code>, default:                   <code>OP_AND</code> )           \u2013            <p>Default operator to be used to construct the <code>LogicalOp</code>, defaults to <code>OP_AND</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[OperatorAST]</code>           \u2013            <p>Logical operator with <code>operands</code> or the operand itself if it is the only provided in arguments.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>def combine(self, *operands: Optional[OperatorAST], default_op: str = LOGICAL_OPS.OP_AND) -&gt; Optional[OperatorAST]:\n    \"\"\"\n    Combines several operands (standalone filter values) into a logical operator if number of operands is greater\n    than one. Operands with `None` value are skipped (e.g. empty strings).\n\n    Args:\n        default_op: Default operator to be used to construct the `LogicalOp`, defaults to `OP_AND`\n\n    Returns:\n        Logical operator with `operands` or the operand itself if it is the only provided in arguments.\n    \"\"\"\n    valid_operands = [op for op in operands if op]\n\n    if len(valid_operands) == 0:\n        return None\n\n    return valid_operands[0] if len(valid_operands) == 1 else self.logical_op(default_op, valid_operands)\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.FilterParser._parse_comparison_op","title":"_parse_comparison_op","text":"<pre><code>_parse_comparison_op(filters: FilterType) -&gt; ComparisonOp\n</code></pre> <p>Parsing a comparison operator dictionary.</p> <p>Parameters:</p> <ul> <li> <code>filters</code>               (<code>FilterType</code>)           \u2013            <p>Comparison filter dictionary with <code>field</code>, <code>operator</code> and <code>value</code> keys expected.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Neo4jFilterParserError</code>             \u2013            <p>If required <code>field</code> or <code>value</code> comparison dictionary keys are missing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComparisonOp</code>           \u2013            <p><code>AST</code> node representing the comparison expression in abstract syntax tree.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>def _parse_comparison_op(self, filters: FilterType) -&gt; ComparisonOp:\n    \"\"\"\n    Parsing a comparison operator dictionary.\n\n    Args:\n        filters: Comparison filter dictionary with `field`, `operator` and `value` keys expected.\n\n    Raises:\n        Neo4jFilterParserError: If required `field` or `value` comparison dictionary keys are missing.\n\n    Returns:\n       `AST` node representing the comparison expression in abstract syntax tree.\n    \"\"\"\n\n    operator = filters[\"operator\"]\n    field_name = filters.get(\"field\")\n    filter_value = filters.get(\"value\")\n\n    if not field_name:\n        raise Neo4jFilterParserError(f\"`field` is mandatory in comparison filter dictionary: `{filters}`.\")\n\n    if filter_value is None:\n        raise Neo4jFilterParserError(f\"`value` is mandatory in comparison filter dictionary: `{filters}`.\")\n\n    return self.comparison_op(field_name, operator, filter_value)\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.FilterParser._parse_logical_op","title":"_parse_logical_op","text":"<pre><code>_parse_logical_op(filters: FilterType) -&gt; LogicalOp\n</code></pre> <p>This method is responsible of parsing logical operators. It returns <code>LogicalOp</code> with specific operator (e.g. \"OR\") and its operands (list of <code>AST</code> nodes). Operands are parsed by calling <code>self._parse_tree</code> which might result in further recursive parsing flow.</p> <p>Parameters:</p> <ul> <li> <code>filters</code>               (<code>FilterType</code>)           \u2013            <p>Logical filter with conditions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Neo4jFilterParserError</code>             \u2013            <p>If required <code>conditions</code> logic dictionary key is missing or is not a <code>list</code> with at least one item.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LogicalOp</code>           \u2013            <p>The instance of <code>LogicalOp</code> with the list parsed operands.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>def _parse_logical_op(self, filters: FilterType) -&gt; LogicalOp:\n    \"\"\"\n    This method is responsible of parsing logical operators. It returns `LogicalOp` with specific operator\n    (e.g. \"OR\") and its operands (list of `AST` nodes). Operands are parsed by calling `:::py self._parse_tree`\n    which might result in further recursive parsing flow.\n\n    Args:\n        filters: Logical filter with conditions.\n\n    Raises:\n        Neo4jFilterParserError: If required `conditions` logic dictionary key is missing or is not a `list` with at\n            least one item.\n\n    Returns:\n        The instance of `LogicalOp` with the list parsed operands.\n    \"\"\"\n\n    op = filters[\"operator\"]\n    conditions = filters.get(\"conditions\")\n\n    if not conditions or not isinstance(conditions, list) or len(conditions) &lt; 1:\n        raise Neo4jFilterParserError(\"Can not parse logical operator with empty or absent conditions\")\n\n    operands: List[AST] = [self._parse_tree(condition) for condition in conditions]\n\n    return self.logical_op(op, operands)\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.FilterParser._parse_tree","title":"_parse_tree","text":"<pre><code>_parse_tree(filters: FilterType) -&gt; OperatorAST\n</code></pre> <p>This parses filters dictionary and identifies operations based on its \"operator\" type, e.g. \"AND\" would be resolved to a logical operator type (<code>OpType.LOGICAL</code>). Once recognized the parsing of the operator and its filter will be delegated to a respective method (e.g. <code>self._parse_logical_op</code> or <code>self._parse_comparison_op</code>).</p> <p>Parameters:</p> <ul> <li> <code>filters</code>               (<code>FilterType</code>)           \u2013            <p>Metadata filters dictionary. Could be the full filter value or a smaller filters chunk.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Neo4jFilterParserError</code>             \u2013            <p>If required <code>operator</code> dictionary key is missing.</p> </li> <li> <code>Neo4jFilterParserError</code>             \u2013            <p>If <code>filters</code> is not a dictionary.</p> </li> <li> <code>Neo4jFilterParserError</code>             \u2013            <p>If operator value is unknown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OperatorAST</code>           \u2013            <p>A root <code>AST</code> node of parsed filter.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>def _parse_tree(self, filters: FilterType) -&gt; OperatorAST:\n    \"\"\"\n    This parses filters dictionary and identifies operations based on its \"operator\" type,\n    e.g. \"AND\" would be resolved to a logical operator type (`OpType.LOGICAL`). Once recognized the parsing\n    of the operator and its filter will be delegated to a respective method (e.g. `self._parse_logical_op` or\n    `self._parse_comparison_op`).\n\n    Args:\n        filters: Metadata filters dictionary. Could be the full filter value or a smaller filters chunk.\n\n    Raises:\n        Neo4jFilterParserError: If required `operator` dictionary key is missing.\n        Neo4jFilterParserError: If `filters` is not a dictionary.\n        Neo4jFilterParserError: If operator value is unknown.\n\n    Returns:\n        A root `AST` node of parsed filter.\n    \"\"\"\n\n    if not isinstance(filters, dict):\n        raise Neo4jFilterParserError(\"Filter must be a dictionary.\")\n\n    if \"operator\" not in filters:\n        raise Neo4jFilterParserError(\"`operator` must ne present in both comparison and logic dictionaries.\")\n\n    operator = filters[\"operator\"]\n    op_type = OpType.from_op(operator)\n\n    if op_type == OpType.LOGICAL:\n        return self._parse_logical_op(filters)\n    elif op_type == OpType.COMPARISON:\n        return self._parse_comparison_op(filters)\n    else:\n        raise Neo4jFilterParserError(\n            f\"Unknown operator({operator}) in filter dictionary. Should be either \"\n            f\"comparison({COMPARISON_OPS}) or logical({LOGICAL_OPS})\"\n        )\n</code></pre>"},{"location":"reference/metadata_filter/parser/#neo4j_haystack.metadata_filter.parser.FilterParser.parse","title":"parse","text":"<pre><code>parse(filters: FilterType) -&gt; OperatorAST\n</code></pre> <p>This is the entry point to parse a given metadata filter into an abstract syntax tree. The implementation delegates the parsing logic to the private <code>self._parse_tree</code> method.</p> <p>Parameters:</p> <ul> <li> <code>filters</code>               (<code>FilterType</code>)           \u2013            <p>Metadata filters to be parsed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Neo4jFilterParserError</code>             \u2013            <p>In case parsing results in empty <code>AST</code> tree or more than one root node has been created after parsing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OperatorAST</code>           \u2013            <p>Abstract syntax tree representing <code>filters</code>. You should expect a single root operator returned, which</p> </li> <li> <code>OperatorAST</code>           \u2013            <p>could used to traverse the whole tree.</p> </li> </ul> Source code in <code>src/neo4j_haystack/metadata_filter/parser.py</code> <pre><code>def parse(self, filters: FilterType) -&gt; OperatorAST:\n    \"\"\"\n    This is the entry point to parse a given metadata filter into an abstract syntax tree. The implementation\n    delegates the parsing logic to the private `self._parse_tree` method.\n\n    Args:\n        filters: Metadata filters to be parsed.\n\n    Raises:\n        Neo4jFilterParserError: In case parsing results in empty `AST` tree or more than one root node has been\n            created after parsing.\n\n    Returns:\n        Abstract syntax tree representing `filters`. You should expect a single root operator returned, which\n        could used to traverse the whole tree.\n    \"\"\"\n\n    return self._parse_tree(filters)\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/","title":"Neo4jQueryParametersMarshaller","text":""},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.DocumentQueryParametersMarshaller","title":"DocumentQueryParametersMarshaller","text":"<p>               Bases: <code>QueryParametersMarshaller</code></p> <p>A marshaller which converts <code>haystack.Document</code> to a dictionary when it is used as query parameter in Cypher query</p> <p>Haystack's native <code>to_dict</code> method is called to produce a flattened dictionary of Document data along with its meta fields.</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>class DocumentQueryParametersMarshaller(QueryParametersMarshaller):\n    \"\"\"\n    A marshaller which converts `haystack.Document` to a dictionary when it is used as query parameter in Cypher query\n\n    Haystack's native `to_dict` method is called to produce a flattened dictionary of Document data along with its meta\n    fields.\n    \"\"\"\n\n    def supports(self, obj: Any) -&gt; bool:\n        \"\"\"\n        Checks if given object is `haystack.Document` instance\n        \"\"\"\n        return isinstance(obj, Document)\n\n    def marshal(self, obj: Any) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts `haystack.Document` to dictionary so it could be used as Cypher query parameter\n        \"\"\"\n        return obj.to_dict(flatten=True)\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.DocumentQueryParametersMarshaller.supports","title":"supports","text":"<pre><code>supports(obj: Any) -&gt; bool\n</code></pre> <p>Checks if given object is <code>haystack.Document</code> instance</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>def supports(self, obj: Any) -&gt; bool:\n    \"\"\"\n    Checks if given object is `haystack.Document` instance\n    \"\"\"\n    return isinstance(obj, Document)\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.DocumentQueryParametersMarshaller.marshal","title":"marshal","text":"<pre><code>marshal(obj: Any) -&gt; Dict[str, Any]\n</code></pre> <p>Converts <code>haystack.Document</code> to dictionary so it could be used as Cypher query parameter</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>def marshal(self, obj: Any) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts `haystack.Document` to dictionary so it could be used as Cypher query parameter\n    \"\"\"\n    return obj.to_dict(flatten=True)\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.ChatMessageParametersMarshaller","title":"ChatMessageParametersMarshaller","text":"<p>               Bases: <code>QueryParametersMarshaller</code></p> <p>A marshaller which converts <code>haystack.dataclasses.chat_message.ChatMessage</code> to a dictionary when it is used as query parameter in Cypher queries</p> <p>Haystack's native <code>to_dict</code> method is called to produce a dictionary of Document data along with its meta fields.</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>class ChatMessageParametersMarshaller(QueryParametersMarshaller):\n    \"\"\"\n    A marshaller which converts `haystack.dataclasses.chat_message.ChatMessage` to a dictionary when it is used as\n    query parameter in Cypher queries\n\n    Haystack's native `to_dict` method is called to produce a dictionary of Document data along with its meta\n    fields.\n    \"\"\"\n\n    def supports(self, obj: Any) -&gt; bool:\n        return isinstance(obj, ChatMessage)\n\n    def marshal(self, obj: Any) -&gt; Dict[str, Any]:\n        return obj.to_dict()\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.DataclassQueryParametersMarshaller","title":"DataclassQueryParametersMarshaller","text":"<p>               Bases: <code>QueryParametersMarshaller</code></p> <p>A marshaller which converts a <code>dataclass</code> to a dictionary when encountered as Cypher query parameter.</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>class DataclassQueryParametersMarshaller(QueryParametersMarshaller):\n    \"\"\"\n    A marshaller which converts a `dataclass` to a dictionary when encountered as Cypher query parameter.\n    \"\"\"\n\n    def supports(self, obj: Any) -&gt; bool:\n        \"\"\"\n        Checks if given object is a python `dataclass` instance\n        \"\"\"\n        return is_dataclass(obj) and not isinstance(obj, type)\n\n    def marshal(self, obj: Any) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts `dataclass` to dictionary so it could be used as Cypher query parameter.\n        \"\"\"\n        return asdict(obj)\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.DataclassQueryParametersMarshaller.supports","title":"supports","text":"<pre><code>supports(obj: Any) -&gt; bool\n</code></pre> <p>Checks if given object is a python <code>dataclass</code> instance</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>def supports(self, obj: Any) -&gt; bool:\n    \"\"\"\n    Checks if given object is a python `dataclass` instance\n    \"\"\"\n    return is_dataclass(obj) and not isinstance(obj, type)\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.DataclassQueryParametersMarshaller.marshal","title":"marshal","text":"<pre><code>marshal(obj: Any) -&gt; Dict[str, Any]\n</code></pre> <p>Converts <code>dataclass</code> to dictionary so it could be used as Cypher query parameter.</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>def marshal(self, obj: Any) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts `dataclass` to dictionary so it could be used as Cypher query parameter.\n    \"\"\"\n    return asdict(obj)\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.Neo4jQueryParametersMarshaller","title":"Neo4jQueryParametersMarshaller","text":"<p>               Bases: <code>QueryParametersMarshaller</code></p> <p>The marshaller converts Cypher query parameters to types which can be consumed in Neo4j query execution. In some cases query parameters contain complex data types (e.g. dataclasses) which can be converted to <code>dict</code> types and thus become eligible for running a Cypher query:</p> <p>Example: Running a query with a dataclass parameter<pre><code>from dataclasses import dataclass\nfrom neo4j_haystack.client import Neo4jClient, Neo4jClientConfig\nfrom neo4j_haystack.serialization import Neo4jQueryParametersMarshaller\n\n@dataclass\nclass YearInfo:\n    year: int = 2024\n\nneo4j_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\nneo4j_client = Neo4jClient(client_config=neo4j_config)\n\nmarshaller = Neo4jQueryParametersMarshaller()\nquery_params = marshaller.marshall({\"year_info\": YearInfo()})\n\nneo4j_client.execute_read(\n    \"MATCH (doc:`Document`) WHERE doc.year=$year_info.year RETURN doc\",\n    parameters=query_params\n)\n</code></pre> The above example would fail without marshaller. With marshaller <code>query_params</code> will become <code>{\"year_info\": {\"year\": 2024}}</code> which is eligible input for Neo4j Driver.</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>class Neo4jQueryParametersMarshaller(QueryParametersMarshaller):\n    \"\"\"\n    The marshaller converts Cypher query parameters to types which can be consumed in Neo4j query execution. In some\n    cases query parameters contain complex data types (e.g. dataclasses) which can be converted to `dict` types and\n    thus become eligible for running a Cypher query:\n\n    ```py title=\"Example: Running a query with a dataclass parameter\"\n    from dataclasses import dataclass\n    from neo4j_haystack.client import Neo4jClient, Neo4jClientConfig\n    from neo4j_haystack.serialization import Neo4jQueryParametersMarshaller\n\n    @dataclass\n    class YearInfo:\n        year: int = 2024\n\n    neo4j_config = Neo4jClientConfig(\"bolt://localhost:7687\", database=\"neo4j\", username=\"neo4j\", password=\"passw0rd\")\n    neo4j_client = Neo4jClient(client_config=neo4j_config)\n\n    marshaller = Neo4jQueryParametersMarshaller()\n    query_params = marshaller.marshall({\"year_info\": YearInfo()})\n\n    neo4j_client.execute_read(\n        \"MATCH (doc:`Document`) WHERE doc.year=$year_info.year RETURN doc\",\n        parameters=query_params\n    )\n    ```\n    The above example would fail without marshaller. With marshaller `query_params` will become\n    `:::py {\"year_info\": {\"year\": 2024}}` which is eligible input for Neo4j Driver.\n    \"\"\"\n\n    def __init__(self):\n        # Order of marshallers is important - first one which supports the type will be used\n        self._marshallers = [\n            DocumentQueryParametersMarshaller(),\n            ChatMessageParametersMarshaller(),\n            DataclassQueryParametersMarshaller(),\n        ]\n\n    def supports(self, _obj: Any) -&gt; bool:\n        \"\"\"\n        Supports conversion of any type\n        \"\"\"\n        return True\n\n    def marshal(self, data) -&gt; Any:\n        if isinstance(data, dict):\n            return {key: self.marshal(value) for key, value in data.items()}\n        elif isinstance(data, (list, tuple, set)):\n            return [self.marshal(value) for value in data]\n\n        # Find a marshaller which supports given type of parameter otherwise return parameter as is\n        marshaller = next((m for m in self._marshallers if m.supports(data)), None)\n\n        return self.marshal(marshaller.marshal(data)) if marshaller else data\n</code></pre>"},{"location":"reference/serialization/query_parameters_marshaller/#neo4j_haystack.serialization.query_parameters_marshaller.Neo4jQueryParametersMarshaller.supports","title":"supports","text":"<pre><code>supports(_obj: Any) -&gt; bool\n</code></pre> <p>Supports conversion of any type</p> Source code in <code>src/neo4j_haystack/serialization/query_parameters_marshaller.py</code> <pre><code>def supports(self, _obj: Any) -&gt; bool:\n    \"\"\"\n    Supports conversion of any type\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/serialization/types/","title":"types","text":""},{"location":"reference/serialization/types/#neo4j_haystack.serialization.types.QueryParametersMarshaller","title":"QueryParametersMarshaller","text":"<p>               Bases: <code>Protocol</code></p> <p>A Protocol to be used by marshaller implementations which convert Neo4j query parameters to appropriate types.</p> Source code in <code>src/neo4j_haystack/serialization/types.py</code> <pre><code>class QueryParametersMarshaller(Protocol):\n    \"\"\"\n    A Protocol to be used by marshaller implementations which convert Neo4j query parameters to appropriate types.\n    \"\"\"\n\n    def supports(self, obj: Any) -&gt; bool:\n        pass\n\n    def marshal(self, obj: Any) -&gt; Any:\n        pass\n</code></pre>"}]}